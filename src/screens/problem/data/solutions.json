{
    "1": {
      "solution": {
        "hash-table": ""
      }
    },
    "2": {
      "solution": {
        "linked-list": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummy = new ListNode();\n        ListNode* current = dummy;\n        int carry = 0;\n\n        while (l1 != nullptr || l2 != nullptr || carry > 0) {\n            int sum = carry;\n\n            if (l1 != nullptr) {\n                sum += l1->val;\n                l1 = l1->next;\n            }\n            if (l2 != nullptr) {\n                sum += l2->val;\n                l2 = l2->next;\n            }\n\n            carry = sum / 10;\n            current->next = new ListNode(sum % 10);\n\n            current = current->next;\n        }\n\n        return dummy->next;\n    }\n};\n"
      }
    },
    "3": {
      "solution": {
        "sliding-window": "public class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int[] charIndex = new int[128]; \n        int left = 0, right = 0;\n        int maxLength = 0;\n\n        while (right < s.length()) {\n            char right = s.charAt(right);\n            left = Math.max(charIndex[right], left);\n            maxLength = Math.max(maxLength, right - left + 1);\n            charIndex[right] = right + 1;\n            right++;\n        }\n\n        return maxLength;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        String input = \"abcabcbb\";\n        int result = sol.lengthOfLongestSubstring(input);\n        System.out.println(\"Length of Longest Substring Without Repeating Characters: \" + result);\n    }\n}"
      }
    },
    "4": {
      "solution": {
        "divide-and-conquer": "public class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        if (nums1.length > nums2.length) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n\n        int x = nums1.length;\n        int y = nums2.length;\n        int low = 0, high = x;\n\n        while (low <= high) {\n            int partitionX = (low + high) / 2;\n            int partitionY = (x + y + 1) / 2 - partitionX;\n\n            int maxX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];\n            int minX = (partitionX == x) ? Integer.MAX_VALUE : nums1[partitionX];\n\n            int maxY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];\n            int minY = (partitionY == y) ? Integer.MAX_VALUE : nums2[partitionY];\n\n            if (maxX <= minY && maxY <= minX) {\n                if ((x + y) % 2 == 0) {\n                    return ((double) Math.max(maxX, maxY) + Math.min(minX, minY)) / 2;\n                } else {\n                    return (double) Math.max(maxX, maxY);\n                }\n            } else if (maxX > minY) {\n                high = partitionX - 1;\n            } else {\n                low = partitionX + 1;\n            }\n        }\n\n        throw new IllegalArgumentException();\n    }\n}"
      }
    },
    "5": {
      "solution": {
        "two-pointers": "class Solution {\n\n    public String longestPalindrome(String s) {\n        if (s == null || s.length() == 0) {\n            return \"\";\n        }\n        int n = s.length();\n        int start = 0;\n        int maxLen = 1; \n        for (int i = 0; i < n; i++) {\n            int len1 = expandAroundCenter(s, i, i); // odd-length palindromes           \n            int len2 = expandAroundCenter(s, i, i + 1); // even-length palindromes\n            int maxLenCurr = Math.max(len1, len2);\n            if (maxLenCurr > maxLen) {\n                maxLen = maxLenCurr;\n                start = i - (maxLen - 1) / 2;\n            }\n        }\n        \n        return s.substring(start, start + maxLen);\n    }\n    \n    private int expandAroundCenter(String s, int left, int right) {\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }\n}\n"
      }
    },
    "6": {
      "solution": {
        "string": ""
      }
    },
    "7": {
      "solution": {
        "math": ""
      }
    },
    "8": {
      "solution": {
        "string": ""
      }
    },
    "9": {
      "solution": {
        "math": ""
      }
    },
    "10": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "11": {
      "solution": {
        "two-pointers": "public class Solution {\n    public int maxArea(int[] height) {\n        int max = 0;\n        int left = 0;\n        int right = height.length - 1;\n\n        while (left < right) {\n            int currentArea = Math.min(height[left], height[right]) * (right - left);\n            max = Math.max(max, currentArea);\n\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n\n        return max;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] heights = {1, 2, 1};\n        System.out.println(solution.maxArea(heights)); // Output: 2\n    }\n}\n"
      }
    },
    "12": {
      "solution": {
        "math": ""
      }
    },
    "13": {
      "solution": {
        "math": ""
      }
    },
    "14": {
      "solution": {
        "trie": ""
      }
    },
    "15": {
      "solution": {
        "two-pointers": "public class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> result = new ArrayList<>();\n\n        for (int i = 0; i < nums.length - 2; i++) {\n            if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\n                int left = i + 1, right = nums.length - 1, target = -nums[i];\n                while (left < right) {\n                    if (nums[left] + nums[right] == target) {\n                        result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n                        while (left < right && nums[left] == nums[left + 1]) left++;\n                        while (left < right && nums[right] == nums[right - 1]) right--;\n                        left++;\n                        right--;\n                    } else if (nums[left] + nums[right] < target) {\n                        left++;\n                    } else {\n                        right--;\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n}"
      }
    },
    "16": {
      "solution": {
        "two-pointers": "import java.util.*;\n\npublic class Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int closestSum = nums[0] + nums[1] + nums[2];\n\n        for (int i = 0; i < nums.length - 2; i++) {\n            int left = i + 1, right = nums.length - 1;\n            while (left < right) {\n                int currentSum = nums[i] + nums[left] + nums[right];\n                if (Math.abs(currentSum - target) < Math.abs(closestSum - target)) {\n                    closestSum = currentSum;\n                }\n                if (currentSum < target) {\n                    left++;\n                } else if (currentSum > target) {\n                    right--;\n                } else {\n                    return target; // Early exit if we find an exact match\n                }\n            }\n        }\n\n        return closestSum;\n    }\n}"
      }
    },
    "17": {
      "solution": {
        "backtracking": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    private static final String[] KEYPAD = {\n        \"\",     // 0\n        \"\",     // 1\n        \"abc\",  // 2\n        \"def\",  // 3\n        \"ghi\",  // 4\n        \"jkl\",  // 5\n        \"mno\",  // 6\n        \"pqrs\", // 7\n        \"tuv\",  // 8\n        \"wxyz\"  // 9\n    };\n\n    public List<String> letterCombinations(String digits) {\n        List<String> result = new ArrayList<>();\n        if (digits == null || digits.length() == 0) {\n            return result;\n        }\n        dfs(result, new StringBuilder(), digits, 0);\n        return result;\n    }\n\n    private void dfs(List<String> result, StringBuilder current, String digits, int index) {\n        if (index == digits.length()) {\n            result.add(current.toString());\n            return;\n        }\n\n        String letters = KEYPAD[digits.charAt(index) - '0'];\n        for (char letter : letters.toCharArray()) {\n            current.append(letter);\n            dfs(result, current, digits, index + 1);\n            current.deleteCharAt(current.length() - 1); // Backtrack\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String digits = \"23\";\n        List<String> combinations = solution.letterCombinations(digits);\n        System.out.println(combinations); // Output: [ad, ae, af, bd, be, bf, cd, ce, cf]\n    }\n}\n"
      }
    },
    "18": {
      "solution": {
        "two-pointers": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        List<List<Integer>> result = new ArrayList<>();\n        int n = nums.length;\n        if (n < 4) return result;\n        \n        Arrays.sort(nums);\n        \n        for (int i = 0; i < n - 3; i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) continue; \n            for (int j = i + 1; j < n - 2; j++) {\n                if (j > i + 1 && nums[j] == nums[j - 1]) continue; \n                \n                int left = j + 1;\n                int right = n - 1;\n                \n                while (left < right) {\n                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];\n                    \n                    if (sum == target) {\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n                        \n                        while (left < right && nums[left] == nums[left + 1]) left++;\n                        while (left < right && nums[right] == nums[right - 1]) right--;\n                        \n                        left++;\n                        right--;\n                    } else if (sum < target) {\n                        left++;\n                    } else {\n                        right--;\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        int[] nums = {1000000000, 1000000000, 1000000000, 1000000000};\n        int target = -294967296;\n        List<List<Integer>> result = sol.fourSum(nums, target);\n        \n        // Expected Output: []\n        for (List<Integer> quad : result) {\n            System.out.println(quad);\n        }\n    }\n}\n"
      }
    },
    "19": {
      "solution": {
        "two-pointers": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode slow = dummy;\n        ListNode fast = dummy;\n        for (int i = 1; i <= n + 1; i++) {\n            fast = fast.next;\n        }\n\n        while (fast != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        slow.next = slow.next.next;\n\n        return dummy.next;\n    }\n}\n"
      }
    },
    "20": {
      "solution": {
        "stack": "import java.util.*;\n\nclass Solution {\n    public boolean isValid(String s) {\n        Deque<Character> stack = new ArrayDeque<>();\n\n        for (char ch : s.toCharArray()) {\n            if (ch == '(' || ch == '{' || ch == '[') {\n                stack.push(ch);\n            } else {\n                if (stack.isEmpty())\n                    return false;\n                char open = stack.pop();\n                if (!isMatchingPair(open, ch))\n                    return false;\n            }\n        }\n\n        return stack.isEmpty();\n    }\n\n    private boolean isMatchingPair(char open, char close) {\n        return (open == '(' && close == ')') ||\n                (open == '{' && close == '}') ||\n                (open == '[' && close == ']');\n    }\n}\n"
      }
    },
    "21": {
      "solution": {
        "recursion": ""
      }
    },
    "22": {
      "solution": {
        "dynamic-programming": "",
        "backtracking": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> result = new ArrayList<>();\n        dfs(\"\", n, n, result);\n        return result;\n    }\n\n    private void dfs(String prefix, int l, int r, List<String> result) {\n        if (l == 0 && r == 0) {\n            result.add(prefix);\n            return;\n        }\n        if (l > 0) {\n            dfs(prefix + \"(\", l - 1, r, result);\n        }\n        if (l < r) {\n            dfs(prefix + \")\", l, r - 1, result);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<String> combinations = solution.generateParenthesis(3);\n        System.out.println(combinations); // Output: [((())),(()()),(())(),()(()),()()()]\n    }\n}\n"
      }
    },
    "23": {
      "solution": {
        "merge-sort": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            return null;\n        }\n        return mergeKLists(lists, 0, lists.length - 1);\n    }\n    \n    private ListNode mergeKLists(ListNode[] lists, int left, int right) {\n        if (left == right) {\n            return lists[left];\n        }\n        int mid = left + (right - left) / 2;\n        ListNode l1 = mergeKLists(lists, left, mid);\n        ListNode l2 = mergeKLists(lists, mid + 1, right);\n        return mergeTwoLists(l1, l2);\n    }\n    \n    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                current.next = l1;\n                l1 = l1.next;\n            } else {\n                current.next = l2;\n                l2 = l2.next;\n            }\n            current = current.next;\n        }\n        \n        if (l1 != null) {\n            current.next = l1;\n        } else if (l2 != null) {\n            current.next = l2;\n        }\n        \n        return dummy.next;\n    }\n}\n",
        "heap-(priority-queue)": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode() {}\n * ListNode(int val) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        Queue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\n\n        for (ListNode list : lists)\n            if (list != null)\n                minHeap.offer(list);\n\n        while (!minHeap.isEmpty()) {\n            ListNode minNode = minHeap.poll();\n            if (minNode.next != null)\n                minHeap.offer(minNode.next);\n            curr.next = minNode;\n            curr = curr.next;\n        }\n\n        return dummy.next;\n    }\n}"
      }
    },
    "24": {
      "solution": {
        "linked-list": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* dummy = new ListNode(0, head);\n        ListNode* prev = dummy;\n\n        while (prev->next != nullptr && prev->next->next != nullptr) {\n            ListNode* first = prev->next;\n            ListNode* second = prev->next->next;\n\n            first->next = second->next;\n            second->next = first;\n            prev->next = second;\n\n            prev = first;\n        }\n\n        return dummy->next; \n    }\n};\n"
      }
    },
    "25": {
      "solution": {
        "recursion": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseKNodes(ListNode* head, int k) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        ListNode* next = nullptr;\n        int count = 0;\n\n        while (curr && count < k) {\n            next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n            count++;\n        }\n        return prev; \n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        if (!head || k == 1) return head; \n\n        ListNode* temp = head;\n        int count = 0;\n        while (temp && count < k) {\n            temp = temp->next;\n            count++;\n        }\n        if (count < k) return head; \n        ListNode* newHead = reverseKNodes(head, k);\n        head->next = reverseKGroup(temp, k);\n        return newHead;\n    }\n};\n"
      }
    },
    "26": {
      "solution": {
        "two-pointers": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length == 0) return 0;\n\n        int slow = 1;  // slow pointer\n        for (int fast = 1; fast < nums.length; fast++) {  // fast pointer\n            if (nums[fast] != nums[fast - 1]) {\n                nums[slow++] = nums[fast];\n            }\n        }\n        return slow;\n    }\n}\n"
      }
    },
    "27": {
      "solution": {
        "two-pointers": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        int slow = 0;  \n        for (int fast = 0; fast < nums.length; fast++) { \n            if (nums[fast] != val) {\n                nums[slow++] = nums[fast];\n            }\n        }\n        return slow;\n    }\n}"
      }
    },
    "28": {
      "solution": {
        "two-pointers": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle.isEmpty()) {\n            return 0;\n        }\n        int haystackLength = haystack.length();\n        int needleLength = needle.length();\n        \n        for (int i = 0; i <= haystackLength - needleLength; i++) {\n            int j = 0;\n            while (j < needleLength && haystack.charAt(i + j) == needle.charAt(j)) {\n                j++;\n            }\n            if (j == needleLength) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n"
      }
    },
    "29": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "30": {
      "solution": {
        "sliding-window": "import java.util.*;\n\npublic class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> result = new ArrayList<>();\n        if (s == null || s.length() == 0 || words == null || words.length == 0) {\n            return result;\n        }\n\n        int wordLength = words[0].length();\n        int wordsCount = words.length;\n        int totalLength = wordLength * wordsCount;\n\n        Map<String, Integer> wordMap = new HashMap<>();\n        for (String word : words) {\n            wordMap.put(word, wordMap.getOrDefault(word, 0) + 1);\n        }\n\n        for (int i = 0; i < wordLength; i++) {\n            int left = i;\n            int right = i;\n            int count = 0;\n            Map<String, Integer> currentMap = new HashMap<>();\n            \n            while (right + wordLength <= s.length()) {\n                String word = s.substring(right, right + wordLength);\n                right += wordLength;\n\n                if (wordMap.containsKey(word)) {\n                    currentMap.put(word, currentMap.getOrDefault(word, 0) + 1);\n                    count++;\n                    while (currentMap.get(word) > wordMap.get(word)) {\n                        String leftWord = s.substring(left, left + wordLength);\n                        currentMap.put(leftWord, currentMap.get(leftWord) - 1);\n                        left += wordLength;\n                        count--;\n                    }\n                    if (count == wordsCount) {\n                        result.add(left);\n                    }\n                } else {\n                    currentMap.clear();\n                    count = 0;\n                    left = right;\n                }\n            }\n        }\n\n        return result;\n    }\n}"
      }
    },
    "31": {
      "solution": {
        "two-pointers": "class Solution {\n    public void nextPermutation(int[] nums) {\n        int n = nums.length;\n        int i = n - 2;\n        \n        while (i >= 0 && nums[i] >= nums[i + 1]) {\n            i--;\n        }\n        \n        if (i >= 0) {\n            int j = n - 1;\n            while (nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        \n        reverse(nums, i + 1, n - 1);\n    }\n    \n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    \n    private void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            swap(nums, start, end);\n            start++;\n            end--;\n        }\n    }\n}\n"
      }
    },
    "32": {
      "solution": {
        "stack": "import java.util.*;\n\nclass Solution {\n    public int longestValidParentheses(String s) {\n        Deque<Integer> stack = new ArrayDeque<>();\n        stack.push(-1);\n        int maxLength = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (ch == '(') {\n                stack.push(i);\n            } else {\n                stack.pop();\n                if (stack.isEmpty()) {\n                    stack.push(i);\n                } else {\n                    maxLength = Math.max(maxLength, i - stack.peek());\n                }\n            }\n        }\n\n        return maxLength;\n    }\n}\n"
      }
    },
    "33": {
      "solution": {
        "array": "",
        "binary-search": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left = 0, right = nums.size() - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                return mid;\n            }\n            \n            if (nums[left] <= nums[mid]) {\n                if (nums[left] <= target && target < nums[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[right]) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n        \n        return -1;\n    }\n};\n"
      }
    },
    "34": {
      "solution": {
        "array": "",
        "binary-search": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int binarySearchFirst(const vector<int>& nums, int target) {\n        int low = 0, high = nums.size() - 1;\n        int firstPos = -1;\n\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (nums[mid] == target) {\n                firstPos = mid; \n                high = mid - 1;\n            } else if (nums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n\n        return firstPos;\n    }\n\n    int binarySearchLast(const vector<int>& nums, int target) {\n        int low = 0, high = nums.size() - 1;\n        int lastPos = -1;\n\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (nums[mid] == target) {\n                lastPos = mid;\n                low = mid + 1;\n            } else if (nums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n\n        return lastPos;\n    }\n\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int first = binarySearchFirst(nums, target);\n        int last = binarySearchLast(nums, target);\n        return {first, last};\n    }\n};"
      }
    },
    "35": {
      "solution": {
        "array": "",
        "binary-search": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int low = 0, high = nums.size() - 1;\n\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n\n            if (nums[mid] == target) {\n                return mid; \n            } else if (nums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1; \n            }\n        }\n\n        return low; \n    }\n};"
      }
    },
    "36": {
      "solution": {
        "matrix": "public class Solution {\n\n    public boolean isSafe(char[][] board, int row, int col, char num) {\n        for (int j = 0; j < 9; j++) {\n            if (board[row][j] == num) {\n                return false;\n            }\n        }\n\n        for (int i = 0; i < 9; i++) {\n            if (board[i][col] == num) {\n                return false;\n            }\n        }\n\n        int startRow = row - row % 3;\n        int startCol = col - col % 3;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (board[i + startRow][j + startCol] == num) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    public boolean isValidSudoku(char[][] board) {\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                char num = board[i][j];                \n                if (num == '.') continue;\n\n                board[i][j] = '.';\n                if (!isSafe(board, i, j, num)) {\n                    return false; \n                }\n                board[i][j] = num;\n            }\n        }\n\n        return true;\n    }\n}\n"
      }
    },
    "37": {
      "solution": {
        "backtracking": "public class Solution {\n\n   public boolean isSafe(int[][] board, int row, int col, int num, int n) {\n        for (int j = 0; j < n; j++)\n            if (board[row][j] == num)\n                return false;\n\n        for (int i = 0; i < n; i++)\n            if (board[i][col] == num)\n                return false;\n\n        int startRow = row - row % 3,\n                startCol = col - col % 3;\n\n        // check within the section (3 * 3)(n = 3)\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (board[i + startRow][j + startCol] == num)\n                    return false;\n            }\n        }\n\n        return true;\n    }\n\n    boolean solve(int[][] board, int row, int col, int n) {\n        // avoid further tracking if all cells are explored\n        if (row == n - 1 && col == n)\n            return true;\n\n        // move to next row\n        if (col == n) {\n            row++;\n            col = 0;\n        }\n\n        // check for next element horizontally if element is\n        // already present\n        if (board[row][col] != 0)\n            return solve(board, row, col + 1, n);\n\n        // if present value is 0, replace it with values from 0-9\n        for (int num = 1; num < n + 1; num++) {\n            if (isSafe(board, row, col, num, n)) {\n                board[row][col] = num;\n        // check for next column\n                if (solve(board, row, col + 1, n)) {\n                    return true;\n                }\n            }\n            board[row][col] = 0;\n        }\n\n        return false;\n    }\n\n    public void solveSudoku(char[][] board) {\n        int n = board[0].length;\n        int grid[][] = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (board[i][j] == '.') {\n                    grid[i][j] = 0;\n                } else {\n                    grid[i][j] = Integer.parseInt(String.valueOf(board[i][j]));\n                }\n            }\n        }\n        solve(grid, 0, 0, n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) {\n                    board[i][j] = '.';\n                } else {\n                    board[i][j] = (char) (grid[i][j] + '0');\n                }\n            }\n        }\n    }\n\n}\n"
      }
    },
    "38": {
      "solution": {
        "string": ""
      }
    },
    "39": {
      "solution": {
        "backtracking": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(candidates);\n        dfs(0, candidates, target, res, new ArrayList<>());\n        return res;\n    }\n\n    private void dfs(int s, int[] candidates, int target, List<List<Integer>> res, List<Integer> curr) {\n        if (target < 0)\n            return;\n        if (target == 0) {\n            res.add(new ArrayList<>(curr));\n            return;\n        }\n        for (int i = s; i < candidates.length; ++i) {\n            // if(int i=0;... , ans = [[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]\n            curr.add(candidates[i]);\n            dfs(i, candidates, target - candidates[i], res, curr);\n            curr.remove(curr.size() - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] candidates = { 2, 3, 6, 7 };\n        int target = 7;\n        List<List<Integer>> combinations = solution.combinationSum(candidates, target);\n        System.out.println(combinations); // Output: [[2, 2, 3], [7]]\n    }\n}\n"
      }
    },
    "40": {
      "solution": {
        "backtracking": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\n        if (candidates == null || candidates.length == 0)\n            return result;\n        ArrayList<Integer> current = new ArrayList<Integer>();\n        Arrays.sort(candidates);\n        combinationSum(candidates, target, 0, current, result);\n        return result;\n    }\n\n    public void combinationSum(int[] candidates, int target, int j, ArrayList<Integer> curr,\n            List<List<Integer>> result) {\n        if (target == 0) {\n            ArrayList<Integer> temp = new ArrayList<Integer>(curr);\n            result.add(temp);\n            return;\n        }\n        for (int i = j; i < candidates.length; i++) {\n            if (target < candidates[i]) {\n                return;\n            }\n            if (i == j || candidates[i] != candidates[i - 1]) {\n                curr.add(candidates[i]);\n                combinationSum(candidates, target - candidates[i], i + 1, curr, result);\n                curr.remove(curr.size() - 1);\n            }\n        }\n    }\n}"
      }
    },
    "41": {
      "solution": {
        "hash-table": ""
      }
    },
    "42": {
      "solution": {
        "two-pointers": "class Solution {\n    public int trap(int[] height) {\n        if (height == null || height.length == 0) return 0;\n\n        int left = 0, right = height.length - 1;\n        int left_max = 0, right_max = 0;\n        int waterTrapped = 0;\n\n        while (left < right) {\n            if (height[left] < height[right]) {\n                if (height[left] >= left_max) {\n                    left_max = height[left];\n                } else {\n                    waterTrapped += left_max - height[left];\n                }\n                left++;\n            } else {\n                if (height[right] >= right_max) {\n                    right_max = height[right];\n                } else {\n                    waterTrapped += right_max - height[right];\n                }\n                right--;\n            }\n        }\n\n        return waterTrapped;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        int[] height = {0,1,0,2,1,0,1,3,2,1,2,1};\n        System.out.println(sol.trap(height)); // Output: 6\n    }\n}\n"
      }
    },
    "43": {
      "solution": {
        "math": ""
      }
    },
    "44": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "45": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "46": {
      "solution": {
        "backtracking": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        boolean[] visited = new boolean[nums.length];\n        dfs(nums, res, new ArrayList<>(), visited);\n        return res;\n    }\n\n    private void dfs(int[] nums, List<List<Integer>> res, List<Integer> curr, boolean[] visited) {\n        if (curr.size() == nums.length) {\n            res.add(new ArrayList<>(curr));\n            return;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (!visited[i]) {\n                visited[i] = true;\n                curr.add(nums[i]);\n                dfs(nums, res, curr, visited);\n                curr.remove(curr.size() - 1);\n                visited[i] = false;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, 2, 3};\n        List<List<Integer>> permutations = solution.permute(nums);\n        System.out.println(permutations); // Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n    }\n}\n"
      }
    },
    "47": {
      "solution": {
        "backtracking": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        boolean[] visited = new boolean[nums.length];\n        if (nums == null || nums.length == 0) {\n            return res;\n        }\n        Arrays.sort(nums); // Sort the array to handle duplicates\n        dfs(nums, res, new ArrayList<>(), visited);\n        return res;\n    }\n\n    private void dfs(int[] nums, List<List<Integer>> res, List<Integer> curr, boolean[] visited) {\n        if (curr.size() == nums.length) {\n            res.add(new ArrayList<>(curr));\n            return;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (visited[i]) {\n                continue;\n            }\n            if (i == 0 || nums[i] != nums[i - 1] || (nums[i] == nums[i - 1] && visited[i - 1])) {\n                visited[i] = true;\n                curr.add(nums[i]);\n                dfs(nums, res, curr, visited);\n                curr.remove(curr.size() - 1); // Backtrack\n                visited[i] = false;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, 1, 2};\n        List<List<Integer>> permutations = solution.permuteUnique(nums);\n        System.out.println(permutations); // Output: [[1, 1, 2], [1, 2, 1], [2, 1, 1]]\n    }\n}\n"
      }
    },
    "48": {
      "solution": {
        "matrix": "public class RotateImage {\n\n    public void rotate(int[][] matrix) {\n        if (matrix == null || matrix.length == 0) return;\n        \n        int n = matrix.length;\n        transpose(matrix, n);\n        \n        for (int i = 0; i < n; i++) {\n            reverseRow(matrix[i], n);\n        }\n    }\n    \n    private void transpose(int[][] matrix, int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                swap(matrix, i, j, j, i);\n            }\n        }\n    }\n    \n    private void reverseRow(int[] row, int n) {\n        int left = 0, right = n - 1;\n        while (left < right) {\n            int temp = row[left];\n            row[left] = row[right];\n            row[right] = temp;\n            left++;\n            right--;\n        }\n    }\n    \n    private void swap(int[][] matrix, int i, int j, int x, int y) {\n        int temp = matrix[i][j];\n        matrix[i][j] = matrix[x][y];\n        matrix[x][y] = temp;\n    }\n\n    public static void main(String[] args) {\n        RotateImage ri = new RotateImage();\n        int[][] matrix = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        };\n        \n        ri.rotate(matrix);\n        \n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[i].length; j++) {\n                System.out.print(matrix[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n"
      }
    },
    "49": {
      "solution": {
        "sorting": ""
      }
    },
    "50": {
      "solution": {
        "recursion": "class Solution {\npublic:\n    double myPow(double x, int n) {\n        long long power = n;\n        if (power < 0) {\n            x = 1 / x;\n            power = -power;\n        }\n\n        return fastPow(x, power);\n    }\n\nprivate:\n    double fastPow(double x, long long n) {\n        if (n == 0)\n            return 1.0;\n        double half = fastPow(x, n / 2);\n\n        if (n % 2 == 0) {\n            return half * half;\n        } else {\n            return half * half * x;\n        }\n    }\n};\n"
      }
    },
    "51": {
      "solution": {
        "backtracking": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<List<String>> solveNQueens(int n) {\n        List<List<String>> res = new ArrayList<>();\n        char[][] board = new char[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                board[i][j] = '.';\n            }\n        }\n        dfs(board, 0, res);\n        return res;\n    }\n\n    private void dfs(char[][] board, int row, List<List<String>> res) {\n        if (row == board.length) {\n            res.add(construct(board));\n            return;\n        }\n\n        for (int col = 0; col < board.length; col++) {\n            if (isValid(board, row, col)) {\n                board[row][col] = 'Q';\n                dfs(board, row + 1, res);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    private boolean isValid(char[][] board, int row, int col) {\n        for (int i = 0; i < row; i++) {\n            if (board[i][col] == 'Q') {\n                return false;\n            }\n        }\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] == 'Q') {\n                return false;\n            }\n        }\n        for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\n            if (board[i][j] == 'Q') {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private List<String> construct(char[][] board) {\n        List<String> path = new ArrayList<>();\n        for (int i = 0; i < board.length; i++) {\n            path.add(new String(board[i]));\n        }\n        return path;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n = 4;\n        List<List<String>> result = solution.solveNQueens(n);\n        for (List<String> solutionBoard : result) {\n            for (String row : solutionBoard) {\n                System.out.println(row);\n            }\n            System.out.println();\n        }\n    }\n}\n"
      }
    },
    "52": {
      "solution": {
        "backtracking": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public int totalNQueens(int n) {\n        int[][] board = new int[n][n];\n        List<List<Integer>> result = new ArrayList<>();\n        placeQueens(board, 0, n, result);\n        return result.size();\n    }\n\n    private boolean isSafe(int[][] board, int row, int col, int n) {\n        int i, j;\n\n        for (i = 0; i < col; i++)\n            if (board[row][i] == 1) return false;\n        for (i = row, j = col; i >= 0 && j >= 0; i--, j--)\n            if (board[i][j] == 1) return false;\n        for (i = row, j = col; j >= 0 && i < n; i++, j--)\n            if (board[i][j] == 1) return false;\n\n        return true;\n    }\n\n    private boolean placeQueens(int[][] board, int col, int n, List<List<Integer>> result) {\n        if (col == n) {\n            List<Integer> solution = new ArrayList<>();\n            for (int[] rows : board) {\n                for (int i = 0; i < n; i++) {\n                    if (rows[i] == 1) {\n                        solution.add(i);\n                        break;\n                    }\n                }\n            }\n            result.add(solution);\n            return true;\n        }\n\n        boolean res = false;\n        for (int i = 0; i < n; i++) {\n            if (isSafe(board, i, col, n)) {\n                board[i][col] = 1;\n                res = placeQueens(board, col + 1, n, result) || res;\n                board[i][col] = 0;  // backtrack\n            }\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.totalNQueens(4));  // Output: 2\n    }\n}\n"
      }
    },
    "53": {
      "solution": {
        "dynamic-programming": "",
        "divide-and-conquer": "public class Solution {\n    public int maxSubArray(int[] nums) {\n        return maxSubArrayHelper(nums, 0, nums.length - 1);\n    }\n\n    private int maxSubArrayHelper(int[] nums, int left, int right) {\n        if (left == right) {\n            return nums[left];\n        }\n\n        int mid = (left + right) / 2;\n        int leftMax = maxSubArrayHelper(nums, left, mid);\n        int rightMax = maxSubArrayHelper(nums, mid + 1, right);\n        int crossMax = findMaxCrossingSubarray(nums, left, mid, right);\n\n        return Math.max(leftMax, Math.max(rightMax, crossMax));\n    }\n\n    private int findMaxCrossingSubarray(int[] nums, int left, int mid, int right) {\n        int leftSum = Integer.MIN_VALUE;\n        int sum = 0;\n        for (int i = mid; i >= left; i--) {\n            sum += nums[i];\n            if (sum > leftSum) {\n                leftSum = sum;\n            }\n        }\n\n        int rightSum = Integer.MIN_VALUE;\n        sum = 0;\n        for (int i = mid + 1; i <= right; i++) {\n            sum += nums[i];\n            if (sum > rightSum) {\n                rightSum = sum;\n            }\n        }\n\n        return leftSum + rightSum;\n    }\n\n}"
      }
    },
    "54": {
      "solution": {
        "matrix": "package com.sai.designPatterns;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> result = new ArrayList<>();\n        if (matrix == null || matrix.length == 0) return result;\n\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        boolean[][] visited = new boolean[rows][cols];\n\n        dfs(matrix, visited, result, 0, 0, 0);\n        return result;\n    }\n\n    private void dfs(int[][] matrix, boolean[][] visited, List<Integer> result, int row, int col, int direction) {\n        if (row < 0 || row >= matrix.length || col < 0 || col >= matrix[0].length || visited[row][col]) {\n            return;\n        }\n\n        visited[row][col] = true;\n        result.add(matrix[row][col]);\n\n        int nextRow = row + DIRECTIONS[direction][0];\n        int nextCol = col + DIRECTIONS[direction][1];\n        if (nextRow < 0 || nextRow >= matrix.length || nextCol < 0 || nextCol >= matrix[0].length || visited[nextRow][nextCol]) {\n            direction = (direction + 1) % 4;\n            nextRow = row + DIRECTIONS[direction][0];\n            nextCol = col + DIRECTIONS[direction][1];\n        }\n\n        dfs(matrix, visited, result, nextRow, nextCol, direction);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Sample 2D matrix\n        int[][] matrix = {\n                {1, 2, 3, 4},\n                {5, 6, 7, 8},\n                {9, 10, 11, 12}\n        };\n\n        // Get the spiral order\n        List<Integer> result = solution.spiralOrder(matrix);\n\n        System.out.println(\"Spiral Order: \" + result);\n    }\n}\n"
      }
    },
    "55": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "56": {
      "solution": {
        "sorting": ""
      }
    },
    "57": {
      "solution": {
        "array": ""
      }
    },
    "58": {
      "solution": {
        "string": ""
      }
    },
    "59": {
      "solution": {
        "matrix": "public class Solution {\n\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public int[][] generateMatrix(int n) {\n        int[][] matrix = new int[n][n];\n        boolean[][] visited = new boolean[n][n];\n        int row = 0, col = 0, dir = 0;\n        for (int i = 1; i <= n * n; i++) {\n            matrix[row][col] = i;\n            visited[row][col] = true;\n\n            int nextRow = row + DIRECTIONS[dir][0];\n            int nextCol = col + DIRECTIONS[dir][1];\n\n            if (nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || visited[nextRow][nextCol]) {\n                dir = (dir + 1) % 4; \n                nextRow = row + DIRECTIONS[dir][0];\n                nextCol = col + DIRECTIONS[dir][1];\n            }\n\n            row = nextRow;\n            col = nextCol;\n        }\n        return matrix;\n    }\n\n}\n"
      }
    },
    "60": {
      "solution": {
        "recursion": ""
      }
    },
    "61": {
      "solution": {
        "two-pointers": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n        ListNode oldTail = head;\n        int length = 1;\n        while (oldTail.next != null) {\n            oldTail = oldTail.next;\n            length++;\n        }\n        oldTail.next = head;        \n        int newTailPosition = length - k % length - 1;        \n        ListNode newTail = head;\n        for (int i = 0; i < newTailPosition; i++) {\n            newTail = newTail.next;\n        }        \n        ListNode newHead = newTail.next;        \n        newTail.next = null;\n        return newHead;\n    }\n}\n"
      }
    },
    "62": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "63": {
      "solution": {
        "matrix": ""
      }
    },
    "64": {
      "solution": {
        "matrix": ""
      }
    },
    "65": {
      "solution": {
        "string": ""
      }
    },
    "66": {
      "solution": {
        "math": ""
      }
    },
    "67": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "68": {
      "solution": {
        "string": ""
      }
    },
    "69": {
      "solution": {
        "math": "",
        "binary-search": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x == 0 || x == 1) return x; \n\n        int low = 0, high = x, ans = 0;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (mid <= x / mid) { \n                ans = mid;\n                low = mid + 1;\n            } else {\n                high = mid - 1; \n            }\n        }\n        return ans;\n    }\n};\n"
      }
    },
    "70": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "71": {
      "solution": {
        "stack": "import java.util.*;\n\nclass Solution {\n    public String simplifyPath(String path) {\n        Deque<String> stack = new ArrayDeque<>();\n        String[] components = path.split(\"/\");\n\n        for (String component : components) {\n            if (component.equals(\"\") || component.equals(\".\")) {\n                continue;\n            } else if (component.equals(\"..\")) {\n                if (!stack.isEmpty()) {\n                    stack.pop();\n                }\n            } else {\n                stack.push(component);\n            }\n        }\n\n        StringBuilder simplifiedPath = new StringBuilder();\n        while (!stack.isEmpty()) {\n            simplifiedPath.insert(0, \"/\" + stack.pop());\n        }\n\n        return simplifiedPath.length() > 0 ? simplifiedPath.toString() : \"/\";\n    }\n}\n"
      }
    },
    "72": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "73": {
      "solution": {
        "matrix": "public class Solution {\n    public void setZeroes(int[][] matrix) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        \n        boolean isFirstRowZero = false;\n        boolean isFirstColZero = false;\n        \n        for (int i = 0; i < m; i++) {\n            if (matrix[i][0] == 0) {\n                isFirstColZero = true;\n                break;\n            }\n        }\n        \n        for (int j = 0; j < n; j++) {\n            if (matrix[0][j] == 0) {\n                isFirstRowZero = true;\n                break;\n            }\n        }\n        \n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (matrix[i][j] == 0) {\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        \n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        \n        if (isFirstRowZero) {\n            for (int j = 0; j < n; j++) {\n                matrix[0][j] = 0;\n            }\n        }\n        \n        if (isFirstColZero) {\n            for (int i = 0; i < m; i++) {\n                matrix[i][0] = 0;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] matrix = {\n            {1, 1, 1},\n            {1, 0, 1},\n            {1, 1, 1}\n        };\n        \n        solution.setZeroes(matrix);\n        \n        for (int[] row : matrix) {\n            for (int val : row) {\n                System.out.print(val);\n            }\n            System.out.println();\n        }\n    }\n}\n"
      }
    },
    "74": {
      "solution": {
        "matrix": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return false;\n        }\n\n        int m = matrix.length;\n        int n = matrix[0].length;\n\n        int left = 0;\n        int right = m * n - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            int midValue = matrix[mid / n][mid % n];\n\n            if (midValue == target) {\n                return true;\n            } else if (midValue < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return false;\n    }\n}"
      }
    },
    "75": {
      "solution": {
        "two-pointers": "class Solution {\n    public void sortColors(int[] nums) {\n        int low = 0;\n        int mid = 0;\n        int high = nums.length - 1;\n\n        while (mid <= high) {\n            if (nums[mid] == 0) {\n                swap(nums, low, mid);\n                low++;\n                mid++;\n            } else if (nums[mid] == 1) {\n                mid++;\n            } else {  // nums[mid] == 2\n                swap(nums, mid, high);\n                high--;\n            }\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        int[] nums = {2, 0, 2, 1, 1, 0};\n        sol.sortColors(nums);        \n        for (int num : nums) {\n            System.out.print(num + \" \");\n        }\n    }\n}\n"
      }
    },
    "76": {
      "solution": {
        "sliding-window": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    public String minWindow(String s, String t) {\n        if (s == null || s.length() == 0 || t == null || t.length() == 0) {\n            return;\n        }\n\n        Map<Character, Integer> tCount = new HashMap<>();\n        for (char c : t.toCharArray()) {\n            tCount.put(c, tCount.getOrDefault(c, 0) + 1);\n        }\n\n        int required = tCount.size();\n        int left = 0, right = 0;\n        int formed = 0;\n        Map<Character, Integer> windowCounts = new HashMap<>();\n        int[] ans = {-1, 0, 0}; // length, left, right\n\n        while (right < s.length()) {\n            char c = s.charAt(right);\n            windowCounts.put(c, windowCounts.getOrDefault(c, 0) + 1);\n\n            if (tCount.containsKey(c) && windowCounts.get(c).intValue() == tCount.get(c).intValue()) {\n                formed++;\n            }\n\n            while (left <= right && formed == required) {\n                c = s.charAt(left);\n                \n                if (ans[0] == -1 || right - left + 1 < ans[0]) {\n                    ans[0] = right - left + 1;\n                    ans[1] = left;\n                    ans[2] = right;\n                }\n\n                windowCounts.put(c, windowCounts.get(c) - 1);\n                if (tCount.containsKey(c) && windowCounts.get(c).intValue() < tCount.get(c).intValue()) {\n                    formed--;\n                }\n\n                left++;\n            }\n\n            right++;\n        }\n\n        return ans[0] == -1 ? : s.substring(ans[1], ans[2] + 1);\n    }\n}\n"
      }
    },
    "77": {
      "solution": {
        "backtracking": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        dfs(result, new ArrayList<>(), n, k, 1);\n        return result;\n    }\n\n    private void dfs(List<List<Integer>> result, List<Integer> combination, int n, int k, int start) {\n        if (combination.size() == k) {\n            result.add(new ArrayList<>(combination));\n            return;\n        }\n\n        for (int i = start; i <= n; i++) {\n            combination.add(i);\n            dfs(result, combination, n, k, i + 1);\n            combination.remove(combination.size() - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n = 4;\n        int k = 2;\n        List<List<Integer>> result = solution.combine(n, k);\n        for (List<Integer> combo : result) {\n            System.out.println(combo);\n        }\n    }\n}\n"
      }
    },
    "78": {
      "solution": {
        "backtracking": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        dfs(result, new ArrayList<>(), nums, 0);\n        return result;\n    }\n\n    private void dfs(List<List<Integer>> result, List<Integer> current, int[] nums, int start) {\n        result.add(new ArrayList<>(current));\n        for (int i = start; i < nums.length; i++) {\n            current.add(nums[i]);\n            dfs(result, current, nums, i + 1);\n            current.remove(current.size() - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, 2, 3};\n        List<List<Integer>> result = solution.subsets(nums);\n        for (List<Integer> subset : result) {\n            System.out.println(subset);\n        }\n    }\n}\n"
      }
    },
    "79": {
      "solution": {
        "backtracking": "class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public boolean exist(char[][] board, String word) {\n        int rows = board.length;\n        int cols = board[0].length;\n\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                if (dfs(board, word, row, col, 0)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private boolean dfs(char[][] board, String word, int row, int col, int index) {\n        if (index == word.length()) {\n            return true;\n        }\n        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length ||\n                board[row][col] != word.charAt(index)) {\n            return false;\n        }\n        char temp = board[row][col];\n        board[row][col] = '#';\n        for (int[] direction : DIRECTIONS) {\n            int newRow = row + direction[0];\n            int newCol = col + direction[1];\n            if (dfs(board, word, newRow, newCol, index + 1)) {\n                return true;\n            }\n        }\n        board[row][col] = temp;\n        return false;\n    }\n}",
        "matrix": "class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public boolean exist(char[][] board, String word) {\n        int rows = board.length;\n        int cols = board[0].length;\n\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                if (dfs(board, word, row, col, 0)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private boolean dfs(char[][] board, String word, int row, int col, int index) {\n        if (index == word.length()) {\n            return true;\n        }\n        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length ||\n                board[row][col] != word.charAt(index)) {\n            return false;\n        }\n        char temp = board[row][col];\n        board[row][col] = '#';\n        for (int[] direction : DIRECTIONS) {\n            int newRow = row + direction[0];\n            int newCol = col + direction[1];\n            if (dfs(board, word, newRow, newCol, index + 1)) {\n                return true;\n            }\n        }\n        board[row][col] = temp;\n        return false;\n    }\n}"
      }
    },
    "80": {
      "solution": {
        "two-pointers": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        int n = nums.length;\n        if (n <= 2) {\n            return n;\n        }\n        int slow = 2;\n        for (int fast = 2; fast < n; fast++) {\n            if (nums[fast] != nums[slow - 2]) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n        }\n\n        return slow;\n    }\n}"
      }
    },
    "81": {
      "solution": {
        "array": "",
        "binary-search": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        int low = 0, high = nums.size() - 1;\n\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n\n            if (nums[mid] == target) {\n                return true; \n            }\n\n            if (nums[low] == nums[mid] && nums[mid] == nums[high]) {\n                ++low;\n                --high;\n            }\n            else if (nums[low] <= nums[mid]) {\n                if (nums[low] <= target && target < nums[mid]) {\n                    high = mid - 1; \n                } else {\n                    low = mid + 1; \n                }\n            }\n            else {\n                if (nums[mid] < target && target <= nums[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1; \n                }\n            }\n        }\n        return false; \n    }\n};\n"
      }
    },
    "82": {
      "solution": {
        "two-pointers": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if (head == null) return null;\n\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode prev = dummy;\n        ListNode current = head;\n\n        while (current != null) {\n            while (current.next != null && current.val == current.next.val) {\n                current = current.next;\n            }\n            if (prev.next != current) {\n                prev.next = current.next;\n            } else {\n                prev = prev.next;\n            }\n            current = current.next; \n        }\n\n        return dummy.next;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();        \n        ListNode head = new ListNode(1);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(3);\n        head.next.next.next = new ListNode(3);\n        head.next.next.next.next = new ListNode(4);\n        head.next.next.next.next.next = new ListNode(4);\n        head.next.next.next.next.next.next = new ListNode(5);\n\n        ListNode result = sol.deleteDuplicates(head);        \n        while (result != null) {\n            System.out.print(result.val + \" \");\n            result = result.next;\n        }\n    }\n}\n"
      }
    },
    "83": {
      "solution": {
        "linked-list": ""
      }
    },
    "84": {
      "solution": {
        "monotonic-stack": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n        Stack<Integer> stack = new Stack<>();\n        int maxArea = 0;\n        int index = 0;\n\n        while (index < heights.length) {\n            if (stack.isEmpty() || heights[index] >= heights[stack.peek()]) {\n                stack.push(index++);\n            } else {\n                int top = stack.pop();\n                int height = heights[top];\n                int width = stack.isEmpty() ? index : index - stack.peek() - 1;\n                maxArea = Math.max(maxArea, height * width);\n            }\n        }\n\n        while (!stack.isEmpty()) {\n            int top = stack.pop();\n            int height = heights[top];\n            int width = stack.isEmpty() ? index : index - stack.peek() - 1;\n            maxArea = Math.max(maxArea, height * width);\n        }\n\n        return maxArea;\n    }\n}"
      }
    },
    "85": {
      "solution": {
        "matrix": "class Solution {\n    // dp[i][j] represents the height of consecutive '1's ending at the cell (i, j) in the binary matrix\n    public int maximalRectangle(char[][] matrix) {\n        if (matrix.length == 0) return 0;\n        int n = matrix.length;\n        int m = matrix[0].length;\n        int[][] dp = new int[n][m];\n        int maxArea = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (i == 0)\n                    dp[i][j] = matrix[i][j] == '1' ? 1 : 0;\n                else\n                    dp[i][j] = matrix[i][j] == '1' ? (dp[i - 1][j] + 1) : 0;\n                int min = dp[i][j];\n                for (int k = j; k >= 0; k--) {\n                    if (min == 0) break;\n                    if (dp[i][k] < min) min = dp[i][k];\n                    maxArea = Math.max(maxArea, min * (j - k + 1));\n                }\n            }\n        }\n        System.out.println(Arrays.deepToString(dp).replaceAll(\"],\", \"],\\n\"));\n        return maxArea;\n    }\n}"
      }
    },
    "86": {
      "solution": {
        "two-pointers": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public ListNode partition(ListNode head, int x) {\n        ListNode dummy1 = new ListNode(0);\n        ListNode dummy2 = new ListNode(0); \n        ListNode lessPtr = dummy1; \n        ListNode greaterOrEqualPtr = dummy2; \n        \n        while (head != null) {\n            if (head.val < x) {\n                lessPtr.next = head;\n                lessPtr = lessPtr.next;\n            } else {\n                greaterOrEqualPtr.next = head;\n                greaterOrEqualPtr = greaterOrEqualPtr.next;\n            }\n            head = head.next;\n        }\n        \n        lessPtr.next = dummy2.next;\n        greaterOrEqualPtr.next = null; \n        return dummy1.next; \n    }\n}\n"
      }
    },
    "87": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "88": {
      "solution": {
        "two-pointers": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int p1 = m - 1;\n        int p2 = n - 1;\n        \n        int p = m + n - 1; \n        while (p1 >= 0 && p2 >= 0) {\n            if (nums1[p1] > nums2[p2]) {\n                nums1[p--] = nums1[p1--];\n            } else {\n                nums1[p--] = nums2[p2--];\n            }\n        }\n        \n        while (p2 >= 0) {\n            nums1[p--] = nums2[p2--];\n        }\n    }\n}\n"
      }
    },
    "89": {
      "solution": {
        "backtracking": ""
      }
    },
    "90": {
      "solution": {
        "backtracking": ""
      }
    },
    "91": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "92": {
      "solution": {
        "linked-list": ""
      }
    },
    "93": {
      "solution": {
        "backtracking": ""
      }
    },
    "94": {
      "solution": {
        "stack": ""
      }
    },
    "95": {
      "solution": {
        "binary-search-tree": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode() {\n    }\n\n    TreeNode(int val) {\n        this.val = val;\n    }\n\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic class Solution {\n    public List<TreeNode> generateTrees(int n) {\n        if (n == 0)\n            return new ArrayList<>();\n        return generateTrees(1, n);\n    }\n\n    private List<TreeNode> generateTrees(int start, int end) {\n        List<TreeNode> allTrees = new ArrayList<>();\n        if (start > end) {\n            allTrees.add(null);\n            return allTrees;\n        }\n\n        for (int i = start; i <= end; i++) {\n            // all possible left subtrees if i is chosen to be a root\n            List<TreeNode> leftTrees = generateTrees(start, i - 1);\n\n            // all possible right subtrees if i is chosen to be a root\n            List<TreeNode> rightTrees = generateTrees(i + 1, end);\n\n            // connect left and right subtrees to the root i\n            for (TreeNode left : leftTrees) {\n                for (TreeNode right : rightTrees) {\n                    TreeNode currTree = new TreeNode(i);\n                    currTree.left = left;\n                    currTree.right = right;\n                    allTrees.add(currTree);\n                }\n            }\n        }\n        return allTrees;\n    }\n}\n"
      }
    },
    "96": {
      "solution": {
        "binary-search-tree": "public class Solution {\n\n    public int numTrees(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n        for (int nodes = 2; nodes <= n; nodes++) {\n            for (int root = 1; root <= nodes; root++) {\n                dp[nodes] += dp[root - 1] * dp[nodes - root];\n            }\n        }\n        return dp[n];\n    }\n\n}\n"
      }
    },
    "97": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "98": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode() {}\n * TreeNode(int val) { this.val = val; }\n * TreeNode(int val, TreeNode left, TreeNode right) {\n * this.val = val;\n * this.left = left;\n * this.right = right;\n * }\n * }\n */\npublic class Solution {\n\n    public boolean isValidBST(TreeNode root) {\n        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n\n    private boolean isValidBST(TreeNode node, long min, long max) {\n        if (node == null) {\n            return true;\n        }\n        if (node.val <= min || node.val >= max) {\n            return false;\n        }\n        return isValidBST(node.left, min, node.val) && isValidBST(node.right, node.val, max);\n    }\n\n}\n"
      }
    },
    "99": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n\n    public void recoverTree(TreeNode root) {\n        TreeNode first = null;\n        TreeNode second = null;\n        TreeNode prev = null;\n        TreeNode temp = null;\n\n        while (root != null) {\n            if (root.left != null) {\n                // Find the rightmost node in the left subtree or link it to the current root\n                temp = root.left;\n                while (temp.right != null && temp.right != root) {\n                    temp = temp.right;\n                }\n\n                if (temp.right != null) {\n                    // Unlink the rightmost node from the current root\n                    if (prev != null && root.val < prev.val) {\n                        if (first == null) {\n                            first = prev;\n                        }\n                        second = root;\n                    }\n                    prev = root;\n\n                    temp.right = null;\n                    root = root.right;\n                } else {\n                    // Link the rightmost node to the current root\n                    temp.right = root;\n                    root = root.left;\n                }\n            } else {\n                // Check for swapped nodes\n                if (prev != null && root.val < prev.val) {\n                    if (first == null) {\n                        first = prev;\n                    }\n                    second = root;\n                }\n                prev = root;\n\n                root = root.right;\n            }\n        }\n\n        // Swap the values of the two nodes\n        if (first != null && second != null) {\n            int tempVal = first.val;\n            first.val = second.val;\n            second.val = tempVal;\n        }\n    }\n}\n"
      }
    },
    "100": {
      "solution": {
        "tree": ""
      }
    },
    "101": {
      "solution": {
        "tree": ""
      }
    },
    "102": {
      "solution": {
        "breadth-first-search": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> result;\n        if (!root) return result; \n        \n        queue<TreeNode*> q;\n        q.push(root);\n\n        while (!q.empty()) {\n            int size = q.size();\n            vector<int> currentLevel;\n\n            for (int i = 0; i < size; ++i) {\n                TreeNode* currentNode = q.front();\n                q.pop();\n                currentLevel.push_back(currentNode->val);\n\n                if (currentNode->left) q.push(currentNode->left);\n                if (currentNode->right) q.push(currentNode->right);\n            }\n\n            result.push_back(currentLevel);\n        }\n\n        return result;\n    }\n};\n"
      }
    },
    "103": {
      "solution": {
        "breadth-first-search": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\n * right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        if (!root)\n            return {};\n\n        vector<vector<int>> ans;\n        deque<TreeNode*> q{{root}};\n        bool isLeftToRight = true;\n\n        while (!q.empty()) {\n            vector<int> currLevel;\n            for (int size = q.size(); size > 0; --size)\n                if (isLeftToRight) {\n                    TreeNode* node = q.front();\n                    q.pop_front();\n                    currLevel.push_back(node->val);\n                    if (node->left)\n                        q.push_back(node->left);\n                    if (node->right)\n                        q.push_back(node->right);\n                } else {\n                    TreeNode* node = q.back();\n                    q.pop_back();\n                    currLevel.push_back(node->val);\n                    if (node->right)\n                        q.push_front(node->right);\n                    if (node->left)\n                        q.push_front(node->left);\n                }\n            ans.push_back(currLevel);\n            isLeftToRight = !isLeftToRight;\n        }\n\n        return ans;\n    }\n};\n"
      }
    },
    "104": {
      "solution": {
        "breadth-first-search": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (!root) return 0; \n        int leftDepth = maxDepth(root->left);\n        int rightDepth = maxDepth(root->right);\n\n        return 1 + max(leftDepth, rightDepth);\n    }\n};\n"
      }
    },
    "105": {
      "solution": {
        "tree": ""
      }
    },
    "106": {
      "solution": {
        "tree": ""
      }
    },
    "107": {
      "solution": {
        "breadth-first-search": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> levelOrderBottom(TreeNode* root) {\n        vector<vector<int>> result;\n        if (!root) return result; \n        queue<TreeNode*> q;\n        q.push(root);\n\n        while (!q.empty()) {\n            int size = q.size();\n            vector<int> currentLevel;\n\n            for (int i = 0; i < size; ++i) {\n                TreeNode* currentNode = q.front();\n                q.pop();\n                currentLevel.push_back(currentNode->val);\n\n                if (currentNode->left) q.push(currentNode->left);\n                if (currentNode->right) q.push(currentNode->right);\n            }\n\n            result.push_back(currentLevel);\n        }\n\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n"
      }
    },
    "108": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode() {}\n * TreeNode(int val) { this.val = val; }\n * TreeNode(int val, TreeNode left, TreeNode right) {\n * this.val = val;\n * this.left = left;\n * this.right = right;\n * }\n * }\n */\nclass Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return null;\n        }\n        return constructBST(nums, 0, nums.length - 1);\n    }\n\n    private TreeNode constructBST(int[] nums, int left, int right) {\n        if (left > right) {\n            return null;\n        }\n\n        int mid = left + (right - left) / 2;\n        TreeNode node = new TreeNode(nums[mid]);\n\n        node.left = constructBST(nums, left, mid - 1);\n        node.right = constructBST(nums, mid + 1, right);\n\n        return node;\n    }\n}"
      }
    },
    "109": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode() {}\n * TreeNode(int val) { this.val = val; }\n * TreeNode(int val, TreeNode left, TreeNode right) {\n * this.val = val;\n * this.left = left;\n * this.right = right;\n * }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        return sortedListToBSTHelper(head, null);\n    }\n\n    private TreeNode sortedListToBSTHelper(ListNode head, ListNode tail) {\n        if (head == tail) {\n            return null;\n        }\n\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast != tail && fast.next != tail) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        TreeNode node = new TreeNode(slow.val);\n        node.left = sortedListToBSTHelper(head, slow);\n        node.right = sortedListToBSTHelper(slow.next, tail);\n        return node;\n    }\n}"
      }
    },
    "110": {
      "solution": {
        "tree": ""
      }
    },
    "111": {
      "solution": {
        "breadth-first-search": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\n * right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        if (!root)\n            return 0;\n\n        queue<pair<TreeNode*, int>> q;\n        q.push({root, 1});\n\n        while (!q.empty()) {\n            auto [node, depth] = q.front();\n            q.pop();\n\n            if (!node->left && !node->right) {\n                return depth;\n            }\n\n            if (node->left)\n                q.push({node->left, depth + 1});\n            if (node->right)\n                q.push({node->right, depth + 1});\n        }\n\n        return 0;\n    }\n};\n"
      }
    },
    "112": {
      "solution": {
        "tree": ""
      }
    },
    "113": {
      "solution": {
        "tree": ""
      }
    },
    "114": {
      "solution": {
        "stack": ""
      }
    },
    "115": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "116": {
      "solution": {
        "tree": ""
      }
    },
    "117": {
      "solution": {
        "tree": ""
      }
    },
    "118": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "119": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "120": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "121": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "122": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "123": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "124": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "125": {
      "solution": {
        "two-pointers": "class Solution {\n    public boolean isPalindrome(String s) {\n        int left = 0, right = s.length() - 1;\n        \n        while (left < right) {\n            char c1 = s.charAt(left);\n            char c2 = s.charAt(right);\n            \n            if (!Character.isLetterOrDigit(c1)) {\n                left++;\n            } else if (!Character.isLetterOrDigit(c2)) {\n                right--;\n            } else {\n                if (Character.toLowerCase(c1) != Character.toLowerCase(c2)) {\n                    return false;\n                }\n                left++;\n                right--;\n            }\n        }\n        \n        return true;\n    }\n}\n"
      }
    },
    "126": {
      "solution": {
        "backtracking": ""
      }
    },
    "127": {
      "solution": {
        "breadth-first-search": ""
      }
    },
    "128": {
      "solution": {
        "union-find": ""
      }
    },
    "129": {
      "solution": {
        "tree": ""
      }
    },
    "130": {
      "solution": {
        "union-find": "",
        "matrix": "class Solution {\n    public void solve(char[][] board) {\n        if (board == null || board.length == 0 || board[0].length == 0) {\n            return;\n        }\n\n        int m = board.length;\n        int n = board[0].length;\n\n        for (int i = 0; i < m; i++) {\n            if (board[i][0] == 'O') {\n                dfs(board, i, 0);\n            }\n            if (board[i][n - 1] == 'O') {\n                dfs(board, i, n - 1);\n            }\n        }\n\n        for (int j = 0; j < n; j++) {\n            if (board[0][j] == 'O') {\n                dfs(board, 0, j);\n            }\n            if (board[m - 1][j] == 'O') {\n                dfs(board, m - 1, j);\n            }\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (board[i][j] == 'O') {\n                    board[i][j] = 'X';\n                } else if (board[i][j] == '*') {\n                    board[i][j] = 'O';\n                }\n            }\n        }\n    }\n\n    private void dfs(char[][] board, int i, int j) {\n        int m = board.length;\n        int n = board[0].length;\n\n        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != 'O') {\n            return;\n        }\n        board[i][j] = '*';\n        dfs(board, i, j + 1);\n        dfs(board, i + 1, j);\n        dfs(board, i, j - 1);\n        dfs(board, i - 1, j);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        char[][] board = {\n            {'X', 'X', 'X', 'X'},\n            {'X', 'O', 'O', 'X'},\n            {'X', 'X', 'O', 'X'},\n            {'X', 'O', 'X', 'X'}\n        };\n\n        solution.solve(board);\n\n        for (char[] row : board) {\n            System.out.println(new String(row));\n        }\n    }\n}\n"
      }
    },
    "131": {
      "solution": {
        "dynamic-programming": "",
        "backtracking": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<List<String>> partition(String s) {\n        List<List<String>> result = new ArrayList<>();\n        dfs(s, 0, new ArrayList<>(), result);\n        return result;\n    }\n\n    private void dfs(String s, int start, List<String> current, List<List<String>> result) {\n        if (start == s.length()) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n        for (int end = start; end < s.length(); end++) {\n            String substring = s.substring(start, end + 1);\n            if (isPalindrome(substring)) {\n                current.add(substring);\n                dfs(s, end + 1, current, result);\n                current.remove(current.size() - 1);\n            }\n        }\n    }\n\n    private boolean isPalindrome(String s) {\n        int left = 0;\n        int right = s.length() - 1;\n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s = \"aab\";\n        List<List<String>> result = solution.partition(s);\n        for (List<String> partition : result) {\n            System.out.println(partition);\n        }\n    }\n}\n"
      }
    },
    "132": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "133": {
      "solution": {
        "graph": ""
      }
    },
    "134": {
      "solution": {
        "greedy": ""
      }
    },
    "135": {
      "solution": {
        "greedy": ""
      }
    },
    "136": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "137": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "138": {
      "solution": {
        "linked-list": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n\n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        if (head == nullptr)\n            return nullptr;\n\n        Node* current = head;\n        while (current != nullptr) {\n            Node* newNode = new Node(current->val);\n            newNode->next = current->next;\n            current->next = newNode;\n            current = newNode->next;\n        }\n\n        current = head;\n        while (current != nullptr) {\n            if (current->random != nullptr) {\n                current->next->random = current->random->next;\n            }\n            current = current->next->next;\n        }\n\n        Node* dummy = new Node(0);\n        Node* copy = dummy;\n        current = head;\n\n        while (current != nullptr) {\n            Node* temp = current->next;\n            current->next = temp->next;\n            copy->next = temp;\n            copy = copy->next;\n            current = current->next;\n        }\n\n        return dummy->next;\n    }\n};\n"
      }
    },
    "139": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "140": {
      "solution": {
        "dynamic-programming": "",
        "backtracking": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Solution {\n\n    public List<String> wordBreak(String s, List<String> wordDict) {\n        return dfs(s, wordDict, new HashMap<>());\n    }\n\n    private List<String> dfs(String s, List<String> wordDict, Map<String, List<String>> memo) {\n        if (memo.containsKey(s)) {\n            return memo.get(s);\n        }\n        if (s.length() == 0) {\n            List<String> baseResult = new ArrayList<>();\n            baseResult.add(\"\");\n            return baseResult;\n        }\n\n        List<String> res = new ArrayList<>();\n        for (String word : wordDict) {\n            if (s.startsWith(word)) {\n                List<String> sublist = dfs(s.substring(word.length()), wordDict, memo);\n                for (String sub : sublist) {\n                    res.add(word + (sub.isEmpty() ? \"\" : \" \") + sub);\n                }\n            }\n        }\n        memo.put(s, res);\n        return res;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s = \"catsanddog\";\n        List<String> wordDict = new ArrayList<>();\n        wordDict.add(\"cat\");\n        wordDict.add(\"cats\");\n        wordDict.add(\"and\");\n        wordDict.add(\"sand\");\n        wordDict.add(\"dog\");\n\n        List<String> result = solution.wordBreak(s, wordDict);\n        for (String sentence : result) {\n            System.out.println(sentence);\n        }\n    }\n}\n"
      }
    },
    "141": {
      "solution": {
        "two-pointers": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return false;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (slow != fast) {\n            if (fast == null || fast.next == null) {\n                return false;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return true;\n    }\n}"
      }
    },
    "142": {
      "solution": {
        "two-pointers": "public class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {\n                slow = head;\n                while (slow != fast) {\n                    slow = slow.next;\n                    fast = fast.next;\n                }\n                return slow; \n            }\n        }\n\n        return null; \n    }\n}\n"
      }
    },
    "143": {
      "solution": {
        "two-pointers": ""
      }
    },
    "144": {
      "solution": {
        "stack": ""
      }
    },
    "145": {
      "solution": {
        "stack": ""
      }
    },
    "146": {
      "solution": {
        "doubly-linked-list": "class LRUCache {\n    class Node {\n        int key;\n        int value;\n        Node prev;\n        Node next;\n        \n        public Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n    \n    private int capacity;\n    private Map<Integer, Node> map;\n    private Node head;\n    private Node tail;\n    \n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        map = new HashMap<>();\n        head = new Node(-1, -1);\n        tail = new Node(-1, -1);\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        if (!map.containsKey(key)) {\n            return -1;\n        }\n        \n        Node node = map.get(key);\n        moveToHead(node);\n        \n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            Node node = map.get(key);\n            node.value = value;\n            moveToHead(node);\n        } else {\n            Node newNode = new Node(key, value);\n            map.put(key, newNode);\n            addToHead(newNode);\n            \n            if (map.size() > capacity) {\n                Node removed = removeTail();\n                map.remove(removed.key);\n            }\n        }\n    }\n    \n    private void moveToHead(Node node) {\n        removeNode(node);\n        addToHead(node);\n    }\n    \n    private void removeNode(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n    \n    private void addToHead(Node node) {\n        node.next = head.next;\n        node.next.prev = node;\n        head.next = node;\n        node.prev = head;\n    }\n    \n    private Node removeTail() {\n        Node nodeToRemove = tail.prev;\n        removeNode(nodeToRemove);\n        return nodeToRemove;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        LRUCache cache = new LRUCache(2); // Capacity is 2\n        cache.put(1, 1);\n        cache.put(2, 2);\n        System.out.println(cache.get(1)); // Output: 1\n        cache.put(3, 3);\n        System.out.println(cache.get(2)); // Output: -1 (not found)\n        cache.put(4, 4);\n        System.out.println(cache.get(1)); // Output: -1 (not found)\n        System.out.println(cache.get(3)); // Output: 3\n        System.out.println(cache.get(4)); // Output: 4\n    }\n}\n"
      }
    },
    "147": {
      "solution": {
        "linked-list": ""
      }
    },
    "148": {
      "solution": {
        "merge-sort": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        ListNode mid = getMid(head);\n        ListNode left = head;\n        ListNode right = mid.next;\n        mid.next = null; \n        left = sortList(left);\n        right = sortList(right);\n\n        return merge(left, right);\n    }\n\n    private ListNode getMid(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        return slow;\n    }\n\n    private ListNode merge(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n\n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                current.next = l1;\n                l1 = l1.next;\n            } else {\n                current.next = l2;\n                l2 = l2.next;\n            }\n            current = current.next;\n        }\n\n        if (l1 != null) {\n            current.next = l1;\n        } else {\n            current.next = l2;\n        }\n\n        return dummy.next;\n    }\n}\n"
      }
    },
    "149": {
      "solution": {
        "geometry": ""
      }
    },
    "150": {
      "solution": {
        "stack": ""
      }
    },
    "151": {
      "solution": {
        "two-pointers": ""
      }
    },
    "152": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "153": {
      "solution": {
        "array": "",
        "binary-search": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int low = 0, high = nums.size() - 1;\n\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n\n            if (nums[mid] > nums[high]) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n\n        return nums[low];\n    }\n};"
      }
    },
    "154": {
      "solution": {
        "array": ""
      }
    },
    "155": {
      "solution": {
        "stack": "import java.util.Stack;\n\nclass MinStack {\n    private Stack<Integer> stack;\n    private Stack<Integer> minStack;\n\n    public MinStack() {\n        stack = new Stack<>();\n        minStack = new Stack<>();\n    }\n\n    public void push(int val) {\n        stack.push(val);\n        if (minStack.isEmpty() || val <= minStack.peek()) {\n            minStack.push(val);\n        }\n    }\n\n    public void pop() {\n        if (stack.peek().equals(minStack.peek())) {\n            minStack.pop();\n        }\n        stack.pop();\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getMin() {\n        return minStack.peek();\n    }\n}"
      }
    },
    "156": {
      "solution": {
        "tree": ""
      }
    },
    "157": {
      "solution": {
        "interactive": ""
      }
    },
    "158": {
      "solution": {
        "interactive": ""
      }
    },
    "159": {
      "solution": {
        "sliding-window": "class Solution {\n    public int lengthOfLongestSubstringTwoDistinct(String s) {\n        Map<Character, Integer> count = new HashMap<>();\n        int n = s.length();\n        int ans = 0;\n        int left = 0;\n        for (int right = 0; right < n; ++right) {\n            char c = s.charAt(right);\n            count.put(c, count.getOrDefault(c, 0) + 1);\n            while (count.size() > 2) {\n                char t = s.charAt(left++);\n                count.put(t, count.get(t) - 1);\n                if (count.get(t) == 0) {\n                    count.remove(t);\n                }\n            }\n            ans = Math.max(ans, right - left + 1);\n        }\n        return ans;\n    }\n}"
      }
    },
    "160": {
      "solution": {
        "linked-list": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {\n        if (headA == nullptr || headB == nullptr)\n            return nullptr;\n\n        int lenA = getLength(headA);\n        int lenB = getLength(headB);\n\n        while (lenA > lenB) {\n            headA = headA->next;\n            lenA--;\n        }\n        while (lenB > lenA) {\n            headB = headB->next;\n            lenB--;\n        }\n\n        while (headA != headB) {\n            headA = headA->next;\n            headB = headB->next;\n        }\n\n        return headA;\n    }\n\nprivate:\n    int getLength(ListNode* head) {\n        int length = 0;\n        while (head != nullptr) {\n            length++;\n            head = head->next;\n        }\n        return length;\n    }\n};\n"
      }
    },
    "161": {
      "solution": {
        "two-pointers": ""
      }
    },
    "162": {
      "solution": {
        "array": "",
        "binary-search": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        int low = 0, high = nums.size() - 1;\n\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n\n            if (nums[mid] > nums[mid + 1]) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return low;\n    }\n};"
      }
    },
    "163": {
      "solution": {
        "array": ""
      }
    },
    "164": {
      "solution": {
        "radix-sort": "class Solution {\n    public int maximumGap(int[] nums) {\n        if (nums == null || nums.length < 2) {\n            return 0;\n        }\n        \n        radixSort(nums);\n        \n        int maxGap = 0;\n        for (int i = 1; i < nums.length; i++) {\n            maxGap = Math.max(maxGap, nums[i] - nums[i - 1]);\n        }\n        return maxGap;\n    }\n\n    private void radixSort(int[] nums) {\n        int max = Arrays.stream(nums).max().getAsInt();\n        int exp = 1;\n        while (max / exp > 0) {\n            countingSort(nums, exp);\n            exp *= 10;\n        }\n    }\n\n    private void countingSort(int[] nums, int exp) {\n        int n = nums.length;\n        int[] output = new int[n];\n        int[] count = new int[10];\n\n        for (int i = 0; i < n; i++) {\n            int index = (nums[i] / exp) % 10;\n            count[index]++;\n        }\n\n        for (int i = 1; i < 10; i++) {\n            count[i] += count[i - 1];\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            int index = (nums[i] / exp) % 10;\n            output[count[index] - 1] = nums[i];\n            count[index]--;\n        }\n\n        System.arraycopy(output, 0, nums, 0, n);\n    }\n}\n",
        "bucket-sort": "import java.util.*;\n\npublic class Solution {\n\n    public int maximumGap(int[] nums) {\n        if (nums == null || nums.length < 2) {\n            return 0;\n        }\n\n        int n = nums.length;\n        int minVal = Integer.MAX_VALUE;\n        int maxVal = Integer.MIN_VALUE;\n\n        for (int num : nums) {\n            minVal = Math.min(minVal, num);\n            maxVal = Math.max(maxVal, num);\n        }\n\n        int bucketSize = Math.max(1, (maxVal - minVal) / (n - 1));\n        int bucketCount = (maxVal - minVal) / bucketSize + 1;\n\n        List<Integer>[] buckets = new ArrayList[bucketCount];\n        for (int i = 0; i < bucketCount; i++) {\n            buckets[i] = new ArrayList<>();\n        }\n\n        for (int num : nums) {\n            int bucketIndex = (num - minVal) / bucketSize;\n            buckets[bucketIndex].add(num);\n        }\n\n        int maxGap = 0;\n        int previousMax = minVal;\n\n        for (int i = 0; i < bucketCount; i++) {\n            if (buckets[i].isEmpty()) {\n                continue;\n            }\n            Collections.sort(buckets[i]);\n            int currentMin = buckets[i].get(0);\n            int currentMax = buckets[i].get(buckets[i].size() - 1);\n            maxGap = Math.max(maxGap, currentMin - previousMax);\n            previousMax = currentMax;\n        }\n\n        return maxGap;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums1 = { 3, 6, 9, 1 };\n        int[] nums2 = { 10 };\n\n        System.out.println(\"Maximum gap for nums1: \" + solution.maximumGap(nums1)); // Output: 3\n        System.out.println(\"Maximum gap for nums2: \" + solution.maximumGap(nums2)); // Output: 0\n    }\n}\n"
      }
    },
    "165": {
      "solution": {
        "two-pointers": ""
      }
    },
    "166": {
      "solution": {
        "math": ""
      }
    },
    "167": {
      "solution": {
        "two-pointers": "class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int left = 0;\n        int right = numbers.length - 1;\n\n        while (left < right) {\n            int sum = numbers[left] + numbers[right];\n            if (sum == target) {\n                return new int[] { left + 1, right + 1 };\n            } else if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return new int[] {};\n    }\n}"
      }
    },
    "168": {
      "solution": {
        "math": ""
      }
    },
    "169": {
      "solution": {
        "divide-and-conquer": "",
        "counting": "class Solution {\n  public int majorityElement(int[] nums) {\n    Integer ans = null;\n    int count = 0;\n\n    for (final int num : nums) {\n      if (count == 0)\n        ans = num;\n      count += num == ans ? 1 : -1;\n    }\n\n    return ans;\n  }\n}"
      }
    },
    "170": {
      "solution": {
        "two-pointers": ""
      }
    },
    "171": {
      "solution": {
        "math": ""
      }
    },
    "172": {
      "solution": {
        "math": ""
      }
    },
    "173": {
      "solution": {
        "iterator": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nimport java.util.*;\n\nclass BSTIterator {\n    private Stack<TreeNode> stack;\n\n    public BSTIterator(TreeNode root) {\n        stack = new Stack<>();\n        pushAll(root);\n    }\n    \n    /** @return the next smallest number */\n    public int next() {\n        TreeNode node = stack.pop();\n        pushAll(node.right);\n        return node.val;\n    }\n    \n    public boolean hasNext() {\n        return !stack.isEmpty();\n    }\n    \n    private void pushAll(TreeNode node) {\n        while (node != null) {\n            stack.push(node);\n            node = node.left;\n        }\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */"
      }
    },
    "174": {
      "solution": {
        "matrix": "public class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}};\n    \n    public int calculateMinimumHP(int[][] dungeon) {\n        int m = dungeon.length;\n        int n = dungeon[0].length;\n        Integer[][] memo = new Integer[m][n]; // Memoization table to store minimum health needed\n        return dfs(dungeon, 0, 0, m, n, memo);\n    }\n    \n    private int dfs(int[][] dungeon, int i, int j, int m, int n, Integer[][] memo) {\n        // Base case: if at the princess's cell, calculate minimum health to survive\n        if (i == m - 1 && j == n - 1) {\n            return Math.max(1, 1 - dungeon[i][j]);\n        }\n        \n        if (memo[i][j] != null) {\n            return memo[i][j];\n        }\n        \n        int minHealth = Integer.MAX_VALUE;\n        \n        // Explore right and down directions\n        for (int[] dir : DIRECTIONS) {\n            int ni = i + dir[0];\n            int nj = j + dir[1];\n            \n            if (ni < m && nj < n) {\n                minHealth = Math.min(minHealth, dfs(dungeon, ni, nj, m, n, memo));\n            }\n        }\n        \n        int healthRequired = Math.max(1, minHealth - dungeon[i][j]);        \n        memo[i][j] = healthRequired;\n        \n        return healthRequired;\n    }\n}\n"
      }
    },
    "175": {
      "solution": {
        "database": ""
      }
    },
    "176": {
      "solution": {
        "database": ""
      }
    },
    "177": {
      "solution": {
        "database": ""
      }
    },
    "178": {
      "solution": {
        "database": ""
      }
    },
    "179": {
      "solution": {
        "greedy": ""
      }
    },
    "180": {
      "solution": {
        "database": ""
      }
    },
    "181": {
      "solution": {
        "database": ""
      }
    },
    "182": {
      "solution": {
        "database": ""
      }
    },
    "183": {
      "solution": {
        "database": ""
      }
    },
    "184": {
      "solution": {
        "database": ""
      }
    },
    "185": {
      "solution": {
        "database": ""
      }
    },
    "186": {
      "solution": {
        "two-pointers": ""
      }
    },
    "187": {
      "solution": {
        "sliding-window": "import java.util.List;\nimport java.util.Map;\n\nclass Solution {\n    public List<String> findRepeatedDnaSequences(String s) {\n        List<String> result = new ArrayList<>();\n        if (s.length() <= 10) return result;\n\n        Map<String, Integer> sequenceCount = new HashMap<>();\n        for (int i = 0; i <= s.length() - 10; i++) {\n            String sequence = s.substring(i, i + 10);\n            sequenceCount.put(sequence, sequenceCount.getOrDefault(sequence, 0) + 1);\n            if (sequenceCount.get(sequence) == 2) {\n                result.add(sequence);\n            }\n        }\n\n        return result;\n    }\n}"
      }
    },
    "188": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "189": {
      "solution": {
        "two-pointers": "class Solution {\n    public void rotate(int[] nums, int k) {\n        k = k % nums.length;\n        reverse(nums, 0, nums.length - 1);\n        reverse(nums, 0, k - 1);\n        reverse(nums, k, nums.length - 1);\n    }\n\n    private void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            int temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}"
      }
    },
    "190": {
      "solution": {
        "divide-and-conquer": ""
      }
    },
    "191": {
      "solution": {
        "divide-and-conquer": ""
      }
    },
    "192": {
      "solution": {
        "shell": "#!/bin/bash\ntr -s ' ' '\\n' < words.txt | sort | uniq -c | awk '{print $2, $1}' | sort -nr -k2\n"
      }
    },
    "193": {
      "solution": {
        "shell": "#!/bin/bash\ngrep -E '^(([0-9]{3}) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$)' file.txt"
      }
    },
    "194": {
      "solution": {
        "shell": "#!/bin/bash\nawk '\n{\n    for (i = 1; i <= NF; i++) {\n        if (NR == 1) {\n            res[i] = $i;\n        } else {\n            res[i] = res[i] \" \" $i;\n        }\n    }\n}\nEND {\n    for (i = 1; i <= NF; i++) {\n        print res[i];\n    }\n}' file.txt\n"
      }
    },
    "195": {
      "solution": {
        "shell": "#!/bin/bash\nsed '10q;d' file.txt"
      }
    },
    "196": {
      "solution": {
        "database": ""
      }
    },
    "197": {
      "solution": {
        "database": ""
      }
    },
    "198": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "199": {
      "solution": {
        "breadth-first-search": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) {\n        vector<int> result;\n        if (!root) return result; \n        \n        queue<TreeNode*> q;\n        q.push(root);\n\n        while (!q.empty()) {\n            int size = q.size();\n            TreeNode* rightMost = nullptr;\n\n            for (int i = 0; i < size; ++i) {\n                TreeNode* currentNode = q.front();\n                q.pop();\n\n                rightMost = currentNode;\n\n                if (currentNode->left) q.push(currentNode->left);\n                if (currentNode->right) q.push(currentNode->right);\n            }\n\n            if (rightMost) result.push_back(rightMost->val);\n        }\n\n        return result;\n    }\n};\n"
      }
    },
    "200": {
      "solution": {
        "union-find": "",
        "matrix": "class Solution {\n\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public int numIslands(char[][] grid) {\n        if (grid == null || grid.length == 0) {\n            return 0;\n        }\n\n        int m = grid.length;\n        int n = grid[0].length;\n        int numIslands = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    numIslands++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n\n        return numIslands;\n    }\n\n    private void dfs(char[][] grid, int i, int j) {\n        int m = grid.length;\n        int n = grid[0].length;\n\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != '1') {\n            return;\n        }\n        grid[i][j] = '0';\n        for (int[] direction : DIRECTIONS) {\n            int newRow = i + direction[0];\n            int newCol = j + direction[1];\n            dfs(grid, newRow, newCol);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        char[][] grid = {\n            {'1', '1', '1', '1', '0'},\n            {'1', '1', '0', '1', '0'},\n            {'1', '1', '0', '0', '0'},\n            {'0', '0', '0', '0', '0'}\n        };\n\n        int result = solution.numIslands(grid);\n        System.out.println(\"Number of Islands: \" + result); // Output: 1\n    }\n}\n"
      }
    },
    "201": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "202": {
      "solution": {
        "two-pointers": "import java.util.HashSet;\n\npublic class Solution {\n    public boolean isHappy(int n) {\n        HashSet<Integer> seen = new HashSet<>();\n\n        while (n != 1 && !seen.contains(n)) {\n            seen.add(n);\n            n = getNextNumber(n);\n        }\n\n        return n == 1;\n    }\n\n    private int getNextNumber(int n) {\n        int sum = 0;\n        while (n > 0) {\n            int digit = n % 10;\n            sum += digit * digit;\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"
      }
    },
    "203": {
      "solution": {
        "recursion": ""
      }
    },
    "204": {
      "solution": {
        "number-theory": "class Solution {\npublic:\n    int countPrimes(int n) {\n        if (n <= 2) return 0;\n\n        vector<bool> isPrime(n, true);\n        isPrime[0] = isPrime[1] = false; \n        \n        for (int i = 2; i * i < n; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < n; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        int count = 0;\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n};\n"
      }
    },
    "205": {
      "solution": {
        "hash-table": ""
      }
    },
    "206": {
      "solution": {
        "linked-list": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n\n        while (curr != nullptr) {\n            ListNode* nextNode = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextNode;\n        }\n\n        return prev;\n    }\n};\n"
      }
    },
    "207": {
      "solution": {
        "topological-sort": "class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        List<List<Integer>> adjList = new ArrayList<>();\n\n        for (int i = 0; i < numCourses; i++) {\n            adjList.add(new ArrayList<>());\n        }\n\n        int[] indegree = new int[numCourses];\n\n        for (int[] prerequisite : prerequisites) {\n            int course = prerequisite[0];\n            int prerequisiteCourse = prerequisite[1];\n\n            adjList.get(prerequisiteCourse).add(course);\n            indegree[course]++;\n        }\n\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < numCourses; i++) {\n            if (indegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n\n        int visitedCount = 0;\n        \n        while (!queue.isEmpty()) {\n            int course = queue.poll();\n            visitedCount++;\n\n            for (int neighbor : adjList.get(course)) {\n                indegree[neighbor]--;\n                if (indegree[neighbor] == 0) {\n                    queue.offer(neighbor);\n                }\n            }\n        }\n\n        return visitedCount == numCourses;\n    }\n}"
      }
    },
    "208": {
      "solution": {
        "trie": "class TrieNode {\n  public TrieNode[] children = new TrieNode[26];\n  public boolean isWord = false;\n}\n\nclass Trie {\n  public void insert(String word) {\n    TrieNode node = root;\n    for (final char c : word.toCharArray()) {\n      final int i = c - 'a';\n      if (node.children[i] == null)\n        node.children[i] = new TrieNode();\n      node = node.children[i];\n    }\n    node.isWord = true;\n  }\n\n  public boolean search(String word) {\n    TrieNode node = find(word);\n    return node != null && node.isWord;\n  }\n\n  public boolean startsWith(String prefix) {\n    return find(prefix) != null;\n  }\n\n  private TrieNode root = new TrieNode();\n\n  private TrieNode find(String prefix) {\n    TrieNode node = root;\n    for (final char c : prefix.toCharArray()) {\n      final int i = c - 'a';\n      if (node.children[i] == null)\n        return null;\n      node = node.children[i];\n    }\n    return node;\n  }\n}\n"
      }
    },
    "209": {
      "solution": {
        "sliding-window": "public class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int n = nums.length;\n        int minLength = Integer.MAX_VALUE;\n        int left = 0;\n        int sum = 0;\n        \n        for (int right = 0; right < n; right++) {\n            sum += nums[right];\n            \n            while (sum >= target) {\n                minLength = Math.min(minLength, right - left + 1);\n                sum -= nums[left];\n                left++;\n            }\n        }\n        \n        return (minLength == Integer.MAX_VALUE) ? 0 : minLength;\n    }\n}\n"
      }
    },
    "210": {
      "solution": {
        "topological-sort": "class Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        List<List<Integer>> adjList = new ArrayList<>();\n        Queue<Integer> queue = new LinkedList<>();\n        List<Integer> result = new ArrayList<>();\n\n        for (int i = 0; i < numCourses; i++) {\n            adjList.add(new ArrayList<>());\n        }\n\n        int[] in_degree = new int[numCourses];\n        int visitedCount = 0;\n\n        for (int[] prerequisite : prerequisites) {\n            int course = prerequisite[0];\n            int preRequisiteCourse = prerequisite[1];\n            adjList.get(preRequisiteCourse).add(course);\n            in_degree[course]++;\n        }\n\n        for (int i = 0; i < numCourses; i++) {\n            if (in_degree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            int course = queue.poll();\n            result.add(course);\n            visitedCount++;\n            for (int neighbor : adjList.get(course)) {\n                if (--in_degree[neighbor] == 0) {\n                    queue.offer(neighbor);\n                }\n            }\n        }\n\n        if (visitedCount == numCourses) {\n            return result.stream().mapToInt(Integer::intValue).toArray();\n        }\n\n        return new int[0];\n    }\n}"
      }
    },
    "211": {
      "solution": {
        "trie": "class TrieNode {\n    public TrieNode[] children = new TrieNode[26];\n    public boolean isWord = false;\n}\n\nclass WordDictionary {\n    public void addWord(String word) {\n        TrieNode node = root;\n        for (final char c : word.toCharArray()) {\n            final int i = c - 'a';\n            if (node.children[i] == null)\n                node.children[i] = new TrieNode();\n            node = node.children[i];\n        }\n        node.isWord = true;\n    }\n\n    public boolean search(String word) {\n        return dfs(word, 0, root);\n    }\n\n    private TrieNode root = new TrieNode();\n\n    private boolean dfs(String word, int s, TrieNode node) {\n        if (s == word.length())\n            return node.isWord;\n        if (word.charAt(s) != '.') {\n            TrieNode next = node.children[word.charAt(s) - 'a'];\n            return next == null ? false : dfs(word, s + 1, next);\n        }\n\n        // word.charAt(s) == '.' -> search all 26 children\n        for (int i = 0; i < 26; ++i)\n            if (node.children[i] != null && dfs(word, s + 1, node.children[i]))\n                return true;\n\n        return false;\n    }\n}\n"
      }
    },
    "212": {
      "solution": {
        "matrix": "class Solution {\n    private static final int[][] DIRECTIONS = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\n\n    public List<String> findWords(char[][] board, String[] words) {\n        List<String> result = new ArrayList<>();\n        if (board == null || board.length == 0 || words == null || words.length == 0) {\n            return result;\n        }\n\n        TrieNode root = buildTrie(words);\n        int rows = board.length;\n        int cols = board[0].length;\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                dfs(board, i, j, root, result);\n            }\n        }\n\n        return result;\n    }\n\n    private void dfs(char[][] board, int row, int col, TrieNode node, List<String> result) {\n        char c = board[row][col];\n        if (c == '#' || node.children[c - 'a'] == null) {\n            return;\n        }\n\n        node = node.children[c - 'a'];\n        if (node.word != null) { // Found a word\n            result.add(node.word);\n            node.word = null; // To avoid duplicate results\n        }\n\n        board[row][col] = '#';\n        for (int[] dir : DIRECTIONS) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n            if (newRow >= 0 && newRow < board.length && newCol >= 0 && newCol < board[0].length) {\n                dfs(board, newRow, newCol, node, result);\n            }\n        }\n        board[row][col] = c;\n    }\n\n    private TrieNode buildTrie(String[] words) {\n        TrieNode root = new TrieNode();\n        for (String word : words) {\n            TrieNode node = root;\n            for (char c : word.toCharArray()) {\n                int index = c - 'a';\n                if (node.children[index] == null) {\n                    node.children[index] = new TrieNode();\n                }\n                node = node.children[index];\n            }\n            node.word = word;\n        }\n        return root;\n    }\n\n    static class TrieNode {\n        TrieNode[] children = new TrieNode[26];\n        String word;\n    }\n}\n"
      }
    },
    "213": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "214": {
      "solution": {
        "rolling-hash": "",
        "hash-function": "class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        string rev = s;\n        reverse(rev.begin(), rev.end());\n\n        string combined = s + \"#\" + rev;\n\n        vector<int> prefix(combined.size(), 0);\n        for (int i = 1; i < combined.size(); i++) {\n            int j = prefix[i - 1];\n            while (j > 0 && combined[i] != combined[j]) {\n                j = prefix[j - 1];\n            }\n            if (combined[i] == combined[j]) {\n                j++;\n            }\n            prefix[i] = j;\n        }\n\n        int longest_palindrome_prefix_len = prefix.back();\n\n        return rev.substr(0, s.size() - longest_palindrome_prefix_len) + s;\n    }\n};\n"
      }
    },
    "215": {
      "solution": {
        "quickselect": "public class Solution {\n    public int findKthLargest(int[] nums, int k) {\n        int left = 0, right = nums.length - 1;\n        Random rand = new Random();\n        while (true) {\n            int pivot_index = left + rand.nextInt(right - left + 1);\n            int new_pivot_index = partition(nums, left, right, pivot_index);\n            if (new_pivot_index == nums.length - k) {\n                return nums[new_pivot_index];\n            } else if (new_pivot_index > nums.length - k) {\n                right = new_pivot_index - 1;\n            } else {\n                left = new_pivot_index + 1;\n            }\n        }\n    }\n\n    private int partition(int[] nums, int left, int right, int pivot_index) {\n        int pivot = nums[pivot_index];\n        swap(nums, pivot_index, right);\n        int stored_index = left;\n        for (int i = left; i < right; i++) {\n            if (nums[i] < pivot) {\n                swap(nums, i, stored_index);\n                stored_index++;\n            }\n        }\n        swap(nums, right, stored_index);\n        return stored_index;\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}",
        "heap-(priority-queue)": "class Solution {\n  public int findKthLargest(int[] nums, int k) {\n    Queue<Integer> minHeap = new PriorityQueue<>();\n\n    for (final int num : nums) {\n      minHeap.offer(num);\n      while (minHeap.size() > k)\n        minHeap.poll();\n    }\n\n    return minHeap.peek();\n  }\n}"
      }
    },
    "216": {
      "solution": {
        "backtracking": ""
      }
    },
    "217": {
      "solution": {
        "sorting": ""
      }
    },
    "218": {
      "solution": {
        "line-sweep": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> getSkyline(int[][] buildings) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<int[]> heights = new ArrayList<>();\n        \n        // Step 1: Collect Events\n        for (int[] building : buildings) {\n            heights.add(new int[]{building[0], -building[2]}); // start event\n            heights.add(new int[]{building[1], building[2]});  // end event\n        }\n        \n        // Step 2: Sort Events\n        Collections.sort(heights, (a, b) -> {\n            if (a[0] != b[0]) {\n                return a[0] - b[0];\n            }\n            return a[1] - b[1];\n        });\n        \n        // Step 3: Process Events\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n        pq.offer(0);\n        int prevHeight = 0;\n        \n        for (int[] h : heights) {\n            if (h[1] < 0) {\n                pq.offer(-h[1]); // start event\n            } else {\n                pq.remove(h[1]); // end event\n            }\n            int currHeight = pq.peek();\n            if (prevHeight != currHeight) {\n                result.add(Arrays.asList(h[0], currHeight));\n                prevHeight = currHeight;\n            }\n        }\n        \n        return result;\n    }\n}\n"
      }
    },
    "219": {
      "solution": {
        "sliding-window": "import java.util.HashSet;\n\npublic class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        if (nums == null || nums.length == 0 || k <= 0) {\n            return false;\n        }\n        \n        HashSet<Integer> set = new HashSet<>();\n        \n        for (int i = 0; i < nums.length; i++) {\n            if (set.contains(nums[i])) {\n                return true;\n            }\n            \n            set.add(nums[i]);\n            \n            if (set.size() > k) {\n                set.remove(nums[i - k]);\n            }\n        }\n        \n        return false;\n    }\n}\n"
      }
    },
    "220": {
      "solution": {
        "bucket-sort": "import java.util.*;\n\npublic class Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n        if (k <= 0 || t < 0) {\n            return false;\n        }\n\n        Map<Long, Long> bucketMap = new HashMap<>();\n        long bucketSize = (long) t + 1;\n\n        for (int i = 0; i < nums.length; i++) {\n            long num = (long) nums[i];\n            long bucket = getBucket(num, bucketSize);\n\n            if (bucketMap.containsKey(bucket)) {\n                return true;\n            }\n\n            if (bucketMap.containsKey(bucket - 1) && Math.abs(num - bucketMap.get(bucket - 1)) < bucketSize) {\n                return true;\n            }\n            if (bucketMap.containsKey(bucket + 1) && Math.abs(num - bucketMap.get(bucket + 1)) < bucketSize) {\n                return true;\n            }\n\n            bucketMap.put(bucket, num);\n            if (i >= k) {\n                bucketMap.remove(getBucket((long) nums[i - k], bucketSize));\n            }\n        }\n\n        return false;\n    }\n\n    private long getBucket(long num, long bucketSize) {\n        return num < 0 ? (num + 1) / bucketSize - 1 : num / bucketSize;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums1 = { 1, 2, 3, 1 };\n        int k1 = 3, t1 = 0;\n        System.out.println(solution.containsNearbyAlmostDuplicate(nums1, k1, t1)); // Output: true\n\n        int[] nums2 = { 1, 0, 1, 1 };\n        int k2 = 1, t2 = 2;\n        System.out.println(solution.containsNearbyAlmostDuplicate(nums2, k2, t2)); // Output: true\n\n        int[] nums3 = { 1, 5, 9, 1, 5, 9 };\n        int k3 = 2, t3 = 3;\n        System.out.println(solution.containsNearbyAlmostDuplicate(nums3, k3, t3)); // Output: false\n    }\n}\n",
        "sliding-window": "import java.util.TreeSet;\n\npublic class Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n        if (nums == null || nums.length == 0 || k <= 0 || t < 0) {\n            return false;\n        }\n        \n        TreeSet<Long> set = new TreeSet<>();\n        \n        for (int i = 0; i < nums.length; i++) {\n            long num = nums[i];\n            \n            Long floor = set.floor(num + t);\n            if (floor != null && floor >= num - t) {\n                return true;\n            }\n            \n            set.add(num);\n            \n            if (set.size() > k) {\n                set.remove((long) nums[i - k]);\n            }\n        }\n        \n        return false;\n    }\n}\n",
        "ordered-set": "#include <iostream>\n#include <vector>\n#include <set>\n#include <cmath>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n        if (k <= 0 || t < 0) return false;\n\n        set<long long> window;\n        for (int i = 0; i < nums.size(); i++) {\n            auto it = window.lower_bound((long long)nums[i] - (long long)t);\n            if (it != window.end() && *it <= (long long)nums[i] + (long long)t) {\n                return true;\n            }\n\n            window.insert(nums[i]);\n\n            if (window.size() > k) {\n                window.erase(nums[i - k]);\n            }\n        }\n\n        return false;\n    }\n};\n"
      }
    },
    "221": {
      "solution": {
        "matrix": ""
      }
    },
    "222": {
      "solution": {
        "tree": ""
      }
    },
    "223": {
      "solution": {
        "geometry": ""
      }
    },
    "224": {
      "solution": {
        "stack": "import java.util.Stack;\n\npublic class Solution {\n    public int calculate(String s) {\n        Stack<Integer> stack = new Stack<>();\n        int result = 0;\n        int number = 0;\n        int sign = 1; \n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n\n            if (Character.isDigit(c)) {\n                number = number * 10 + (c - '0');\n            } else if (c == '+') {\n                result += sign * number;\n                number = 0;\n                sign = 1;\n            } else if (c == '-') {\n                result += sign * number;\n                number = 0;\n                sign = -1;\n            } else if (c == '(') {\n                stack.push(result);\n                stack.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c == ')') {\n                result += sign * number;\n                number = 0;\n                result *= stack.pop();\n                result += stack.pop();\n            }\n        }\n\n        if (number != 0) {\n            result += sign * number;\n        }\n\n        return result;\n    }\n}\n"
      }
    },
    "225": {
      "solution": {
        "queue": "import java.util.LinkedList;\nimport java.util.Queue;\n\nclass MyStack {\n\n    private Queue<Integer> queue1;\n    private Queue<Integer> queue2;\n\n    public MyStack() {\n        queue1 = new LinkedList<>();\n        queue2 = new LinkedList<>();\n    }\n    \n    public void push(int x) {\n        queue2.offer(x);\n        while (!queue1.isEmpty()) {\n            queue2.offer(queue1.poll());\n        }\n        Queue<Integer> temp = queue1;\n        queue1 = queue2;\n        queue2 = temp;\n    }\n    \n    public int pop() {\n        if (queue1.isEmpty()) {\n            throw new RuntimeException(\"Stack is empty\");\n        }\n        return queue1.poll();\n    }\n    \n    public int top() {\n        if (queue1.isEmpty()) {\n            throw new RuntimeException(\"Stack is empty\");\n        }\n        return queue1.peek();\n    }\n    \n    public boolean empty() {\n        return queue1.isEmpty();\n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack obj = new MyStack();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.top();\n * boolean param_4 = obj.empty();\n */\n"
      }
    },
    "226": {
      "solution": {
        "breadth-first-search": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if (!root) return nullptr; \n        \n        TreeNode* temp = root->left;\n        root->left = root->right;\n        root->right = temp;\n\n        invertTree(root->left);\n        invertTree(root->right);\n\n        return root;\n    }\n};"
      }
    },
    "227": {
      "solution": {
        "stack": ""
      }
    },
    "228": {
      "solution": {
        "array": ""
      }
    },
    "229": {
      "solution": {
        "counting": "class Solution {\n  public List<Integer> majorityElement(int[] nums) {\n    List<Integer> ans = new ArrayList<>();\n    int candidate1 = 0;\n    int candidate2 = 1;  \n    int countSoFar1 = 0;\n    int countSoFar2 = 0; \n\n    for (final int num : nums)\n      if (num == candidate1) {\n        ++countSoFar1;\n      } else if (num == candidate2) {\n        ++countSoFar2;\n      } else if (countSoFar1 == 0) { \n        candidate1 = num;\n        ++countSoFar1;\n      } else if (countSoFar2 == 0) {\n        candidate2 = num;\n        ++countSoFar2;\n      } else { \n        --countSoFar1;\n        --countSoFar2;\n      }\n\n    int count1 = 0;\n    int count2 = 0;\n\n    for (final int num : nums)\n      if (num == candidate1)\n        ++count1;\n      else if (num == candidate2)\n        ++count2;\n\n    if (count1 > nums.length / 3)\n      ans.add(candidate1);\n    if (count2 > nums.length / 3)\n      ans.add(candidate2);\n    return ans;\n  }\n}"
      }
    },
    "230": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode() {}\n * TreeNode(int val) { this.val = val; }\n * TreeNode(int val, TreeNode left, TreeNode right) {\n * this.val = val;\n * this.left = left;\n * this.right = right;\n * }\n * }\n */\nclass Solution {\n    private int count = 0;\n    private int result = 0;\n\n    public int kthSmallest(TreeNode root, int k) {\n        inorder(root, k);\n        return result;\n    }\n\n    private void inorder(TreeNode root, int k) {\n        if (root == null) {\n            return;\n        }\n\n        inorder(root.left, k);\n\n        count++;\n        if (count == k) {\n            result = root.val;\n            return;\n        }\n\n        inorder(root.right, k);\n    }\n}"
      }
    },
    "231": {
      "solution": {
        "recursion": ""
      }
    },
    "232": {
      "solution": {
        "queue": "import java.util.Stack;\n\nclass MyQueue {\n\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n    \n    public int peek() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n"
      }
    },
    "233": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "234": {
      "solution": {
        "linked-list": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n\n    public boolean isPalindrome(ListNode head) {\n        if (head == null || head.next == null)\n            return true;\n\n        ListNode slow = head, fast = head;\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        ListNode secondHalf = reverseLinkedList(slow.next);\n        \n        ListNode p1 = head;\n        ListNode p2 = secondHalf;\n        while (p2 != null) {\n            if (p1.val != p2.val)\n                return false;\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        \n        reverseLinkedList(secondHalf);\n\n        return true;\n    }\n\n    private ListNode reverseLinkedList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextNode = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextNode;\n        }\n        return prev;\n    }\n\n}"
      }
    },
    "235": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\n\npublic class Solution {\n\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null) {\n            return null;\n        }\n\n        if (p.val < root.val && q.val < root.val) {\n            return lowestCommonAncestor(root.left, p, q);\n        } else if (p.val > root.val && q.val > root.val) {\n            return lowestCommonAncestor(root.right, p, q);\n        } else {\n            return root;\n        }\n    }\n\n}\n"
      }
    },
    "236": {
      "solution": {
        "tree": ""
      }
    },
    "237": {
      "solution": {
        "linked-list": ""
      }
    },
    "238": {
      "solution": {
        "prefix-sum": "public class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        \n        int[] answer = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            answer[i] = 1;\n        }\n        \n        int prefix = 1;\n        for (int i = 0; i < n; i++) {\n            answer[i] = prefix;\n            prefix *= nums[i];\n        }\n        \n        int postfix = 1;\n        for (int i = n - 1; i >= 0; i--) {\n            answer[i] *= postfix;\n            postfix *= nums[i];\n        }\n        \n        return answer;\n    }\n}\n"
      }
    },
    "239": {
      "solution": {
        "monotonic-queue": "import java.util.*;\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        if (n * k == 0) return new int[0]; \n        if (k == 1) return nums; \n        Deque<Integer> deque = new LinkedList<>();\n        int[] result = new int[n - k + 1]; \n        for (int i = 0; i < n; i++) {\n            while (!deque.isEmpty() && deque.peek() < i - k + 1) {\n                deque.poll();\n            }\n            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {\n                deque.pollLast();\n            }\n            deque.offer(i); \n            if (i - k + 1 >= 0) {\n                result[i - k + 1] = nums[deque.peek()];\n            }\n        }\n        return result;\n    }\n}\n"
      }
    },
    "240": {
      "solution": {
        "matrix": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return false;\n        }\n        \n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        \n        int row = 0;\n        int col = cols - 1;\n        \n        while (row < rows && col >= 0) {\n            if (matrix[row][col] == target) {\n                return true;\n            } else if (matrix[row][col] > target) {\n                col--;  // Moving left (reduce column)\n            } else {\n                row++;  // Moving down (increase row)\n            }\n        }\n        \n        return false;\n    }\n}\n"
      }
    },
    "241": {
      "solution": {
        "memoization": "#include <vector>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> diffWaysToCompute(string expression) {\n        unordered_map<string, vector<int>> memo; // Memoization map\n        return helper(expression, memo);\n    }\n    \nprivate:\n    vector<int> helper(const string& expression, unordered_map<string, vector<int>>& memo) {\n        if (memo.find(expression) != memo.end()) {\n            return memo[expression];\n        }\n        \n        vector<int> results;\n        bool isNumber = true;\n        \n        for (int i = 0; i < expression.length(); ++i) {\n            char c = expression[i];\n            if (c == '+' || c == '-' || c == '*') {\n                isNumber = false;\n                \n                string left = expression.substr(0, i);\n                string right = expression.substr(i + 1);\n                \n                vector<int> leftResults = helper(left, memo);\n                vector<int> rightResults = helper(right, memo);\n                \n                for (int l : leftResults) {\n                    for (int r : rightResults) {\n                        if (c == '+') {\n                            results.push_back(l + r);\n                        } else if (c == '-') {\n                            results.push_back(l - r);\n                        } else if (c == '*') {\n                            results.push_back(l * r);\n                        }\n                    }\n                }\n            }\n        }\n        \n        if (isNumber) {\n            results.push_back(stoi(expression));\n        }\n        \n        memo[expression] = results;\n        return results;\n    }\n};\n"
      }
    },
    "242": {
      "solution": {
        "sorting": ""
      }
    },
    "243": {
      "solution": {
        "string": ""
      }
    },
    "244": {
      "solution": {
        "two-pointers": ""
      }
    },
    "245": {
      "solution": {
        "string": ""
      }
    },
    "246": {
      "solution": {
        "two-pointers": ""
      }
    },
    "247": {
      "solution": {
        "recursion": "const char pairs[5][2] = { {'0','0'},{'1','1'},{'8','8'},{'6','9'},{'9','6'} };\nclass Solution {\npublic:\n    vector<string> findStrobogrammatic(int n) {\n        string s(n, '0');\n        vector<string> ans;\n        function<void(int)> dfs = [&](int i) {\n            if (i == (n + 1) / 2) {\n                ans.push_back(s);\n                return;\n            }\n            int j = n - 1 - i;\n            for (auto &[a, b] : pairs) {\n                if (i == j && a != b) continue;\n                if (i == 0 && n > 1 && a == '0') continue;\n                s[i] = a;\n                s[j] = b;\n                dfs(i + 1);\n            }\n        };\n        dfs(0);\n        return ans;\n    }\n};"
      }
    },
    "248": {
      "solution": {
        "recursion": ""
      }
    },
    "249": {
      "solution": {
        "hash-table": ""
      }
    },
    "250": {
      "solution": {
        "tree": ""
      }
    },
    "251": {
      "solution": {
        "iterator": "class Vector2D {\n    private int i;\n    private int j;\n    private int[][] vec;\n\n    public Vector2D(int[][] vec) {\n        this.vec = vec;\n    }\n\n    public int next() {\n        forward();\n        return vec[i][j++];\n    }\n\n    public boolean hasNext() {\n        forward();\n        return i < vec.length;\n    }\n\n    private void forward() {\n        while (i < vec.length && j >= vec[i].length) {\n            ++i;\n            j = 0;\n        }\n    }\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * Vector2D obj = new Vector2D(vec);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */"
      }
    },
    "252": {
      "solution": {
        "sorting": "class Solution {\npublic:\n    bool canAttendMeetings(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] < b[0];\n        });\n        for (int i = 1; i < intervals.size(); ++i) {\n            if (intervals[i][0] < intervals[i - 1][1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};"
      }
    },
    "253": {
      "solution": {
        "two-pointers": ""
      }
    },
    "254": {
      "solution": {
        "backtracking": ""
      }
    },
    "255": {
      "solution": {
        "binary-search-tree": "class Solution {\n    public boolean verifyPreorder(int[] preorder) {\n        Deque<Integer> stack = new ArrayDeque<>();\n        int last = Integer.MIN_VALUE;\n        for (int x : preorder) {\n            if (x < last) {\n                return false;\n            }\n            while (!stack.isEmpty() && stack.peek() < x) {\n                last = stack.poll();\n            }\n            stack.push(x);\n        }\n        return true;\n    }\n}"
      }
    },
    "256": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "257": {
      "solution": {
        "tree": "",
        "backtracking": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> result = new ArrayList<>();\n        dfs(root, result, \"\");\n        return result;\n    }\n\n    private void dfs(TreeNode root, List<String> res, String path) {\n        if (root == null) return;\n        if (root.left == null && root.right == null) {\n            res.add(path + root.val);\n            return;\n        }\n        if (root.left != null) {\n            dfs(root.left, res, path + root.val + \"->\");\n        }\n        if (root.right != null) {\n            dfs(root.right, res, path + root.val + \"->\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        TreeNode t = new TreeNode(1);\n        t.left = new TreeNode(2);\n        t.left.right = new TreeNode(5);\n        t.right = new TreeNode(3);\n\n        List<String> paths = solution.binaryTreePaths(t);\n        for (String path : paths) {\n            System.out.println(path);\n        }\n    }\n}\n"
      }
    },
    "258": {
      "solution": {
        "number-theory": "class Solution {\npublic:\n    int addDigits(int num) {\n        if (num == 0) return 0;\n        \n        return 1 + (num - 1) % 9;\n    }\n};\n"
      }
    },
    "259": {
      "solution": {
        "two-pointers": "",
        "binary-search": "class Solution {\npublic:\n    int threeSumSmaller(vector<int>& nums, int target) {\n        sort(nums.begin(), nums.end());\n        int tripletCount = 0;\n\n        for (int i = 0, n = nums.size(); i < n; ++i) {\n            int left = i + 1, right = n - 1;\n\n            while (left < right) {\n                int currentSum = nums[i] + nums[left] + nums[right];\n\n                if (currentSum >= target) {\n                    --right; \n                } else {\n                    tripletCount += right - left; \n                    ++left; \n                }\n            }\n        }\n        return tripletCount;\n    }\n};\n"
      }
    },
    "260": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "261": {
      "solution": {
        "union-find": "class Solution {\npublic:\n    vector<int> parent;\n\n    bool validTree(int n, vector<vector<int>>& edges) {\n        parent.resize(n);\n        for (int i = 0; i < n; ++i) parent[i] = i;\n        for (auto& e : edges) {\n            int a = e[0], b = e[1];\n            if (find(a) == find(b)) return false; // Cycle detected\n            parent[find(a)] = find(b);\n            --n;\n        }\n        return n == 1;\n    }\n\n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]); // Path compression\n        return parent[x];\n    }\n};\n"
      }
    },
    "262": {
      "solution": {
        "database": ""
      }
    },
    "263": {
      "solution": {
        "math": ""
      }
    },
    "264": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "265": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "266": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "267": {
      "solution": {
        "backtracking": ""
      }
    },
    "268": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "269": {
      "solution": {
        "topological-sort": "class Solution {\n public:\n  string alienOrder(vector<string>& words) {\n    unordered_map<char, unordered_set<char>> graph;\n    vector<int> inDegrees(26);\n    buildGraph(graph, words, inDegrees);\n    return topology(graph, inDegrees);\n  }\n\n private:\n  void buildGraph(unordered_map<char, unordered_set<char>>& graph,\n                  const vector<string>& words, vector<int>& inDegrees) {\n    for (const string& word : words)\n      for (const char c : word)\n        if (!graph.contains(c))\n          graph[c] = unordered_set<char>();\n\n    for (int i = 1; i < words.size(); ++i) {\n      const string& first = words[i - 1];\n      const string& second = words[i];\n      const int length = min(first.length(), second.length());\n      for (int j = 0; j < length; ++j) {\n        const char u = first[j];\n        const char v = second[j];\n        if (u != v) {\n          if (!graph[u].contains(v)) {\n            graph[u].insert(v);\n            ++inDegrees[v - 'a'];\n          }\n          break;\n        }\n        if (j == length - 1 && first.length() > second.length()) {\n          graph.clear();\n          return;\n        }\n      }\n    }\n  }\n\n  string topology(unordered_map<char, unordered_set<char>>& graph,\n                  vector<int>& inDegrees) {\n    string s;\n    queue<char> q;\n\n    for (const auto& [c, _] : graph)\n      if (inDegrees[c - 'a'] == 0)\n        q.push(c);\n\n    while (!q.empty()) {\n      const char u = q.front();\n      q.pop();\n      s += u;\n      for (const char v : graph[u])\n        if (--inDegrees[v - 'a'] == 0)\n          q.push(v);\n    }\n\n    return s.length() == graph.size() ? s : \"\";\n  }\n};"
      }
    },
    "270": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int closestValue(TreeNode root, double target) {\n        int ans = root.val;\n        double max = Double.MAX_VALUE;\n        while (root != null) {\n            double t = Math.abs(root.val - target);\n            if (t < max || (t == max && root.val < ans)) {\n                max = t;\n                ans = root.val;\n            }\n            if (root.val > target) {\n                root = root.left;\n            } else {\n                root = root.right;\n            }\n        }\n        return ans;\n    }\n}"
      }
    },
    "271": {
      "solution": {
        "design": ""
      }
    },
    "272": {
      "solution": {
        "two-pointers": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private List<Integer> ans;\n    private double target;\n    private int k;\n\n    public List<Integer> closestKValues(TreeNode root, double target, int k) {\n        ans = new LinkedList<>();\n        this.target = target;\n        this.k = k;\n        dfs(root);\n        return ans;\n    }\n\n    private void dfs(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        dfs(root.left);\n        if (ans.size() < k) {\n            ans.add(root.val);\n        } else {\n            if (Math.abs(root.val - target) >= Math.abs(ans.get(0) - target)) {\n                return;\n            }\n            ans.remove(0);\n            ans.add(root.val);\n        }\n        dfs(root.right);\n    }\n}"
      }
    },
    "273": {
      "solution": {
        "recursion": "class Solution {\npublic:\n    string numberToWords(int num) {\n        if (num == 0) return \"Zero\";\n\n        vector<string> scales = {\"\", \"Thousand\", \"Million\", \"Billion\"};\n        string result = \"\";\n\n        int scaleIndex = 0;\n        while (num > 0) {\n            if (num % 1000 != 0) {\n                result = helper(num % 1000) + (scales[scaleIndex].empty() ? \"\" : \" \" + scales[scaleIndex]) + \n                         (result.empty() ? \"\" : \" \" + result);\n            }\n            num /= 1000;\n            scaleIndex++;\n        }\n\n        return result;\n    }\n\nprivate:\n    vector<string> belowTwenty = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n                                  \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \n                                  \"Eighteen\", \"Nineteen\"};\n\n    vector<string> tens = {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\n\n    string helper(int num) {\n        if (num == 0) return \"\";\n\n        if (num < 20) {\n            return belowTwenty[num];\n        } else if (num < 100) {\n            return tens[num / 10] + (num % 10 == 0 ? \"\" : \" \" + belowTwenty[num % 10]);\n        } else {\n            return belowTwenty[num / 100] + \" Hundred\" + (num % 100 == 0 ? \",\" : \": \" + helper(num % 100));\n        }\n    }\n};\n"
      }
    },
    "274": {
      "solution": {
        "counting-sort": "class Solution {\n    public int hIndex(int[] citations) {\n        int n = citations.length;\n        int[] count = new int[n + 1];\n        \n        for (int c : citations) {\n            if (c >= n) {\n                count[n]++;\n            } else {\n                count[c]++;\n            }\n        }\n        \n        // Calculate the H-Index\n        int total = 0;\n        for (int i = n; i >= 0; i--) {\n            total += count[i];\n            if (total >= i) {\n                return i;\n            }\n        }\n        \n        return 0;\n    }\n}\n"
      }
    },
    "275": {
      "solution": {
        "array": ""
      }
    },
    "276": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "277": {
      "solution": {
        "two-pointers": "",
        "interactive": "/* The knows API is defined for you.\n      bool knows(int a, int b); */\n\nclass Solution {\npublic:\n    int findCelebrity(int n) {\n        int ans = 0;\n        for (int i = 1; i < n; ++i) {\n            if (knows(ans, i)) {\n                ans = i;\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (ans != i) {\n                if (knows(ans, i) || !knows(i, ans)) {\n                    return -1;\n                }\n            }\n        }\n        return ans;\n    }\n};"
      }
    },
    "278": {
      "solution": {
        "interactive": ""
      }
    },
    "279": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "280": {
      "solution": {
        "greedy": ""
      }
    },
    "281": {
      "solution": {
        "iterator": "public class ZigzagIterator {\n    private int curr;\n    private int size;\n    private List<Integer> indexes = new ArrayList<>();\n    private List<List<Integer>> vectors = new ArrayList<>();\n\n    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {\n        curr = 0;\n        size = 2;\n        indexes.add(0);\n        indexes.add(0);\n        vectors.add(v1);\n        vectors.add(v2);\n    }\n\n    public int next() {\n        List<Integer> vector = vectors.get(curr);\n        int index = indexes.get(curr);\n        int res = vector.get(index);\n        indexes.set(curr, index + 1);\n        curr = (curr + 1) % size;\n        return res;\n    }\n\n    public boolean hasNext() {\n        int start = curr;\n        while (indexes.get(curr) == vectors.get(curr).size()) {\n            curr = (curr + 1) % size;\n            if (start == curr) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n/**\n * Your ZigzagIterator object will be instantiated and called as such:\n * ZigzagIterator i = new ZigzagIterator(v1, v2);\n * while (i.hasNext()) v[dp()] = i.next();\n */"
      }
    },
    "282": {
      "solution": {
        "backtracking": ""
      }
    },
    "283": {
      "solution": {
        "two-pointers": "public class Solution {\n    public void moveZeroes(int[] nums) {\n        int slow = 0;\n\n        for (int fast = 0; fast < nums.length; fast++) {\n            if (nums[fast] != 0) {\n                int temp = nums[slow];\n                nums[slow] = nums[fast];\n                nums[fast] = temp;\n                slow++;\n            }\n        }\n    }\n}\n"
      }
    },
    "284": {
      "solution": {
        "iterator": "import java.util.*;\n\nclass PeekingIterator implements Iterator<Integer> {\n    private Iterator<Integer> iterator;\n    private Integer nextElement;\n    private boolean hasNext;\n\n    public PeekingIterator(Iterator<Integer> iterator) {\n        this.iterator = iterator;\n        if (iterator.hasNext()) {\n            nextElement = iterator.next();\n            hasNext = true;\n        } else {\n            hasNext = false;\n        }\n    }\n\n    public Integer peek() {\n        return nextElement;\n    }\n    \n    @Override\n    public Integer next() {\n        if (!hasNext) {\n            throw new NoSuchElementException();\n        }\n        Integer result = nextElement;\n        if (iterator.hasNext()) {\n            nextElement = iterator.next();\n        } else {\n            hasNext = false;\n        }\n        return result;\n    }\n    \n    @Override\n    public boolean hasNext() {\n        return hasNext;\n    }\n}\n"
      }
    },
    "285": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {\n        TreeNode ans = null;\n        while (root != null) {\n            if (root.val > p.val) {\n                ans = root;\n                root = root.left;\n            } else {\n                root = root.right;\n            }\n        }\n        return ans;\n    }\n}"
      }
    },
    "286": {
      "solution": {
        "breadth-first-search": "class Solution {\npublic:\n    void wallsAndGates(vector<vector<int>>& rooms) {\n        int m = rooms.size();\n        int n = rooms[0].size();\n        queue<pair<int, int>> q;\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                if (rooms[i][j] == 0)\n                    q.emplace(i, j);\n        int d = 0;\n        vector<int> dirs = {-1, 0, 1, 0, -1};\n        while (!q.empty()) {\n            ++d;\n            for (int i = q.size(); i > 0; --i) {\n                auto p = q.front();\n                q.pop();\n                for (int j = 0; j < 4; ++j) {\n                    int x = p.first + dirs[j];\n                    int y = p.second + dirs[j + 1];\n                    if (x >= 0 && x < m && y >= 0 && y < n && rooms[x][y] == INT_MAX) {\n                        rooms[x][y] = d;\n                        q.emplace(x, y);\n                    }\n                }\n            }\n        }\n    }\n};"
      }
    },
    "287": {
      "solution": {
        "two-pointers": "public class Solution {\n    public int findDuplicate(int[] nums) {\n        int slow = nums[0];\n        int fast = nums[nums[0]];\n        \n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        }\n        \n        fast = 0; \\\\slow = 0; \n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n        \n        return slow;\n    }\n}\n"
      }
    },
    "288": {
      "solution": {
        "design": ""
      }
    },
    "289": {
      "solution": {
        "matrix": "class Solution {\n    public void gameOfLife(int[][] board) {\n        int numRows = board.length;\n        int numCols = board[0].length;\n      \n        for (int row = 0; row < numRows; ++row) {\n            for (int col = 0; col < numCols; ++col) {\n                // Count live neighbors, initializing at -board[row][col] to offset self-counting if alive\n                int liveNeighbors = -board[row][col];\n                for (int i = row - 1; i <= row + 1; ++i) {\n                    for (int j = col - 1; j <= col + 1; ++j) {\n                        // Check if neighbor is within bounds and alive\n                        if (i >= 0 && i < numRows && j >= 0 && j < numCols && board[i][j] > 0) {\n                            liveNeighbors++;\n                        }\n                    }\n                }\n                            \n                // Rule 1 or Rule 3: Any live cell with fewer than two live neighbors\n                // or with more than three live neighbors dies (set to 2 for temporary state)\n                if (board[row][col] == 1 && (liveNeighbors < 2 || liveNeighbors > 3)) {\n                    board[row][col] = 2;\n                }\n              \n                // Rule 4: Any dead cell with exactly three live neighbors becomes a live cell\n                // (set to -1 for temporary state)\n                if (board[row][col] == 0 && liveNeighbors == 3) {\n                    board[row][col] = -1;\n                }\n            }\n        }\n      \n        for (int row = 0; row < numRows; ++row) {\n            for (int col = 0; col < numCols; ++col) {\n                // A value of 2 means the cell was previously alive and now is dead\n                if (board[row][col] == 2) {\n                    board[row][col] = 0;\n                }\n                // A value of -1 means the cell was previously dead and now is alive\n                else if (board[row][col] == -1) {\n                    board[row][col] = 1;\n                }\n            }\n        }\n    }\n}"
      }
    },
    "290": {
      "solution": {
        "hash-table": ""
      }
    },
    "291": {
      "solution": {
        "backtracking": ""
      }
    },
    "292": {
      "solution": {
        "brainteaser": "class Solution {\n    public boolean canWinNim(int n) {\n        return n % 4 != 0;\n    }\n}\n"
      }
    },
    "293": {
      "solution": {
        "string": ""
      }
    },
    "294": {
      "solution": {
        "breadth-first-search": "using ll = long long;\n\nclass Solution {\npublic:\n    int n;\n    unordered_map<ll, bool> memo;\n\n    bool canWin(string currentState) {\n        n = currentState.size();\n        ll mask = 0;\n        for (int i = 0; i < n; ++i)\n            if (currentState[i] == '+') mask |= 1ll << i;\n        return dfs(mask);\n    }\n\n    bool dfs(ll mask) {\n        if (memo.count(mask)) return memo[mask];\n        for (int i = 0; i < n - 1; ++i) {\n            if ((mask & (1ll << i)) == 0 || (mask & (1ll << (i + 1))) == 0) continue;\n            if (dfs(mask ^ (1ll << i) ^ (1ll << (i + 1)))) continue;\n            memo[mask] = true;\n            return true;\n        }\n        memo[mask] = false;\n        return false;\n    }\n};"
      }
    },
    "295": {
      "solution": {
        "two-pointers": "",
        "ordered-set": "import java.util.Collections;\nimport java.util.PriorityQueue;\n\nclass MedianFinder {\n    private PriorityQueue<Integer> maxHeap; // To store the smaller half of the numbers\n    private PriorityQueue<Integer> minHeap; // To store the larger half of the numbers\n\n    public MedianFinder() {\n        maxHeap = new PriorityQueue<>(Collections.reverseOrder()); // Max-heap for the left side\n        minHeap = new PriorityQueue<>(); // Min-heap for the right side\n    }\n\n    public void addNum(int num) {\n        if (maxHeap.isEmpty() || num <= maxHeap.peek()) {\n            maxHeap.offer(num);\n        } else {\n            minHeap.offer(num);\n        }\n\n        if (maxHeap.size() < minHeap.size()) {\n            maxHeap.offer(minHeap.poll());\n        } else if (maxHeap.size() - minHeap.size() > 1) {\n            minHeap.offer(maxHeap.poll());\n        }\n    }\n\n    public double findMedian() {\n        if (maxHeap.size() == minHeap.size()) {\n            return (double) (maxHeap.peek() + minHeap.peek()) / 2.0;\n        }\n        return (double) maxHeap.peek();\n    }\n}\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder obj = new MedianFinder();\n * obj.addNum(num);\n * double param_2 = obj.findMedian();\n */\n"
      }
    },
    "296": {
      "solution": {
        "matrix": "class Solution {\n  public int minTotalDistance(int[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    List<Integer> rows = new ArrayList<>(); // i indices s.t. grid[i][j] == 1\n    List<Integer> cols = new ArrayList<>(); // j indices s.t. grid[i][j] == 1\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 1)\n          rows.add(i);\n\n    for (int j = 0; j < n; ++j)\n      for (int i = 0; i < m; ++i)\n        if (grid[i][j] == 1)\n          cols.add(j);\n\n    // sum(i - median(rows)) + sum(j - median(cols))\n    return minTotalDistance(rows) + minTotalDistance(cols);\n  }\n\n  private int minTotalDistance(List<Integer> grid) {\n    int sum = 0;\n    int i = 0;\n    int j = grid.size() - 1;\n    while (i < j)\n      sum += grid.get(j--) - grid.get(i++);\n    return sum;\n  }\n}"
      }
    },
    "297": {
      "solution": {
        "tree": ""
      }
    },
    "298": {
      "solution": {
        "tree": ""
      }
    },
    "299": {
      "solution": {
        "counting": "class Solution {\npublic:\n    string getHint(string secret, string guess) {\n        int A = 0;\n        int B = 0;\n        vector<int> count1(10);\n        vector<int> count2(10);\n\n        for (int i = 0; i < secret.length(); ++i)\n            if (secret[i] == guess[i])\n                ++A;\n            else {\n                ++count1[secret[i] - '0'];\n                ++count2[guess[i] - '0'];\n            }\n\n        for (int i = 0; i < 10; ++i)\n            B += min(count1[i], count2[i]);\n\n        return to_string(A) + \"A\" + to_string(B) + \"B\";\n    }\n};"
      }
    },
    "300": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "301": {
      "solution": {
        "backtracking": ""
      }
    },
    "302": {
      "solution": {
        "matrix": ""
      }
    },
    "303": {
      "solution": {
        "prefix-sum": "class NumArray {\n    private int[] prefixSum;\n\n    public NumArray(int[] nums) {\n        int n = nums.length;\n        prefixSum = new int[n + 1]; // One extra space for convenience\n        prefixSum[0] = 0; // Base case: sum of no elements is 0\n\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n    }\n\n    // Query: Compute the sum of the range [left, right]\n    public int sumRange(int left, int right) {\n        return prefixSum[right + 1] - prefixSum[left];\n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * int param_1 = obj.sumRange(left,right);\n */"
      }
    },
    "304": {
      "solution": {
        "matrix": "class NumMatrix {\n  public NumMatrix(int[][] matrix) {\n    if (matrix.length == 0)\n      return;\n\n    int m = matrix.length;\n    int n = matrix[0].length;\n\n    // prefix[i][j] := sum of matrix[0..i)[0..j)\n    prefix = new int[m + 1][n + 1];\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        prefix[i + 1][j + 1] = matrix[i][j] + prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j];\n  }\n\n  public int sumRegion(int row1, int col1, int row2, int col2) {\n    return prefix[row2 + 1][col2 + 1] - prefix[row1][col2 + 1]\n         - prefix[row2 + 1][col1] + prefix[row1][col1];\n  }\n\n  private int[][] prefix;\n}\n"
      }
    },
    "305": {
      "solution": {
        "union-find": ""
      }
    },
    "306": {
      "solution": {
        "backtracking": ""
      }
    },
    "307": {
      "solution": {
        "design": "",
        "segment-tree": "#include <vector>\nusing namespace std;\n\nclass NumArray {\nprivate:\n    vector<int> segTree;\n    int n;\n\n    void buildTree(vector<int>& nums, int start, int end, int node) {\n        if (start == end) {\n            segTree[node] = nums[start];\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        buildTree(nums, start, mid, 2 * node + 1);\n        buildTree(nums, mid + 1, end, 2 * node + 2);\n        segTree[node] = segTree[2 * node + 1] + segTree[2 * node + 2];\n    }\n\n    void updateTree(int start, int end, int index, int val, int node) {\n        if (start == end) {\n            segTree[node] = val;\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        if (index <= mid) {\n            updateTree(start, mid, index, val, 2 * node + 1);\n        } else {\n            updateTree(mid + 1, end, index, val, 2 * node + 2);\n        }\n        segTree[node] = segTree[2 * node + 1] + segTree[2 * node + 2];\n    }\n\n    // Helper function to query the sum in a range\n    int queryTree(int start, int end, int left, int right, int node) {\n        if (left > end || right < start) {\n            return 0; // Out of range\n        }\n        if (left <= start && end <= right) {\n            return segTree[node]; // Fully within range\n        }\n        int mid = start + (end - start) / 2;\n        return queryTree(start, mid, left, right, 2 * node + 1) +\n               queryTree(mid + 1, end, left, right, 2 * node + 2);\n    }\n\npublic:\n    NumArray(vector<int>& nums) {\n        n = nums.size();\n        segTree.resize(4 * n, 0);\n        buildTree(nums, 0, n - 1, 0);\n    }\n    \n    void update(int index, int val) {\n        updateTree(0, n - 1, index, val, 0);\n    }\n    \n    int sumRange(int left, int right) {\n        return queryTree(0, n - 1, left, right, 0);\n    }\n};\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj = new NumArray(nums);\n * obj->update(index,val);\n * int param_2 = obj->sumRange(left,right);\n */\n"
      }
    },
    "308": {
      "solution": {
        "binary-indexed-tree": "class FenwickTree {\n public:\n  FenwickTree(int m, int n) : sums(m + 1, vector<int>(n + 1)) {}\n\n  void add(int row, int col, int delta) {\n    for (int i = row; i < sums.size(); i += lowbit(i))\n      for (int j = col; j < sums[0].size(); j += lowbit(j))\n        sums[i][j] += delta;\n  }\n\n  int get(int row, int col) {\n    int sum = 0;\n    for (int i = row; i > 0; i -= lowbit(i))\n      for (int j = col; j > 0; j -= lowbit(j))\n        sum += sums[i][j];\n    return sum;\n  }\n\n private:\n  vector<vector<int>> sums;\n\n  static inline int lowbit(int i) {\n    return i & -i;\n  }\n};\n\nclass NumMatrix {\n public:\n  NumMatrix(vector<vector<int>>& matrix)\n      : matrix(matrix), tree(matrix.size(), matrix[0].size()) {\n    for (int i = 0; i < matrix.size(); ++i)\n      for (int j = 0; j < matrix[0].size(); ++j)\n        tree.add(i + 1, j + 1, matrix[i][j]);\n  }\n\n  void update(int row, int col, int val) {\n    tree.add(row + 1, col + 1, val - matrix[row][col]);\n    matrix[row][col] = val;\n  }\n\n  int sumRegion(int row1, int col1, int row2, int col2) {\n    return tree.get(row2 + 1, col2 + 1) - tree.get(row1, col2 + 1) -\n           tree.get(row2 + 1, col1) + tree.get(row1, col1);\n  }\n\n private:\n  vector<vector<int>> matrix;\n  FenwickTree tree;\n};"
      }
    },
    "309": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "310": {
      "solution": {
        "topological-sort": ""
      }
    },
    "311": {
      "solution": {
        "matrix": "class Solution {\n  public int[][] multiply(int[][] mat1, int[][] mat2) {\n    int m = mat1.length;\n    int n = mat2.length;\n    int l = mat2[0].length;\n    int[][] ans = new int[m][l];\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < l; ++j)\n        for (int k = 0; k < n; ++k)\n          ans[i][j] += mat1[i][k] * mat2[k][j];\n\n    return ans;\n  }\n}"
      }
    },
    "312": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "313": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "314": {
      "solution": {
        "tree": ""
      }
    },
    "315": {
      "solution": {
        "merge-sort": "class Solution {\n    public List<Integer> countSmaller(int[] nums) {\n        int n = nums.length;\n        int[] countSmaller = new int[n];\n        int[] indices = new int[n];\n        for (int i = 0; i < n; i++) {\n            indices[i] = i;\n        }\n        mergeSort(nums, indices, countSmaller, 0, n - 1);\n        List<Integer> result = new ArrayList<>();\n        for (int count : countSmaller) {\n            result.add(count);\n        }\n        return result;\n    }\n    \n    private void mergeSort(int[] nums, int[] indices, int[] countSmaller, int start, int end) {\n        if (start >= end) {\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        mergeSort(nums, indices, countSmaller, start, mid);\n        mergeSort(nums, indices, countSmaller, mid + 1, end);\n        merge(nums, indices, countSmaller, start, mid, end);\n    }\n    \n    private void merge(int[] nums, int[] indices, int[] countSmaller, int start, int mid, int end) {\n        int leftIndex = start;\n        int rightIndex = mid + 1;\n        int rightCount = 0;\n        int[] newIndices = new int[end - start + 1];\n        int newIndex = 0;\n        \n        while (leftIndex <= mid && rightIndex <= end) {\n            if (nums[indices[rightIndex]] < nums[indices[leftIndex]]) {\n                newIndices[newIndex] = indices[rightIndex];\n                rightCount++;\n                rightIndex++;\n            } else {\n                newIndices[newIndex] = indices[leftIndex];\n                countSmaller[indices[leftIndex]] += rightCount;\n                leftIndex++;\n            }\n            newIndex++;\n        }\n        \n        while (leftIndex <= mid) {\n            newIndices[newIndex] = indices[leftIndex];\n            countSmaller[indices[leftIndex]] += rightCount;\n            leftIndex++;\n            newIndex++;\n        }\n        \n        while (rightIndex <= end) {\n            newIndices[newIndex] = indices[rightIndex];\n            rightIndex++;\n            newIndex++;\n        }\n        \n        System.arraycopy(newIndices, 0, indices, start, end - start + 1);\n    }\n}\n",
        "segment-tree": "class SegmentTree {\npublic:\n    explicit SegmentTree(const vector<int>& nums)\n        : n(nums.size()), tree(n * 4) {\n        build(nums, 0, 0, n - 1);\n    }\n\n    // Adds val to nums[i].\n    void add(int i, int val) { add(0, 0, n - 1, i, val); }\n\n    // Returns sum(nums[i..j]).\n    int query(int i, int j) const { return query(0, 0, n - 1, i, j); }\n\nprivate:\n    const int n;      // the size of the input array\n    vector<int> tree; // the segment tree\n\n    void build(const vector<int>& nums, int treeIndex, int lo, int hi) {\n        if (lo == hi) {\n            tree[treeIndex] = nums[lo];\n            return;\n        }\n        const int mid = (lo + hi) / 2;\n        build(nums, 2 * treeIndex + 1, lo, mid);\n        build(nums, 2 * treeIndex + 2, mid + 1, hi);\n        tree[treeIndex] =\n            merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n    }\n\n    void add(int treeIndex, int lo, int hi, int i, int val) {\n        if (lo == hi) {\n            tree[treeIndex] += val;\n            return;\n        }\n        const int mid = (lo + hi) / 2;\n        if (i <= mid)\n            add(2 * treeIndex + 1, lo, mid, i, val);\n        else\n            add(2 * treeIndex + 2, mid + 1, hi, i, val);\n        tree[treeIndex] =\n            merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\n    }\n\n    int query(int treeIndex, int lo, int hi, int i, int j) const {\n        if (i <= lo && hi <= j) // [lo, hi] lies completely inside [i, j].\n            return tree[treeIndex];\n        if (j < lo || hi < i) // [lo, hi] lies completely outside [i, j].\n            return 0;\n        const int mid = (lo + hi) / 2;\n        return merge(query(treeIndex * 2 + 1, lo, mid, i, j),\n                     query(treeIndex * 2 + 2, mid + 1, hi, i, j));\n    }\n\n    int merge(int left, int right) const { return left + right; }\n};\n\nclass Solution {\npublic:\n    vector<int> countSmaller(vector<int>& nums) {\n        vector<int> ans(nums.size());\n        unordered_map<int, int> ranks;\n        getRanks(nums, ranks);\n        SegmentTree tree(vector<int>(ranks.size() + 1));\n\n        for (int i = nums.size() - 1; i >= 0; --i) {\n            const int num = nums[i];\n            ans[i] = tree.query(0, ranks[num] - 1);\n            tree.add(ranks[num], 1);\n        }\n\n        return ans;\n    }\n\nprivate:\n    void getRanks(const vector<int>& nums, unordered_map<int, int>& ranks) {\n        set<int> sorted(nums.begin(), nums.end());\n        int rank = 0;\n        for (const int num : sorted)\n            ranks[num] = ++rank;\n    }\n};"
      }
    },
    "316": {
      "solution": {
        "monotonic-stack": "import java.util.Stack;\n\nclass Solution {\n    public String removeDuplicateLetters(String s) {\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n\n        boolean[] visited = new boolean[26];\n        Stack<Character> stack = new Stack<>();\n\n        for (char c : s.toCharArray()) {\n            count[c - 'a']--;\n\n            if (visited[c - 'a']) {\n                continue;\n            }\n\n            while (!stack.isEmpty() && stack.peek() > c\n                    && count[stack.peek() - 'a'] > 0) {\n                visited[stack.pop() - 'a'] = false;\n            }\n\n            stack.push(c);\n            visited[c - 'a'] = true;\n        }\n\n        StringBuilder result = new StringBuilder();\n        while (!stack.isEmpty()) {\n            result.insert(0, stack.pop());\n        }\n\n        return result.toString();\n    }\n}\n"
      }
    },
    "317": {
      "solution": {
        "matrix": ""
      }
    },
    "318": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "319": {
      "solution": {
        "brainteaser": "class Solution {\n    public int bulbSwitch(int n) {\n        return (int) Math.sqrt(n);\n    }\n}\n"
      }
    },
    "320": {
      "solution": {
        "backtracking": ""
      }
    },
    "321": {
      "solution": {
        "two-pointers": "class Solution {\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\n        int n = nums1.length;\n        int m = nums2.length;\n        int[] maxNum = new int[k];\n        \n        for (int i = Math.max(0, k - m); i <= k && i <= n; ++i) {\n            int[] candidate = merge(maxSubsequence(nums1, i), maxSubsequence(nums2, k - i), k);\n            if (greater(candidate, 0, maxNum, 0)) {\n                maxNum = candidate;\n            }\n        }\n        \n        return maxNum;\n    }\n    \n    private int[] maxSubsequence(int[] nums, int k) {\n        int n = nums.length;\n        int[] stack = new int[k];\n        int top = -1;\n        int remain = n - k; // number of elements to remove\n        for (int num : nums) {\n            while (top >= 0 && stack[top] < num && remain > 0) {\n                top--;\n                remain--;\n            }\n            if (top < k - 1) {\n                stack[++top] = num;\n            } else {\n                remain--; // skip num since top == k - 1\n            }\n        }\n        return stack;\n    }\n    \n    private int[] merge(int[] nums1, int[] nums2, int k) {\n        int[] result = new int[k];\n        int i = 0, j = 0;\n        for (int r = 0; r < k; r++) {\n            if (greater(nums1, i, nums2, j)) {\n                result[r] = nums1[i++];\n            } else {\n                result[r] = nums2[j++];\n            }\n        }\n        return result;\n    }\n    \n    private boolean greater(int[] nums1, int i, int[] nums2, int j) {\n        while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {\n            i++;\n            j++;\n        }\n        return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);\n    }\n}\n"
      }
    },
    "322": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "323": {
      "solution": {
        "union-find": "class Solution {\n    private int[] parent;\n\n    public int countComponents(int n, int[][] edges) {\n        parent = new int[n];\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n        for (int[] e : edges) {\n            int a = e[0], b = e[1];\n            parent[find(a)] = find(b);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i == find(i)) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n\n    private int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n}\n"
      }
    },
    "324": {
      "solution": {
        "quickselect": "import java.util.Arrays;\n\npublic class Solution {\n    public void wiggleSort(int[] nums) {\n        int n = nums.length;\n        \n        int median = quickselect(nums, 0, n - 1, n / 2);\n        \n        // Three-way partitioning: Elements less than median go to the left,\n        // Elements equal to median go to the middle, Elements greater than median go to the right\n        int left = 0, right = n - 1, i = 0;\n        while (i <= right) {\n            if (nums[newIndex(i, n)] > median) {\n                swap(nums, newIndex(left++, n), newIndex(i++, n));\n            } else if (nums[newIndex(i, n)] < median) {\n                swap(nums, newIndex(right--, n), newIndex(i, n));\n            } else {\n                i++;\n            }\n        }\n    }\n    \n    // Quickselect to find the k-th smallest element\n    private int quickselect(int[] nums, int left, int right, int k) {\n        while (left < right) {\n            int pivot = partition(nums, left, right);\n            if (pivot == k) {\n                return nums[k];\n            } else if (pivot < k) {\n                left = pivot + 1;\n            } else {\n                right = pivot - 1;\n            }\n        }\n        return nums[left];\n    }\n    \n    private int partition(int[] nums, int left, int right) {\n        int pivot = nums[right];\n        int i = left;\n        for (int j = left; j < right; j++) {\n            if (nums[j] < pivot) {\n                swap(nums, i++, j);\n            }\n        }\n        swap(nums, i, right);\n        return i;\n    }\n    \n    private int newIndex(int index, int n) {\n        return (1 + 2 * index) % (n | 1);\n    }\n    \n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n"
      }
    },
    "325": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "326": {
      "solution": {
        "recursion": ""
      }
    },
    "327": {
      "solution": {
        "merge-sort": "class Solution {\n    public int countRangeSum(int[] nums, int lower, int upper) {\n        long[] prefixSum = new long[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n        return mergeSortAndCount(prefixSum, 0, prefixSum.length - 1, lower, upper);\n    }\n    \n    private int mergeSortAndCount(long[] prefixSum, int left, int right, int lower, int upper) {\n        if (left >= right) return 0;\n        \n        int mid = left + (right - left) / 2;\n        int count = 0;\n        \n        count += mergeSortAndCount(prefixSum, left, mid, lower, upper);\n        count += mergeSortAndCount(prefixSum, mid + 1, right, lower, upper);\n        count += mergeAndCount(prefixSum, left, mid, right, lower, upper);\n        \n        return count;\n    }\n    \n    private int mergeAndCount(long[] prefixSum, int left, int mid, int right, int lower, int upper) {\n        int count = 0;\n        int i = left;\n        int j = mid + 1;\n        int k = mid + 1;\n        \n        while (i <= mid) {\n            while (j <= right && prefixSum[j] - prefixSum[i] < lower) j++;\n            while (k <= right && prefixSum[k] - prefixSum[i] <= upper) k++;\n            count += (k - j);\n            i++;\n        }\n        \n        long[] sorted = new long[right - left + 1];\n        int p1 = left, p2 = mid + 1, p = 0;\n        while (p1 <= mid || p2 <= right) {\n            if (p2 > right || (p1 <= mid && prefixSum[p1] <= prefixSum[p2])) {\n                sorted[p++] = prefixSum[p1++];\n            } else {\n                sorted[p++] = prefixSum[p2++];\n            }\n        }\n        \n        System.arraycopy(sorted, 0, prefixSum, left, sorted.length);\n        \n        return count;\n    }\n}\n",
        "binary-indexed-tree": "import java.util.*;\n\npublic class Solution {\n    public int countRangeSum(int[] nums, int lower, int upper) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n\n        int n = nums.length;\n        long[] prefixSums = new long[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefixSums[i + 1] = prefixSums[i] + nums[i];\n        }\n\n        // Create a sorted list of all possible prefix sums.\n        Set<Long> allSums = new TreeSet<>();\n        for (long sum : prefixSums) {\n            allSums.add(sum);\n            allSums.add(sum - lower);\n            allSums.add(sum - upper);\n        }\n\n        // Map each prefix sum to an index for use in the Fenwick Tree.\n        Map<Long, Integer> sumToIndex = new HashMap<>();\n        int index = 0;\n        for (long sum : allSums) {\n            sumToIndex.put(sum, index++);\n        }\n\n        FenwickTree fenwickTree = new FenwickTree(sumToIndex.size());\n        int count = 0;\n        for (long sum : prefixSums) {\n            int left = sumToIndex.get(sum - upper);\n            int right = sumToIndex.get(sum - lower);\n            count += fenwickTree.query(right) - fenwickTree.query(left - 1);\n            fenwickTree.update(sumToIndex.get(sum), 1);\n        }\n\n        return count;\n    }\n\n    class FenwickTree {\n        private int[] tree;\n        \n        public FenwickTree(int size) {\n            tree = new int[size + 1];\n        }\n        \n        public void update(int index, int delta) {\n            index++;\n            while (index < tree.length) {\n                tree[index] += delta;\n                index += index & -index;\n            }\n        }\n        \n        public int query(int index) {\n            index++;\n            int sum = 0;\n            while (index > 0) {\n                sum += tree[index];\n                index -= index & -index;\n            }\n            return sum;\n        }\n    }\n}\n"
      }
    },
    "328": {
      "solution": {
        "linked-list": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* oddEvenList(ListNode* head) {\n        if (!head || !head->next)\n            return head;\n\n        ListNode* odd = head;\n        ListNode* even = head->next;\n        ListNode* evenHead = even;\n\n        while (even && even->next) {\n            odd->next = even->next;\n            odd = odd->next;\n            even->next = odd->next;\n            even = even->next;\n        }\n\n        odd->next = evenHead;\n        return head;\n    }\n};\n"
      }
    },
    "329": {
      "solution": {
        "matrix": "class Solution {\n    private int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    private int[][] memo;\n    private int m, n;\n\n    public int longestIncreasingPath(int[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return 0;\n        }\n\n        m = matrix.length;\n        n = matrix[0].length;\n        memo = new int[m][n];\n        int maxPath = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                maxPath = Math.max(maxPath, dfs(matrix, i, j));\n            }\n        }\n\n        return maxPath;\n    }\n\n    private int dfs(int[][] matrix, int i, int j) {\n        if (memo[i][j] != 0) {\n            return memo[i][j];\n        }\n\n        int maxLength = 1; \n        for (int[] direction : directions) {\n            int x = i + direction[0];\n            int y = j + direction[1];\n\n            if (x >= 0 && x < m && y >= 0 && y < n && matrix[x][y] > matrix[i][j]) {\n                maxLength = Math.max(maxLength, 1 + dfs(matrix, x, y));\n            }\n        }\n\n        memo[i][j] = maxLength;\n        return maxLength;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] matrix = {\n            {9, 9, 4},\n            {6, 6, 8},\n            {2, 1, 1}\n        };\n\n        int result = solution.longestIncreasingPath(matrix);\n        System.out.println(\"Longest Increasing Path: \" + result); // Output: 4\n    }\n}\n"
      }
    },
    "330": {
      "solution": {
        "greedy": ""
      }
    },
    "331": {
      "solution": {
        "stack": ""
      }
    },
    "332": {
      "solution": {
        "eulerian-circuit": "import java.util.*;\n\npublic class Solution {\n\n    public List<String> findItinerary(List<List<String>> tickets) {\n              Map<String, PriorityQueue<String>> graph = new HashMap<>();\n              for (List<String> ticket : tickets) {\n                  graph.computeIfAbsent(ticket.get(0), k -> new PriorityQueue<>()).add(ticket.get(1));\n              }\n      \n              LinkedList<String> itinerary = new LinkedList<>();\n              // dfs('JFK', graph, itinerary); or else use stack\n      \n              Stack<String> stack = new Stack<>();\n              stack.push('JFK');\n      \n              while (!stack.isEmpty()) {\n                  String currentAirport = stack.peek();\n                  PriorityQueue<String> nextAirports = graph.get(currentAirport);\n      \n                  // If the current airport has any destinations left to visit\n                  if (nextAirports != null && !nextAirports.isEmpty()) {\n                      stack.push(nextAirports.poll());\n                  } else {\n                      // If no destinations left, add to itinerary and backtrack\n                      itinerary.addFirst(stack.pop());\n                  }\n              }\n      \n              return itinerary;\n          }\n\n    private void dfs(String airport, Map<String, PriorityQueue<String>> graph, LinkedList<String> itinerary) {\n        PriorityQueue<String> nextAirports = graph.get(airport);\n        while (nextAirports != null && !nextAirports.isEmpty()) {\n            dfs(nextAirports.poll(), graph, itinerary);\n        }\n        itinerary.addFirst(airport);\n    }\n\n    public static void main(String[] args) {\n              Solution solution = new Solution();\n              List<List<String>> tickets = Arrays.asList(\n                      Arrays.asList('MUC', 'LHR'),\n                      Arrays.asList('JFK', 'MUC'),\n                      Arrays.asList('SFO', 'SJC'),\n                      Arrays.asList('LHR', 'SFO'));\n              List<String> itinerary = solution.findItinerary(tickets);\n              System.out.println(itinerary); // Output: [JFK, MUC, LHR, SFO, SJC]\n          }\n}\n"
      }
    },
    "333": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int ans;\n\n    public int largestBSTSubtree(TreeNode root) {\n        ans = 0;\n        dfs(root);\n        return ans;\n    }\n\n    private int[] dfs(TreeNode root) {\n        if (root == null) {\n            return new int[] {Integer.MAX_VALUE, Integer.MIN_VALUE, 0};\n        }\n        int[] left = dfs(root.left);\n        int[] right = dfs(root.right);\n        if (left[1] < root.val && root.val < right[0]) {\n            ans = Math.max(ans, left[2] + right[2] + 1);\n            return new int[] {\n                Math.min(root.val, left[0]), Math.max(root.val, right[1]), left[2] + right[2] + 1};\n        }\n        return new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 0};\n    }\n}"
      }
    },
    "334": {
      "solution": {
        "greedy": ""
      }
    },
    "335": {
      "solution": {
        "geometry": ""
      }
    },
    "336": {
      "solution": {
        "trie": ""
      }
    },
    "337": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "338": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "339": {
      "solution": {
        "breadth-first-search": ""
      }
    },
    "340": {
      "solution": {
        "sliding-window": "import java.util.HashMap;\n\npublic class Solution {\n    public int lengthOfLongestSubstringKDistinct(String s, int k) {\n        if (s == null || s.length() == 0 || k == 0) {\n            return 0;\n        }\n        \n        HashMap<Character, Integer> map = new HashMap<>();\n        int left = 0;\n        int maxLength = 0;\n        \n        for (int right = 0; right < s.length(); right++) {\n            char rightChar = s.charAt(right);\n            map.put(rightChar, map.getOrDefault(rightChar, 0) + 1);\n            \n            while (map.size() > k) {\n                char leftChar = s.charAt(left);\n                map.put(leftChar, map.get(leftChar) - 1);\n                if (map.get(leftChar) == 0) {\n                    map.remove(leftChar);\n                }\n                left++;\n            }\n            \n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n        \n        return maxLength;\n    }\n}\n"
      }
    },
    "341": {
      "solution": {
        "iterator": "public class NestedIterator implements Iterator<Integer> {\n    private Stack<NestedInteger> stack = new Stack<>();\n\n    public NestedIterator(List<NestedInteger> nestedList) {\n        addInteger(nestedList);\n    }\n\n    @Override\n    public Integer next() {\n        return stack.pop().getInteger();\n    }\n\n    @Override\n    public boolean hasNext() {\n        while (!stack.isEmpty() && !stack.peek().isInteger()) {\n          NestedInteger ni = stack.pop();\n            addInteger(ni.getList());\n        }\n        return !stack.isEmpty();\n    }\n\n    private void addInteger(final List<NestedInteger> nestedList) {\n        for (int i = nestedList.size() - 1; i >= 0; --i)\n            stack.push(nestedList.get(i));\n    }\n}\n"
      }
    },
    "342": {
      "solution": {
        "recursion": ""
      }
    },
    "343": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "344": {
      "solution": {
        "two-pointers": "public class Solution {\n    public void reverseString(char[] s) {\n        int left = 0;\n        int right = s.length - 1;\n        \n        while (left < right) {\n            char temp = s[left];\n            s[left] = s[right];\n            s[right] = temp;            \n            left++;\n            right--;\n        }\n    }\n}\n"
      }
    },
    "345": {
      "solution": {
        "two-pointers": "import java.util.HashSet;\n\npublic class Solution {\n    public String reverseVowels(String s) {\n        char[] chars = s.toCharArray();\n        HashSet<Character> vowels = new HashSet<>();\n        vowels.addAll(Set.of('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n\n        int left = 0, right = chars.length - 1;\n        while (left < right) {\n            while (left < right && !vowels.contains(chars[left])) {\n                left++;\n            }\n            while (left < right && !vowels.contains(chars[right])) {\n                right--;\n            }\n            if (left < right) {\n                char temp = chars[left];\n                chars[left] = chars[right];\n                chars[right] = temp;\n                left++;\n                right--;\n            }\n        }\n\n        return new String(chars);\n    }\n}\n"
      }
    },
    "346": {
      "solution": {
        "queue": ""
      }
    },
    "347": {
      "solution": {
        "bucket-sort": "import java.util.*;\n\npublic class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : nums) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        List<Integer>[] buckets = new List[nums.length + 1];\n        for (int key : frequencyMap.keySet()) {\n            int frequency = frequencyMap.get(key);\n            if (buckets[frequency] == null) {\n                buckets[frequency] = new ArrayList<>();\n            }\n            buckets[frequency].add(key);\n        }\n\n        // Step 3: Collect the top k frequent elements\n        List<Integer> result = new ArrayList<>();\n        for (int i = buckets.length - 1; i >= 0 && result.size() < k; i--) {\n            if (buckets[i] != null) {\n                result.addAll(buckets[i]);\n            }\n        }\n\n        int[] topK = new int[k];\n        for (int i = 0; i < k; i++) {\n            topK[i] = result.get(i);\n        }\n        \n        return topK;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums1 = {1, 1, 1, 2, 2, 3};\n        int k1 = 2;\n        System.out.println(Arrays.toString(solution.topKFrequent(nums1, k1))); // Output: [1, 2]\n\n        int[] nums2 = {1};\n        int k2 = 1;\n        System.out.println(Arrays.toString(solution.topKFrequent(nums2, k2))); // Output: [1]\n    }\n}\n",
        "quickselect": "import java.util.*;\n\npublic class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : nums) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        List<Integer> uniqueNums = new ArrayList<>(frequencyMap.keySet());\n        int[] result = new int[k];\n        int left = 0, right = uniqueNums.size() - 1;\n        \n        while (left <= right) {\n            int pivotIndex = partition(uniqueNums, frequencyMap, left, right);\n            if (pivotIndex == k - 1) {\n                for (int i = 0; i < k; i++) {\n                    result[i] = uniqueNums.get(i);\n                }\n                break;\n            } else if (pivotIndex < k - 1) {\n                left = pivotIndex + 1;\n            } else {\n                right = pivotIndex - 1;\n            }\n        }\n        \n        return result;\n    }\n    \n    private int partition(List<Integer> nums, Map<Integer, Integer> frequencyMap, int left, int right) {\n        int pivotFreq = frequencyMap.get(nums.get(right));\n        int i = left;\n        for (int j = left; j < right; j++) {\n            if (frequencyMap.get(nums.get(j)) >= pivotFreq) {\n                Collections.swap(nums, i, j);\n                i++;\n            }\n        }\n        Collections.swap(nums, i, right);\n        return i;\n    }\n}\n",
        "heap-(priority-queue)": "import java.util.*;\n\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : nums) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        PriorityQueue<Map.Entry<Integer, Integer>> heap = new PriorityQueue<>(\n            (a, b) -> a.getValue() - b.getValue()\n        );\n        \n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            heap.offer(entry);\n            if (heap.size() > k) {\n                heap.poll();\n            }\n        }\n        \n        int[] result = new int[k];\n        for (int i = k - 1; i >= 0; i--) {\n            result[i] = heap.poll().getKey();\n        }\n        \n        return result;\n    }\n}\n"
      }
    },
    "348": {
      "solution": {
        "matrix": "",
        "simulation": "class TicTacToe {\nprivate:\n    vector<vector<int>> board;\n    int n;\n    int status(int row, int col) {\n        int p = board[row][col];\n        bool win = true;\n        for (int i = 0; i < n && win; ++i) {\n            if (board[row][i] != p) win = false;\n        }\n        if (win) return p;\n        win = true;\n        for (int i = 0; i < n && win; ++i) {\n            if (board[i][col] != p) win = false;\n        }\n        if (win) return p;\n        if (row == col) {\n            win = true;\n            for (int i = 0; i < n && win; ++i) {\n                if (board[i][i] != p) win = false;\n            }\n            if (win) return p;\n        }\n        if (row + col == n - 1) {\n            win = true;\n            for (int i = 0; i < n && win; ++i) {\n                if (board[i][n - 1 - i] != p) win = false;\n            }\n            if (win) return p;\n        }\n        return 0;\n    }\npublic:\n    TicTacToe(int n) : n(n) {\n        board = vector<vector<int>>(n, vector<int>(n));\n    }\n    int move(int row, int col, int player) {\n        board[row][col] = player;\n        return status(row, col);\n    }\n};"
      }
    },
    "349": {
      "solution": {
        "two-pointers": "import java.util.*;\n\npublic class Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        Set<Integer> set = new HashSet<>();\n        Set<Integer> intersect = new HashSet<>();\n        \n        for (int num : nums1) {\n            set.add(num);\n        }\n        \n        for (int num : nums2) {\n            if (set.contains(num)) {\n                intersect.add(num);\n            }\n        }\n        \n        int[] result = new int[intersect.size()];\n        int index = 0;\n        for (int num : intersect) {\n            result[index++] = num;\n        }\n        \n        return result;\n    }\n}\n"
      }
    },
    "350": {
      "solution": {
        "two-pointers": "import java.util.*;\n\npublic class Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums1) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n\n        List<Integer> intersect = new ArrayList<>();\n\n        for (int num : nums2) {\n            if (map.containsKey(num) && map.get(num) > 0) {\n                intersect.add(num);\n                map.put(num, map.get(num) - 1);\n            }\n        }\n\n        int[] result = new int[intersect.size()];\n        int index = 0;\n        for (int num : intersect) {\n            result[index++] = num;\n        }\n\n        return result;\n    }\n}\n"
      }
    },
    "351": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "352": {
      "solution": {
        "ordered-set": ""
      }
    },
    "353": {
      "solution": {
        "simulation": "class SnakeGame {\npublic:\n    /** Initialize your data structure here.\n        @param width - screen width\n        @param height - screen height\n        @param food - A list of food positions\n        E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0]. */\n    SnakeGame(int width, int height, vector<pair<int, int>> food) {\n        this->width = width;\n        this->height = height;\n        this->food = food;\n        score = 0;\n        snake.push_back({0, 0});\n    }\n\n    /** Moves the snake.\n        @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down\n        @return The game's score after the move. Return -1 if game over.\n        Game over when snake crosses the screen boundary or bites its body. */\n    int move(string direction) {\n        auto head = snake.front(), tail = snake.back();\n        snake.pop_back();\n        if (direction == \"U\") --head.first;\n        else if (direction == \"L\") --head.second;\n        else if (direction == \"R\") ++head.second;\n        else if (direction == \"D\") ++head.first;\n        if (count(snake.begin(), snake.end(), head) || head.first < 0 || head.first >= height || head.second < 0 || head.second >= width) {\n            return -1;\n        }\n        snake.insert(snake.begin(), head);\n        if (!food.empty() && head == food.front()) {\n            food.erase(food.begin());\n            snake.push_back(tail);\n            ++score;\n        }\n        return score;\n    }\n\nprivate:\n    int width, height, score;\n    vector<pair<int, int>> food, snake;\n};\n\n/**\n * Your SnakeGame object will be instantiated and called as such:\n * SnakeGame* obj = new SnakeGame(width, height, food);\n * int param_1 = obj->move(direction);\n */"
      }
    },
    "354": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "355": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "356": {
      "solution": {
        "math": ""
      }
    },
    "357": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "358": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "359": {
      "solution": {
        "data-stream": ""
      }
    },
    "360": {
      "solution": {
        "two-pointers": "class Solution {\n    public int[] sortTransformedArray(int[] nums, int a, int b, int c) {\n        int n = nums.length;\n        int left = 0, right = n - 1, k = a < 0 ? 0 : n - 1;\n        int[] res = new int[n];\n        while (left <= right) {\n            int v1 = fn(a, b, c, nums[left]), v2 = fn(a, b, c, nums[right]);\n            if (a < 0) {\n                if (v1 <= v2) {\n                    res[k] = v1;\n                    ++left;\n                } else {\n                    res[k] = v2;\n                    --right;\n                }\n                ++k;\n            } else {\n                if (v1 >= v2) {\n                    res[k] = v1;\n                    ++left;\n                } else {\n                    res[k] = v2;\n                    --right;\n                }\n                --k;\n            }\n        }\n        return res;\n    }\n\n    private int fn(int a, int b, int c, int x) {\n        return a * x * x + b * x + c;\n    }\n}\n"
      }
    },
    "361": {
      "solution": {
        "matrix": ""
      }
    },
    "362": {
      "solution": {
        "queue": ""
      }
    },
    "363": {
      "solution": {
        "matrix": "class Solution {\n  public int maxSumSubmatrix(int[][] matrix, int k) {\n    int m = matrix.length;\n    int n = matrix[0].length;\n\n    int ans = Integer.MIN_VALUE;\n\n    for (int baseCol = 0; baseCol < n; ++baseCol) {\n      // sums[i] := sum(matrix[i][baseCol..j])\n      int[] sums = new int[m];\n      for (int j = baseCol; j < n; ++j) {\n        for (int i = 0; i < m; ++i)\n          sums[i] += matrix[i][j];\n        // find the max subarray no more than k\n        TreeSet<Integer> accumulate = new TreeSet<>(Arrays.asList(0));\n        int prefix = 0;\n        for (final int sum : sums) {\n          prefix += sum;\n          final Integer lo = accumulate.ceiling(prefix - k);\n          if (lo != null)\n            ans = Math.max(ans, prefix - lo);\n          accumulate.add(prefix);\n        }\n      }\n    }\n\n    return ans;\n  }\n}\n"
      }
    },
    "364": {
      "solution": {
        "stack": ""
      }
    },
    "365": {
      "solution": {
        "breadth-first-search": ""
      }
    },
    "366": {
      "solution": {
        "tree": ""
      }
    },
    "367": {
      "solution": {
        "math": ""
      }
    },
    "368": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "369": {
      "solution": {
        "linked-list": ""
      }
    },
    "370": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "371": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "372": {
      "solution": {
        "divide-and-conquer": ""
      }
    },
    "373": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "374": {
      "solution": {
        "interactive": ""
      }
    },
    "375": {
      "solution": {
        "breadth-first-search": "class Solution {\npublic:\n    int getMoneyAmount(int n) {\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n        \n        for (int len = 2; len <= n; ++len) { \n            for (int i = 1; i <= n - len + 1; ++i) {\n                int j = i + len - 1;\n                dp[i][j] = INT_MAX;\n                for (int k = i; k <= j; ++k) {\n                    int cost = k;\n                    int left = (k > i) ? dp[i][k - 1] : 0;\n                    int right = (k < j) ? dp[k + 1][j] : 0;\n                    dp[i][j] = min(dp[i][j], cost + max(left, right));\n                }\n            }\n        }\n        \n        return dp[1][n];\n    }\n};\n"
      }
    },
    "376": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "377": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "378": {
      "solution": {
        "matrix": "import java.util.PriorityQueue;\n\nclass Solution {\n    public int kthSmallest(int[][] matrix, int k) {\n        int n = matrix.length;\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        \n        for (int j = 0; j < n; j++) {\n            minHeap.offer(new int[]{matrix[0][j], 0, j}); // value, row, col\n        }\n        \n        for (int i = 0; i < k - 1; i++) {\n            int[] current = minHeap.poll();\n            int row = current[1];\n            int col = current[2];\n            \n            if (row < n - 1) {\n                minHeap.offer(new int[]{matrix[row + 1][col], row + 1, col});\n            }\n        }\n        \n        return minHeap.poll()[0];\n    }\n}\n"
      }
    },
    "379": {
      "solution": {
        "queue": ""
      }
    },
    "380": {
      "solution": {
        "randomized": "import java.util.*;\n\nclass RandomizedSet {\n    private List<Integer> nums;\n    private Map<Integer, Integer> pos;\n    private Random rand;\n\n    public RandomizedSet() {\n        nums = new ArrayList<>();\n        pos = new HashMap<>();\n        rand = new Random();\n    }\n\n    public boolean insert(int val) {\n        if (pos.containsKey(val)) {\n            return false;\n        }\n        pos.put(val, nums.size());\n        nums.add(val);\n        return true;\n    }\n\n    public boolean remove(int val) {\n        if (!pos.containsKey(val)) {\n            return false;\n        }\n        int idx = pos.get(val);\n        int lastElement = nums.get(nums.size() - 1);\n        nums.set(idx, lastElement);\n        pos.put(lastElement, idx);\n        nums.remove(nums.size() - 1);\n        pos.remove(val);\n        return true;\n    }\n\n    public int getRandom() {\n        return nums.get(rand.nextInt(nums.size()));\n    }\n}\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * RandomizedSet obj = new RandomizedSet();\n * boolean param_1 = obj.insert(val);\n * boolean param_2 = obj.remove(val);\n * int param_3 = obj.getRandom();\n */"
      }
    },
    "381": {
      "solution": {
        "randomized": "import java.util.*;\n\nclass RandomizedCollection {\n    private List<Integer> nums;\n    private Map<Integer, Set<Integer>> pos;\n    private Random rand;\n\n    public RandomizedCollection() {\n        nums = new ArrayList<>();\n        pos = new HashMap<>();\n        rand = new Random();\n    }\n\n    public boolean insert(int val) {\n        if (!pos.containsKey(val)) {\n            pos.put(val, new HashSet<>());\n        }\n        pos.get(val).add(nums.size());\n        nums.add(val);\n        return pos.get(val).size() == 1;\n    }\n\n    public boolean remove(int val) {\n        if (!pos.containsKey(val) || pos.get(val).isEmpty()) {\n            return false;\n        }\n        int idxToRemove = pos.get(val).iterator().next();\n        pos.get(val).remove(idxToRemove);\n        int lastElement = nums.get(nums.size() - 1);\n        nums.set(idxToRemove, lastElement);\n        if (pos.get(lastElement) != null) {\n            pos.get(lastElement).add(idxToRemove);\n            pos.get(lastElement).remove(nums.size() - 1);\n        }\n        nums.remove(nums.size() - 1);\n        if (pos.get(val).isEmpty()) {\n            pos.remove(val);\n        }\n        return true;\n    }\n\n    public int getRandom() {\n        return nums.get(rand.nextInt(nums.size()));\n    }\n}\n"
      }
    },
    "382": {
      "solution": {
        "reservoir-sampling": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nimport java.util.Random;\n\npublic class Solution {\n    private ListNode head;\n    private Random rand;\n\n    public Solution(ListNode head) {\n        this.head = head;\n        this.rand = new Random();\n    }\n\n    /** Returns a random node's value. */\n    public int getRandom() {\n        ListNode current = head;\n        int reservoir = -1; \n        int count = 0;\n\n        while (current != null) {\n            count++;\n            // With probability 1/count, select the current node's value\n            if (rand.nextInt(count) == 0) {\n                reservoir = current.val;\n            }\n            current = current.next;\n        }\n\n        return reservoir;\n    }\n}\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(head);\n * int param_1 = obj.getRandom();\n */"
      }
    },
    "383": {
      "solution": {
        "counting": "class Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n        vector<int> count(26);\n\n        for (const char c : magazine)\n            ++count[c - 'a'];\n\n        for (const char c : ransomNote) {\n            if (count[c - 'a'] == 0)\n                return false;\n            --count[c - 'a'];\n        }\n\n        return true;\n    }\n};"
      }
    },
    "384": {
      "solution": {
        "randomized": "import java.util.Random;\n\nclass Solution {\n    private int[] original;\n    private int[] array;\n    private Random rand;\n\n    public Solution(int[] nums) {\n        original = nums.clone();\n        array = nums.clone();\n        rand = new Random();\n    }\n\n    public int[] reset() {\n        array = original.clone();\n        return array;\n    }\n\n    public int[] shuffle() {\n        for (int i = 0; i < array.length; i++) {\n            int swapIdx = i + rand.nextInt(array.length - i);\n            int temp = array[i];\n            array[i] = array[swapIdx];\n            array[swapIdx] = temp;\n        }\n        return array;\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(nums);\n * int[] param_1 = obj.reset();\n * int[] param_2 = obj.shuffle();\n */"
      }
    },
    "385": {
      "solution": {
        "stack": ""
      }
    },
    "386": {
      "solution": {
        "trie": ""
      }
    },
    "387": {
      "solution": {
        "queue": "import java.util.HashMap;\n\npublic class Solution {\n    public int firstUniqChar(String s) {\n        HashMap<Character, Integer> count = new HashMap<>();\n        int n = s.length();\n\n        for (int i = 0; i < n; i++) {\n            char c = s.charAt(i);\n            count.put(c, count.getOrDefault(c, 0) + 1);\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (count.get(s.charAt(i)) == 1) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n"
      }
    },
    "388": {
      "solution": {
        "stack": "import java.util.HashMap;\n\npublic class Solution {\n    public int lengthLongestPath(String input) {\n        HashMap<Integer, Integer> pathLengths = new HashMap<>();\n        pathLengths.put(0, 0); \n        int maxLength = 0;\n\n        for (String part : input.split(\"\\n\")) {\n            int level = part.lastIndexOf('\t') + 1; \n            int len = part.length() - level; \n\n            if (part.contains(\".\")) { \n                maxLength = Math.max(maxLength, pathLengths.get(level) + len);\n            } else { \n                pathLengths.put(level + 1, pathLengths.get(level) + len + 1);\n            }\n        }\n\n        return maxLength;\n    }\n\n}\n"
      }
    },
    "389": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "390": {
      "solution": {
        "recursion": "class Solution {\npublic:\n    int lastRemaining(int n) { return helper(n, true); }\n\nprivate:\n    int helper(int n, bool leftToRight) {\n        if (n == 1) {\n            return 1;\n        }\n\n        if (leftToRight || n % 2 == 1) {\n            return 2 * helper(n / 2, !leftToRight);\n        } else {\n            return 2 * helper(n / 2, !leftToRight) - 1;\n        }\n    }\n};\n"
      }
    },
    "391": {
      "solution": {
        "line-sweep": "import java.util.*;\n\nclass Solution {\n    public boolean isRectangleCover(int[][] rectangles) {\n        int area = 0;\n        int x1 = Integer.MAX_VALUE;\n        int y1 = Integer.MAX_VALUE;\n        int x2 = Integer.MIN_VALUE;\n        int y2 = Integer.MIN_VALUE;\n\n        Set<String> corners = new HashSet<>();\n\n        for (int[] rect : rectangles) {\n            x1 = Math.min(x1, rect[0]);\n            y1 = Math.min(y1, rect[1]);\n            x2 = Math.max(x2, rect[2]);\n            y2 = Math.max(y2, rect[3]);\n\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\n\n            String[] cornerPoints = {\n                rect[0] + ' ' + rect[1], rect[0] + ' ' + rect[3],\n                rect[2] + ' ' + rect[1], rect[2] + ' ' + rect[3]\n            };\n\n            for (String point : cornerPoints) {\n                if (!corners.add(point)) {\n                    corners.remove(point);\n                }\n            }\n        }\n\n        if (!corners.contains(x1 + ' ' + y1) ||\n            !corners.contains(x1 + ' ' + y2) ||\n            !corners.contains(x2 + ' ' + y1) ||\n            !corners.contains(x2 + ' ' + y2) ||\n            corners.size() != 4) {\n            return false;\n        }\n\n        return area == (x2 - x1) * (y2 - y1);\n    }\n}\n"
      }
    },
    "392": {
      "solution": {
        "two-pointers": ""
      }
    },
    "393": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "394": {
      "solution": {
        "stack": ""
      }
    },
    "395": {
      "solution": {
        "sliding-window": "import java.util.HashMap;\n\npublic class Solution {\n    public int longestSubstring(String s, int k) {\n        int maxLength = 0;\n        \n        for (int uniqueCount = 1; uniqueCount <= 26; uniqueCount++) {\n            maxLength = Math.max(maxLength, longestSubstringWithNUniqueChars(s, k, uniqueCount));\n        }\n        \n        return maxLength;\n    }\n\n    private int longestSubstringWithNUniqueChars(String s, int k, int uniqueTarget) {\n        HashMap<Character, Integer> freqMap = new HashMap<>();\n        int left = 0, right = 0, maxLength = 0;\n        int uniqueChars = 0, countAtLeastack = 0;\n\n        while (right < s.length()) {\n            char rightChar = s.charAt(right);\n            freqMap.put(rightChar, freqMap.getOrDefault(rightChar, 0) + 1);\n            if (freqMap.get(rightChar) == 1) uniqueChars++;\n            if (freqMap.get(rightChar) == k) countAtLeastack++;\n            right++;\n\n            while (uniqueChars > uniqueTarget) {\n                char leftChar = s.charAt(left);\n                if (freqMap.get(leftChar) == k) countAtLeastack--;\n                freqMap.put(leftChar, freqMap.get(leftChar) - 1);\n                if (freqMap.get(leftChar) == 0) uniqueChars--;\n                left++;\n            }\n\n            if (uniqueChars == uniqueTarget && uniqueChars == countAtLeastack) {\n                maxLength = Math.max(maxLength, right - left);\n            }\n        }\n\n        return maxLength;\n    }\n\n}\n"
      }
    },
    "396": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "397": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "398": {
      "solution": {
        "reservoir-sampling": "public class Solution {\n    private int[] nums;\n    private Random rand;\n\n    public Solution(int[] nums) {\n        this.nums = nums;\n        this.rand = new Random();\n    }\n\n    public int pick(int target) {\n        int count = 0;\n        int result = -1; // Variable to store the chosen index\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == target) {\n                count++;\n                // With probability 1/count, select the current index\n                if (rand.nextInt(count) == 0) {\n                    result = i;\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(nums);\n * int param_1 = obj.pick(target);\n */"
      }
    },
    "399": {
      "solution": {
        "union-find": ""
      }
    },
    "400": {
      "solution": {
        "math": "",
        "binary-search": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findNthDigit(int n) {\n        long long digitLength = 1; \n        long long count = 9;       \n        long long start = 1;      \n\n        while (n > digitLength * count) {\n            n -= digitLength * count; // Skip all digits from this range\n            ++digitLength;            // Move to the next range (2-digits, 3-digits, etc.)\n            count *= 10;              // Update the count of numbers in the current range\n            start *= 10;              // Update the start of the current range\n        }\n\n        long long targetNumber = start + (n - 1) / digitLength; // Zero-indexed position\n\n        string targetStr = to_string(targetNumber); \n        int digitIndex = (n - 1) % digitLength;     \n        return targetStr[digitIndex] - '0';        \n    }\n};"
      }
    },
    "401": {
      "solution": {
        "backtracking": ""
      }
    },
    "402": {
      "solution": {
        "monotonic-stack": "class Solution {\n    public String removeKdigits(String num, int k) {\n        if (k == num.length()) {\n            return \"0\";\n        }\n\n        Stack<Character> stack = new Stack<>();\n\n        for (char digit : num.toCharArray()) {\n            while (!stack.isEmpty() && k > 0 && stack.peek() > digit) {\n                stack.pop();\n                k--;\n            }\n            stack.push(digit);\n        }\n\n        while (k > 0) {\n            stack.pop();\n            k--;\n        }\n\n        StringBuilder result = new StringBuilder();\n        while (!stack.isEmpty()) {\n            result.append(stack.pop());\n        }\n\n        result.reverse();\n        while (result.length() > 1 && result.charAt(0) == '0') {\n            result.deleteCharAt(0);\n        }\n\n        return result.toString();\n    }\n}\n"
      }
    },
    "403": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "404": {
      "solution": {
        "tree": ""
      }
    },
    "405": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "406": {
      "solution": {
        "sorting": ""
      }
    },
    "407": {
      "solution": {
        "matrix": ""
      }
    },
    "408": {
      "solution": {
        "two-pointers": ""
      }
    },
    "409": {
      "solution": {
        "greedy": ""
      }
    },
    "410": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "411": {
      "solution": {
        "backtracking": ""
      }
    },
    "412": {
      "solution": {
        "math": ""
      }
    },
    "413": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "414": {
      "solution": {
        "sorting": "#include <vector>\n#include <climits>\n#include <set>\nusing namespace std;\n\nclass Solution {\npublic:\n    int thirdMax(vector<int>& nums) {\n        // Use LONG_MIN to handle edge cases where the array contains negative numbers\n        long first = LONG_MIN, second = LONG_MIN, third = LONG_MIN;\n        \n        for (int num : nums) {\n            // Skip if num is already in the top three\n            if (num == first || num == second || num == third) {\n                continue;\n            }\n            \n            // Update the top three distinct maximums\n            if (num > first) {\n                third = second;\n                second = first;\n                first = num;\n            } else if (num > second) {\n                third = second;\n                second = num;\n            } else if (num > third) {\n                third = num;\n            }\n        }\n        \n        // If third is still LONG_MIN, it means there are less than 3 distinct numbers\n        return third == LONG_MIN ? first : third;\n    }\n};\n"
      }
    },
    "415": {
      "solution": {
        "math": ""
      }
    },
    "416": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "417": {
      "solution": {
        "matrix": ""
      }
    },
    "418": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "419": {
      "solution": {
        "matrix": ""
      }
    },
    "420": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "421": {
      "solution": {
        "trie": ""
      }
    },
    "422": {
      "solution": {
        "matrix": "class Solution {\n    public boolean validWordSquare(List<String> words) {\n        int m = words.size();\n        for (int i = 0; i < m; ++i) {\n            int n = words.get(i).length();\n            for (int j = 0; j < n; ++j) {\n                if (j >= m || i >= words.get(j).length()) {\n                    return false;\n                }\n                if (words.get(i).charAt(j) != words.get(j).charAt(i)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}"
      }
    },
    "423": {
      "solution": {
        "math": ""
      }
    },
    "424": {
      "solution": {
        "sliding-window": "public class Solution {\n    public int characterReplacement(String s, int k) {\n        int[] count = new int[26];\n        int maxCount = 0, left = 0, maxLength = 0;\n\n        for (int right = 0; right < s.length(); right++) {\n            char rightChar = s.charAt(right);\n            count[rightChar - 'A']++;\n            maxCount = Math.max(maxCount, count[rightChar - 'A']);\n\n            while (right - left + 1 - maxCount > k) {\n                char leftChar = s.charAt(left);\n                count[leftChar - 'A']--;\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n}\n"
      }
    },
    "425": {
      "solution": {
        "backtracking": ""
      }
    },
    "426": {
      "solution": {
        "doubly-linked-list": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val,Node _left,Node _right) {\n        val = _val;\n        left = _left;\n        right = _right;\n    }\n};\n*/\n\nclass Solution {\n    private Node prev;\n    private Node head;\n\n    public Node treeToDoublyList(Node root) {\n        if (root == null) {\n            return null;\n        }\n        prev = null;\n        head = null;\n        dfs(root);\n        prev.right = head;\n        head.left = prev;\n        return head;\n    }\n\n    private void dfs(Node root) {\n        if (root == null) {\n            return;\n        }\n        dfs(root.left);\n        if (prev != null) {\n            prev.right = root;\n            root.left = prev;\n        } else {\n            head = root;\n        }\n        prev = root;\n        dfs(root.right);\n    }\n}"
      }
    },
    "427": {
      "solution": {
        "matrix": ""
      }
    },
    "428": {
      "solution": {
        "tree": "class Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(Node* root) {\n        string res;\n        serializeHelper(root, res);\n        return res;\n    }\n    \n    void serializeHelper(Node* node, string& res) {\n        if (!node) res += \"#\";\n        else {\n            res += to_string(node->val) + \" \" + to_string(node->children.size()) + \" \";\n            for (auto child : node->children) {\n                serializeHelper(child, res);\n            }\n        }\n    }\n\n    // Decodes your encoded data to tree.\n    Node* deserialize(string data) {\n        istringstream iss(data);\n        return deserializeHelper(iss);\n    }\n    \n    Node* deserializeHelper(istringstream& iss) {\n        string val = \",\", size = \":\";\n        iss >> val;\n        if (val == \"#\") return NULL;\n        iss >> size;\n        Node *node = new Node(stoi(val), {});\n        for (int i = 0; i < stoi(size); ++i) {\n            node->children.push_back(deserializeHelper(iss));\n        }\n        return node;\n    }\n};"
      }
    },
    "429": {
      "solution": {
        "tree": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(Node* root) {\n        vector<vector<int>> result; \n        if (root == nullptr) return result;\n        \n        queue<Node*> q; \n        q.push(root);\n\n        while (!q.empty()) {\n            int levelSize = q.size();\n            vector<int> currentLevel;\n            \n            for (int i = 0; i < levelSize; i++) {\n                Node* node = q.front(); \n                q.pop(); \n                \n                currentLevel.push_back(node->val); \n                \n                for (Node* child : node->children) {\n                    q.push(child);\n                }\n            }\n            \n            result.push_back(currentLevel);\n        }\n        \n        return result;\n    }\n};\n"
      }
    },
    "430": {
      "solution": {
        "doubly-linked-list": "/*\nDefinition for a Node.\nclass Node {\n    public int val;\n    public Node prev;\n    public Node next;\n    public Node child;\n};\n*/\n\nclass Solution {\n    public Node flatten(Node head) {\n        if (head == null) return head;\n        \n        Node pointer = head;\n        \n        while (pointer != null) {\n            if (pointer.child == null) {\n                pointer = pointer.next;\n                continue;\n            }\n            \n            Node nextNode = pointer.next;            \n            Node child = pointer.child;\n            Node flattenedChild = flatten(child);\n            \n            pointer.next = flattenedChild;\n            flattenedChild.prev = pointer;\n            \n            Node tail = flattenedChild;\n            while (tail.next != null) {\n                tail = tail.next;\n            }\n            \n            tail.next = nextNode;\n            if (nextNode != null) {\n                nextNode.prev = tail;\n            }\n            \n            pointer.child = null;            \n            pointer = nextNode;\n        }\n        \n        return head;\n    }\n}\n\n"
      }
    },
    "431": {
      "solution": {
        "tree": ""
      }
    },
    "432": {
      "solution": {
        "doubly-linked-list": "class AllOne {\n\n    class Node {\n        int freq;\n        Set<String> keys;\n        Node prev;\n        Node next;\n\n        Node(int freq) {\n            this.freq = freq;\n            keys = new HashSet<>();\n        }\n    }\n\n    private Node head;\n    private Node tail;\n    private Map<String, Node> keyToNode;\n\n    public AllOne() {\n        head = new Node(0);\n        tail = new Node(0);\n        head.next = tail;\n        tail.prev = head;\n        keyToNode = new HashMap<>();\n    }\n\n    public void inc(String key) {\n        if (keyToNode.containsKey(key)) {\n            Node node = keyToNode.get(key);\n            moveKeyToNextFreq(node, key);\n        } else {\n            if (head.next.freq != 1) {\n                addNodeAfter(new Node(1), head);\n            }\n            head.next.keys.add(key);\n            keyToNode.put(key, head.next);\n        }\n    }\n\n    public void dec(String key) {\n        if (!keyToNode.containsKey(key)) return;\n        Node node = keyToNode.get(key);\n        if (node.freq == 1) {\n            node.keys.remove(key);\n            keyToNode.remove(key);\n        } else {\n            moveKeyToPrevFreq(node, key);\n        }\n        if (node.keys.isEmpty()) removeNode(node);\n    }\n\n    public String getMaxKey() {\n        return tail.prev == head ? ",
        " : tail.prev.keys.iterator().next();\n    }\n\n    public String getMinKey() {\n        return head.next == tail ? ": " : head.next.keys.iterator().next();\n    }\n\n    private void moveKeyToNextFreq(Node node, String key) {\n        int nextFreq = node.freq + 1;\n        Node nextNode = node.next;\n        if (nextNode.freq != nextFreq) {\n            nextNode = new Node(nextFreq);\n            addNodeAfter(nextNode, node);\n        }\n        node.keys.remove(key);\n        nextNode.keys.add(key);\n        keyToNode.put(key, nextNode);\n        if (node.keys.isEmpty()) removeNode(node);\n    }\n\n    private void moveKeyToPrevFreq(Node node, String key) {\n        int prevFreq = node.freq - 1;\n        Node prevNode = node.prev;\n        if (prevNode.freq != prevFreq) {\n            prevNode = new Node(prevFreq);\n            addNodeAfter(prevNode, node.prev);\n        }\n        node.keys.remove(key);\n        prevNode.keys.add(key);\n        keyToNode.put(key, prevNode);\n        if (node.keys.isEmpty()) removeNode(node);\n    }\n\n    private void addNodeAfter(Node newNode, Node prevNode) {\n        newNode.next = prevNode.next;\n        newNode.prev = prevNode;\n        prevNode.next.prev = newNode;\n        prevNode.next = newNode;\n    }\n\n    private void removeNode(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n}\n"
      }
    },
    "433": {
      "solution": {
        "breadth-first-search": ""
      }
    },
    "434": {
      "solution": {
        "string": ""
      }
    },
    "435": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "436": {
      "solution": {
        "sorting": ""
      }
    },
    "437": {
      "solution": {
        "tree": ""
      }
    },
    "438": {
      "solution": {
        "sliding-window": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> result = new ArrayList<>();\n        if (s == null || p == null || s.length() < p.length()) {\n            return result;\n        }\n\n        int[] pCount = new int[26];\n        int[] sCount = new int[26];\n\n        for (char c : p.toCharArray()) {\n            pCount[c - 'a']++;\n        }\n\n        int windowLength = p.length();\n        for (int i = 0; i < windowLength; i++) {\n            sCount[s.charAt(i) - 'a']++;\n        }\n\n        for (int i = windowLength; i < s.length(); i++) {\n            if (areArraysEqual(pCount, sCount)) {\n                result.add(i - windowLength);\n            }\n\n            sCount[s.charAt(i - windowLength) - 'a']--;\n            sCount[s.charAt(i) - 'a']++;\n        }\n\n        if (areArraysEqual(pCount, sCount)) {\n            result.add(s.length() - windowLength);\n        }\n\n        return result;\n    }\n\n    private boolean areArraysEqual(int[] arr1, int[] arr2) {\n        for (int i = 0; i < 26; i++) {\n            if (arr1[i] != arr2[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"
      }
    },
    "439": {
      "solution": {
        "stack": ""
      }
    },
    "440": {
      "solution": {
        "trie": ""
      }
    },
    "441": {
      "solution": {
        "math": ""
      }
    },
    "442": {
      "solution": {
        "hash-table": ""
      }
    },
    "443": {
      "solution": {
        "two-pointers": ""
      }
    },
    "444": {
      "solution": {
        "topological-sort": "class Solution {\npublic:\n    bool sequenceReconstruction(vector<int>& nums, vector<vector<int>>& sequences) {\n        int n = nums.size();\n        vector<vector<int>> g(n);\n        vector<int> indeg(n);\n        for (auto& seq : sequences) {\n            for (int i = 1; i < seq.size(); ++i) {\n                int a = seq[i - 1] - 1, b = seq[i] - 1;\n                g[a].push_back(b);\n                ++indeg[b];\n            }\n        }\n        queue<int> q;\n        for (int i = 0; i < n; ++i)\n            if (indeg[i] == 0) q.push(i);\n        while (!q.empty()) {\n            if (q.size() > 1) return false;\n            int i = q.front();\n            q.pop();\n            for (int j : g[i])\n                if (--indeg[j] == 0) q.push(j);\n        }\n        return true;\n    }\n};"
      }
    },
    "445": {
      "solution": {
        "stack": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode() {}\n * ListNode(int val) { this.val = val; }\n * ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\npublic class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        Stack<Integer> s1 = new Stack<>();\n        Stack<Integer> s2 = new Stack<>();\n\n        while (l1 != null) {\n            s1.push(l1.val);\n            l1 = l1.next;\n        }\n        while (l2 != null) {\n            s2.push(l2.val);\n            l2 = l2.next;\n        }\n\n        int carry = 0;\n        ListNode head = null;\n\n        while (!s1.isEmpty() || !s2.isEmpty() || carry != 0) {\n            int sum = carry;\n            if (!s1.isEmpty())\n                sum += s1.pop();\n            if (!s2.isEmpty())\n                sum += s2.pop();\n\n            carry = sum / 10;\n            ListNode newNode = new ListNode(sum % 10);\n            newNode.next = head;\n            head = newNode;\n        }\n\n        return head;\n    }\n\n}\n"
      }
    },
    "446": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "447": {
      "solution": {
        "math": ""
      }
    },
    "448": {
      "solution": {
        "hash-table": ""
      }
    },
    "449": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\nimport java.util.*;\n\npublic class Codec {\n\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        serializeHelper(root, sb);\n        return sb.toString();\n    }\n\n    private void serializeHelper(TreeNode node, StringBuilder sb) {\n        if (node == null) {\n            sb.append(\"null\").append(\",\");\n            return;\n        }\n\n        sb.append(node.val).append(\",\");\n        serializeHelper(node.left, sb);\n        serializeHelper(node.right, sb);\n    }\n\n    public TreeNode deserialize(String data) {\n        if (data == null || data.isEmpty()) {\n            return null;\n        }\n\n        String[] nodes = data.split(\",\");\n        Queue<String> queue = new LinkedList<>(Arrays.asList(nodes));\n        return deserializeHelper(queue);\n    }\n\n    private TreeNode deserializeHelper(Queue<String> queue) {\n        String val = queue.poll();\n        if (val.equals(\"null\")) {\n            return null;\n        }\n\n        TreeNode node = new TreeNode(Integer.parseInt(val));\n        node.left = deserializeHelper(queue);\n        node.right = deserializeHelper(queue);\n\n        return node;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// String tree = ser.serialize(root);\n// TreeNode ans = deser.deserialize(tree);\n// return ans;"
      }
    },
    "450": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode() {}\n * TreeNode(int val) { this.val = val; }\n * TreeNode(int val, TreeNode left, TreeNode right) {\n * this.val = val;\n * this.left = left;\n * this.right = right;\n * }\n * }\n */\nclass Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        if (root == null) {\n            return null;\n        }\n\n        if (key < root.val) {\n            root.left = deleteNode(root.left, key);\n        } else if (key > root.val) {\n            root.right = deleteNode(root.right, key);\n        } else {\n            if (root.left == null) {\n                return root.right;\n            } else if (root.right == null) {\n                return root.left;\n            }\n            root.val = findMin(root.right);\n            root.right = deleteNode(root.right, root.val);\n        }\n\n        return root;\n    }\n\n    private int findMin(TreeNode node) {\n        while (node.left != null) {\n            node = node.left;\n        }\n        return node.val;\n    }\n}\n"
      }
    },
    "451": {
      "solution": {
        "bucket-sort": "import java.util.*;\n\npublic class Solution {\n    public String frequencySort(String s) {\n        Map<Character, Integer> frequencyMap = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);\n        }\n\n        List<Character>[] buckets = new List[s.length() + 1];\n        for (char key : frequencyMap.keySet()) {\n            int frequency = frequencyMap.get(key);\n            if (buckets[frequency] == null) {\n                buckets[frequency] = new ArrayList<>();\n            }\n            buckets[frequency].add(key);\n        }\n\n        StringBuilder result = new StringBuilder();\n        for (int i = buckets.length - 1; i >= 0; i--) {\n            if (buckets[i] != null) {\n                for (char c : buckets[i]) {\n                    for (int j = 0; j < i; j++) {\n                        result.append(c);\n                    }\n                }\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.frequencySort(\"tree\")); // Output: \"eert\" or \"rtee\"\n        System.out.println(solution.frequencySort(\"cccaaa\")); // Output: \"cccaaa\" or \"aaaccc\"\n        System.out.println(solution.frequencySort(\"Aabb\")); // Output: \"bbAa\" or \"bbaA\"\n    }\n}\n"
      }
    },
    "452": {
      "solution": {
        "greedy": ""
      }
    },
    "453": {
      "solution": {
        "math": ""
      }
    },
    "454": {
      "solution": {
        "hash-table": ""
      }
    },
    "455": {
      "solution": {
        "two-pointers": ""
      }
    },
    "456": {
      "solution": {
        "monotonic-stack": "class Solution {\n    public boolean find132pattern(int[] nums) {\n        int n = nums.length;\n        if (n < 3) {\n            return false;\n        }\n\n        Stack<Integer> stack = new Stack<>();\n        int[] min = new int[n];\n        min[0] = nums[0];\n\n        for (int i = 1; i < n; ++i) {\n            min[i] = Math.min(min[i - 1], nums[i]);\n        }\n\n        for (int j = n - 1; j >= 0; --j) {\n            if (nums[j] > min[j]) {\n                while (!stack.isEmpty() && stack.peek() <= min[j]) {\n                    stack.pop();\n                }\n                if (!stack.isEmpty() && stack.peek() < nums[j]) {\n                    return true;\n                }\n                stack.push(nums[j]);\n            }\n        }\n\n        return false;\n    }\n}\n"
      }
    },
    "457": {
      "solution": {
        "two-pointers": "class Solution {\n    public boolean circularArrayLoop(int[] nums) {\n        if (nums.length < 2)\n            return false;\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] == 0)\n                continue;\n            int slow = i;\n            int fast = advance(nums, slow);\n            while (nums[i] * nums[fast] > 0 && nums[i] * nums[advance(nums, fast)] > 0) {\n                if (slow == fast) {\n                    if (slow == advance(nums, slow))\n                        break;\n                    return true;\n                }\n                slow = advance(nums, slow);\n                fast = advance(nums, advance(nums, fast));\n            }\n\n            slow = i;\n            int sign = nums[i];\n            while (sign * nums[slow] > 0) {\n                int next = advance(nums, slow);\n                nums[slow] = 0;\n                slow = next;\n            }\n        }\n\n        return false;\n    }\n\n    private int advance(int[] nums, int i) {\n        int n = nums.length;\n        int val = (i + nums[i]) % n;\n        return i + nums[i] >= 0 ? val : n + val;\n    }\n}"
      }
    },
    "458": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "459": {
      "solution": {
        "string-matching": "class Solution {\npublic:\n    bool repeatedSubstringPattern(string s) {\n        string doubled = s + s;        \n        return doubled.substr(1, doubled.size() - 2).find(s) != string::npos;\n    }\n};\n"
      }
    },
    "460": {
      "solution": {
        "doubly-linked-list": "class LFUCache {\n    class Node {\n        int key, value, freq;\n        Node prev, next;\n        Node(int k, int v) {\n            key = k;\n            value = v;\n            freq = 1;\n        }\n    }\n\n    class DoublyLinkedList {\n        Node head, tail;\n        DoublyLinkedList() {\n            head = new Node(0, 0);\n            tail = new Node(0, 0);\n            head.next = tail;\n            tail.prev = head;\n        }\n\n        void addNode(Node node) {\n            Node nextNode = head.next;\n            head.next = node;\n            node.prev = head;\n            node.next = nextNode;\n            nextNode.prev = node;\n        }\n\n        void removeNode(Node node) {\n            Node prevNode = node.prev;\n            Node nextNode = node.next;\n            prevNode.next = nextNode;\n            nextNode.prev = prevNode;\n        }\n\n        boolean isEmpty() {\n            return head.next == tail;\n        }\n    }\n\n    private int capacity, size, minFreq;\n    private Map<Integer, Node> keyToNode;\n    private Map<Integer, DoublyLinkedList> freqToDLL;\n\n    public LFUCache(int capacity) {\n        this.capacity = capacity;\n        this.size = 0;\n        this.minFreq = 0;\n        this.keyToNode = new HashMap<>();\n        this.freqToDLL = new HashMap<>();\n    }\n\n    public int get(int key) {\n        if (!keyToNode.containsKey(key)) return -1;\n        Node node = keyToNode.get(key);\n        updateFrequency(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        if (capacity == 0) return;\n        if (keyToNode.containsKey(key)) {\n            Node node = keyToNode.get(key);\n            node.value = value;\n            updateFrequency(node);\n        } else {\n            if (size == capacity) {\n                DoublyLinkedList minFreqList = freqToDLL.get(minFreq);\n                keyToNode.remove(minFreqList.tail.prev.key);\n                minFreqList.removeNode(minFreqList.tail.prev);\n                size--;\n            }\n            Node newNode = new Node(key, value);\n            keyToNode.put(key, newNode);\n            minFreq = 1;\n            freqToDLL.computeIfAbsent(1, k -> new DoublyLinkedList()).addNode(newNode);\n            size++;\n        }\n    }\n\n    private void updateFrequency(Node node) {\n        int oldFreq = node.freq;\n        DoublyLinkedList oldList = freqToDLL.get(oldFreq);\n        oldList.removeNode(node);\n        if (oldFreq == minFreq && oldList.isEmpty()) minFreq++;\n        node.freq++;\n        freqToDLL.computeIfAbsent(node.freq, k -> new DoublyLinkedList()).addNode(node);\n    }\n}\n"
      }
    },
    "461": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "462": {
      "solution": {
        "sorting": ""
      }
    },
    "463": {
      "solution": {
        "matrix": "class Solution {\n    private final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public int islandPerimeter(int[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\n            return 0;\n        }\n        int m = grid.length;\n        int n = grid[0].length;\n        int perimeter = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    for (int[] direction : DIRECTIONS) {\n                        int x = i + direction[0];\n                        int y = j + direction[1];\n\n                        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0) {\n                            perimeter++;\n                        }\n                    }\n                }\n            }\n        }\n\n        return perimeter;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] grid = {\n            {0, 1, 0, 0},\n            {1, 1, 1, 0},\n            {1, 0, 0, 0},\n            {0, 1, 0, 0}\n        };\n\n        int result = solution.islandPerimeter(grid);\n        System.out.println(\"Island Perimeter: \" + result); // Output: 12\n    }\n}\n"
      }
    },
    "464": {
      "solution": {
        "bitmask": "#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    unordered_map<int, bool> memo;\n\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (desiredTotal <= 0) return true;\n        int maxSum = (maxChoosableInteger * (maxChoosableInteger + 1)) / 2;\n        if (maxSum < desiredTotal) return false; // Not enough to reach the total\n\n        return canWin(maxChoosableInteger, desiredTotal, 0);\n    }\n\nprivate:\n    bool canWin(int maxChoosableInteger, int target, int used) {\n        if (memo.count(used)) return memo[used];\n\n        for (int i = 1; i <= maxChoosableInteger; ++i) {\n            int mask = (1 << i); // Bitmask for number `i`\n\n            if (used & mask) continue; // Skip if already used\n            \n            // If picking this number wins the game or makes the opponent lose\n            if (i >= target || !canWin(maxChoosableInteger, target - i, used | mask)) {\n                return memo[used] = true;\n            }\n        }\n\n        return memo[used] = false;\n    }\n};\n\n"
      }
    },
    "465": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "466": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "467": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "468": {
      "solution": {
        "string": ""
      }
    },
    "469": {
      "solution": {
        "geometry": ""
      }
    },
    "470": {
      "solution": {
        "rejection-sampling": "/**\n * The rand7() API is already defined in the parent class SolBase.\n * public int rand7();\n * @return a random integer in the range 1 to 7\n */\nclass Solution extends SolBase {\n    public int rand10() {\n        while (true) {\n            int num = (rand7() - 1) * 7 + rand7(); // Generate a number from 1 to 49\n            if (num <= 40) { // Accept only if the number is in the range 1 to 40\n                return 1 + (num - 1) % 10; // Map to the range 1 to 10\n            }\n        }\n    }\n}"
      }
    },
    "471": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "472": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "473": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "474": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "475": {
      "solution": {
        "two-pointers": ""
      }
    },
    "476": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "477": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "478": {
      "solution": {
        "rejection-sampling": "import java.util.Random;\n\nclass Solution {\n    private double radius;\n    private double x_center;\n    private double y_center;\n    private Random random;\n\n    public Solution(double radius, double x_center, double y_center) {\n        this.radius = radius;\n        this.x_center = x_center;\n        this.y_center = y_center;\n        this.random = new Random();\n    }\n\n    public double[] randPoint() {\n        double x = x_center - radius + 2 * radius * random.nextDouble();\n        double y = y_center - radius + 2 * radius * random.nextDouble();\n\n        while (!isInCircle(x, y)) {\n            x = x_center - radius + 2 * radius * random.nextDouble();\n            y = y_center - radius + 2 * radius * random.nextDouble();\n        }\n\n        return new double[]{x, y};\n    }\n\n    private boolean isInCircle(double x, double y) {\n        return Math.pow(x - x_center, 2) + Math.pow(y - y_center, 2) <= Math.pow(radius, 2);\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(radius, x_center, y_center);\n * double[] param_1 = obj.randPoint();\n */"
      }
    },
    "479": {
      "solution": {
        "enumeration": ""
      }
    },
    "480": {
      "solution": {
        "sliding-window": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Solution {\n    public double[] medianSlidingWindow(int[] nums, int k) {\n        List<Double> resList = new ArrayList<>();\n        int n = nums.length;\n        int i = 0;\n        int j = k - 1;\n        List<Integer> temp = new ArrayList<>();\n        for (int x = 0; x < k - 1; x++) {\n            temp.add(nums[x]);\n        }\n        Collections.sort(temp);\n        while (j < n) {\n            int num = nums[j];\n            int insertIdx = Collections.binarySearch(temp, num);\n            if (insertIdx < 0) {\n                insertIdx = -insertIdx - 1;\n            }\n            temp.add(insertIdx, num);\n\n            if (k % 2 == 1) {\n                double median = (double) temp.get(k / 2);\n                resList.add(median);\n            } else {\n                int idx = k / 2;\n                double median1 = (double) temp.get(idx);\n                double median2 = (double) temp.get(idx - 1);\n                resList.add((median1 + median2) / 2);\n            }\n\n            int removeIdx = Collections.binarySearch(temp, nums[i]);\n            if (removeIdx < 0) {\n                removeIdx = -removeIdx - 1;\n            }\n            temp.remove(removeIdx);\n\n            i++;\n            j++;\n        }\n\n        double[] resArray = new double[resList.size()];\n        for (int x = 0; x < resList.size(); x++) {\n            resArray[x] = resList.get(x);\n        }\n\n        return resArray;\n    }\n}"
      }
    },
    "481": {
      "solution": {
        "two-pointers": ""
      }
    },
    "482": {
      "solution": {
        "string": ""
      }
    },
    "483": {
      "solution": {
        "math": ""
      }
    },
    "484": {
      "solution": {
        "stack": ""
      }
    },
    "485": {
      "solution": {
        "array": "class Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        int maxCount = 0;\n        int currentCount = 0;\n        \n        for (int num : nums) {\n            if (num == 1) {\n                currentCount++;\n                maxCount = Math.max(maxCount, currentCount);\n            } else {\n                currentCount = 0;\n            }\n        }\n        \n        return maxCount;\n    }\n}\n"
      }
    },
    "486": {
      "solution": {
        "game-theory": "class Solution {\npublic:\n    bool predictTheWinner(vector<int>& nums) {\n        int n = nums.size();\n        vector<vector<int>> dp(n, vector<int>(n, 0));\n\n        // Base case: When the range is a single element\n        for (int i = 0; i < n; ++i) {\n            dp[i][i] = nums[i];\n        }\n\n        // Fill the DP table for ranges of increasing lengths\n        for (int len = 2; len <= n; ++len) {\n            for (int i = 0; i <= n - len; ++i) {\n                int j = i + len - 1;\n                dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]);\n            }\n        }\n\n        // If dp[0][n-1] >= 0, Player 1 can win or tie\n        return dp[0][n-1] >= 0;\n    }\n};\n"
      }
    },
    "487": {
      "solution": {
        "sliding-window": "class Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        int left = 0, right = 0;\n        int k = 1;\n        while (right < nums.length) {\n            if (nums[right++] == 0) {\n                --k;\n            }\n            if (k < 0 && nums[left++] == 0) {\n                ++k;\n            }\n        }\n        return right - left;\n    }\n}"
      }
    },
    "488": {
      "solution": {
        "stack": ""
      }
    },
    "489": {
      "solution": {
        "interactive": ""
      }
    },
    "490": {
      "solution": {
        "matrix": "class Solution {\n\n  private static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n  public boolean hasPath(int[][] maze, int[] start, int[] destination) {\n    boolean[][] seen = new boolean[maze.length][maze[0].length];\n    return dfs(maze, seen, start[0], start[1], destination);\n  }\n\n  private boolean dfs(int[][] maze, boolean[][] seen, int i, int j, int[] destination) {\n    if (i == destination[0] && j == destination[1])\n      return true;\n    if (seen[i][j])\n      return false;\n\n    seen[i][j] = true;\n\n    for (int[] dir : dirs) {\n      int x = i;\n      int y = j;\n      while (isValid(maze, x + dir[0], y + dir[1])) {\n        x += dir[0];\n        y += dir[1];\n      }\n      if (dfs(maze, seen, x, y, destination))\n        return true;\n    }\n\n    return false;\n  }\n\n  private boolean isValid(int[][] maze, int x, int y) {\n    return 0 <= x && x < maze.length && 0 <= y && y < maze[0].length && maze[x][y] == 0;\n  }\n}"
      }
    },
    "491": {
      "solution": {
        "backtracking": ""
      }
    },
    "492": {
      "solution": {
        "math": ""
      }
    },
    "493": {
      "solution": {
        "merge-sort": "class Solution {\n    public int reversePairs(int[] nums) {\n        return mergeSortAndCount(nums, 0, nums.length - 1);\n    }\n    \n    private int mergeSortAndCount(int[] nums, int left, int right) {\n        if (left >= right) return 0;\n        \n        int mid = left + (right - left) / 2;\n        int count = mergeSortAndCount(nums, left, mid) + mergeSortAndCount(nums, mid + 1, right);\n        count += mergeAndCount(nums, left, mid, right);\n        \n        return count;\n    }\n    \n    private int mergeAndCount(int[] nums, int left, int mid, int right) {\n        int count = 0;\n        int[] merged = new int[right - left + 1];\n        int i = left, j = mid + 1, k = 0;\n        \n        while (i <= mid && j <= right) {\n            if ((long) nums[i] > 2 * (long) nums[j]) {\n                count += (mid - i + 1);\n                j++;\n            } else {\n                i++;\n            }\n        }\n        \n        i = left; j = mid + 1;\n        while (i <= mid && j <= right) {\n            if (nums[i] <= nums[j]) {\n                merged[k++] = nums[i++];\n            } else {\n                merged[k++] = nums[j++];\n            }\n        }\n        \n        while (i <= mid) {\n            merged[k++] = nums[i++];\n        }\n        \n        while (j <= right) {\n            merged[k++] = nums[j++];\n        }\n        \n        System.arraycopy(merged, 0, nums, left, merged.length);\n        \n        return count;\n    }\n}\n"
      }
    },
    "494": {
      "solution": {
        "dynamic-programming": "",
        "backtracking": "import java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        return dfs(nums, 0, 0, target, new HashMap<>());\n    }\n\n    private int dfs(int[] nums, int index, int currentSum, int target, Map<String, Integer> memo) {\n        if (index == nums.length) {\n            return currentSum == target ? 1 : 0;\n        }        \n        String key = index + \",\" + currentSum;\n        if (memo.containsKey(key)) {\n            return memo.get(key);\n        }        \n        int add = dfs(nums, index + 1, currentSum + nums[index], target, memo);\n        int subtract = dfs(nums, index + 1, currentSum - nums[index], target, memo);        \n        memo.put(key, add + subtract);\n        return add + subtract;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, 1, 1, 1, 1};\n        int target = 3;\n        System.out.println(solution.findTargetSumWays(nums, target));  // Output: 5\n    }\n}\n"
      }
    },
    "495": {
      "solution": {
        "array": ""
      }
    },
    "496": {
      "solution": {
        "monotonic-stack": "class Solution {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int m = nums1.length;\n        int n = nums2.length;\n        int[] nums = nextGreaterElement(nums2);\n\n        for (int i = 0; i < n; i++) {\n            map.put(nums2[i], nums[i]);\n        }\n\n        int[] result = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            result[i] = map.get(nums1[i]);\n        }\n\n        return result;\n    }\n\n    public int[] nextGreaterElement(int[] nums) {\n        int[] result = new int[nums.length];\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = nums.length - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && stack.peek() <= nums[i]) {\n                stack.pop();\n            }\n            result[i] = stack.isEmpty() ? -1 : stack.peek();\n            stack.push(nums[i]);\n        }\n\n        return result;\n    }\n\n}\n\n// class Solution {\n//     public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n//         Map<Integer, Integer> map = new HashMap<>();\n//         Stack<Integer> stack = new Stack<>();\n//         for (int num : nums2) {\n//             while (!stack.isEmpty() && stack.peek() < num) {\n//                 map.put(stack.pop(), num);\n//             }\n//             stack.push(num);\n//         }\n//         for (int i = 0; i < nums1.length; i++) {\n//             nums1[i] = map.getOrDefault(nums1[i], -1);\n//         }\n//         return nums1;\n//     }\n// }"
      }
    },
    "497": {
      "solution": {
        "reservoir-sampling": "import java.util.Random;\nimport java.util.TreeMap;\n\npublic class Solution {\n    private int[][] rects;\n    private Random rand;\n    private TreeMap<Integer, Integer> areaMap;\n    private int totalPoints;\n\n    public Solution(int[][] rects) {\n        this.rects = rects;\n        this.rand = new Random();\n        this.areaMap = new TreeMap<>();\n        this.totalPoints = 0;\n\n        // Calculate the cumulative number of points for each rectangle\n        for (int i = 0; i < rects.length; i++) {\n            int[] rect = rects[i];\n            int area = (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1);\n            totalPoints += area;\n            areaMap.put(totalPoints, i);\n        }\n    }\n\n    public int[] pick() {\n        int randomPoint = rand.nextInt(totalPoints) + 1;\n        int rectIndex = areaMap.ceilingEntry(randomPoint).getValue();\n        int[] rect = rects[rectIndex];\n\n        int x = rect[0] + rand.nextInt(rect[2] - rect[0] + 1);\n        int y = rect[1] + rand.nextInt(rect[3] - rect[1] + 1);\n\n        return new int[] { x, y };\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(rects);\n * int[] param_1 = obj.pick();\n */"
      }
    },
    "498": {
      "solution": {
        "matrix": "public class Solution {\n    private static final int[][] DIAGONAL_DIRECTIONS = {{-1, 1}, {1, -1}};\n    \n    public int[] findDiagonalOrder(int[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return new int[0]; \n        }\n        \n        int m = matrix.length;   \n        int n = matrix[0].length;\n        int[] result = new int[m * n]; \n        \n        int r = 0, c = 0;\n        int direction = 0;\n        \n        for (int i = 0; i < m * n; i++) {\n            result[i] = matrix[r][c]; \n            int newR = r + DIAGONAL_DIRECTIONS[direction][0];\n            int newC = c + DIAGONAL_DIRECTIONS[direction][1];\n            \n            if (newR < 0 || newR >= m || newC < 0 || newC >= n) {\n                if (direction == 0) { \n                    if (c == n - 1) {\n                        r++;\n                    } else {\n                        c++; \n                    }\n                } else { \n                    if (r == m - 1) {\n                        c++;\n                    } else {\n                        r++;\n                    }\n                }\n                direction = 1 - direction;\n            } else {\n                r = newR;\n                c = newC;\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[][] matrix = {\n            { 1, 2, 3 },\n            { 4, 5, 6 },\n            { 7, 8, 9 }\n        };\n        \n        int[] result = solution.findDiagonalOrder(matrix);\n        \n        for (int val : result) {\n            System.out.print(val + \" \");\n        }\n    }\n}\n"
      }
    },
    "499": {
      "solution": {
        "matrix": "class Solution {\n    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {\n        int m = maze.length;\n        int n = maze[0].length;\n        int r = ball[0], c = ball[1];\n        int rh = hole[0], ch = hole[1];\n        Deque<int[]> q = new LinkedList<>();\n        q.offer(new int[] {r, c});\n        int[][] dist = new int[m][n];\n        for (int i = 0; i < m; ++i) {\n            Arrays.fill(dist[i], Integer.MAX_VALUE);\n        }\n        dist[r][c] = 0;\n        String[][] path = new String[m][n];\n        path[r][c] = \"\";\n        int[][] dirs = { {-1, 0, 'u'}, {1, 0, 'd'}, {0, -1, 'l'}, {0, 1, 'r'} };\n        while (!q.isEmpty()) {\n            int[] p = q.poll();\n            int i = p[0], j = p[1];\n            for (int[] dir : dirs) {\n                int a = dir[0], b = dir[1];\n                String d = String.valueOf((char) (dir[2]));\n                int x = i, y = j;\n                int step = dist[i][j];\n                while (x + a >= 0 && x + a < m && y + b >= 0 && y + b < n && maze[x + a][y + b] == 0\n                    && (x != rh || y != ch)) {\n                    x += a;\n                    y += b;\n                    ++step;\n                }\n                if (dist[x][y] > step\n                    || (dist[x][y] == step && (path[i][j] + d).compareTo(path[x][y]) < 0)) {\n                    dist[x][y] = step;\n                    path[x][y] = path[i][j] + d;\n                    if (x != rh || y != ch) {\n                        q.offer(new int[] {x, y});\n                    }\n                }\n            }\n        }\n        return path[rh][ch] == null ? \"impossible\" : path[rh][ch];\n    }\n}\n"
      }
    },
    "500": {
      "solution": {
        "hash-table": ""
      }
    },
    "501": {
      "solution": {
        "binary-search-tree": "import java.util.*;\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode() {}\n * TreeNode(int val) { this.val = val; }\n * TreeNode(int val, TreeNode left, TreeNode right) {\n * this.val = val;\n * this.left = left;\n * this.right = right;\n * }\n * }\n */\nclass Solution {\n    private int maxCount;\n    private int currentCount;\n    private int currentVal;\n    private List<Integer> modes;\n\n    public int[] findMode(TreeNode root) {\n        if (root == null) {\n            return new int[0];\n        }\n\n        maxCount = 0;\n        currentCount = 0;\n        currentVal = Integer.MIN_VALUE;\n        modes = new ArrayList<>();\n\n        traverse(root);\n\n        int[] result = new int[modes.size()];\n        for (int i = 0; i < modes.size(); i++) {\n            result[i] = modes.get(i);\n        }\n\n        return result;\n    }\n\n    private void traverse(TreeNode node) {\n        if (node == null) {\n            return;\n        }\n\n        traverse(node.left);\n\n        handleValue(node.val);\n\n        traverse(node.right);\n    }\n\n    private void handleValue(int val) {\n        if (val != currentVal) {\n            currentVal = val;\n            currentCount = 0;\n        }\n\n        currentCount++;\n\n        if (currentCount > maxCount) {\n            maxCount = currentCount;\n            modes.clear();\n            modes.add(currentVal);\n        } else if (currentCount == maxCount) {\n            modes.add(currentVal);\n        }\n    }\n}\n"
      }
    },
    "502": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "503": {
      "solution": {
        "monotonic-stack": "class Solution {\n    public int[] nextGreaterElements(int[] nums) {\n        int n = nums.length;\n        int[] result = new int[n];\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 2 * n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && stack.peek() <= nums[i % n]) {\n                stack.pop();\n            }\n            result[i % n] = stack.isEmpty() ? -1 : stack.peek();\n            stack.push(nums[i % n]);\n        }\n\n        return result;\n    }\n}\n"
      }
    },
    "504": {
      "solution": {
        "math": ""
      }
    },
    "505": {
      "solution": {
        "matrix": "class Solution {\n  public int shortestDistance(int[][] maze, int[] start, int[] destination) {\n    int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    int m = maze.length;\n    int n = maze[0].length;\n    Queue<Pair<Integer, Integer>> q = new ArrayDeque<>(List.of(new Pair<>(start[0], start[1])));\n    int[][] dist = new int[maze.length][maze[0].length];\n    Arrays.stream(dist).forEach(A -> Arrays.fill(A, Integer.MAX_VALUE));\n    dist[start[0]][start[1]] = 0;\n\n    while (!q.isEmpty()) {\n      int i = q.peek().getKey();\n      int j = q.poll().getValue();\n      for (int[] dir : dirs) {\n        int x = i;\n        int y = j;\n        int step = dist[i][j];\n        while (isValid(maze, x + dir[0], y + dir[1])) {\n          x += dir[0];\n          y += dir[1];\n          ++step;\n        }\n        if (step < dist[x][y]) {\n          dist[x][y] = step;\n          q.offer(new Pair<>(x, y));\n        }\n      }\n    }\n\n    return dist[destination[0]][destination[1]] == Integer.MAX_VALUE\n        ? -1\n        : dist[destination[0]][destination[1]];\n  }\n\n  private boolean isValid(int[][] maze, int x, int y) {\n    return x >= 0 && x < maze.length && y >= 0 && y < maze[0].length && maze[x][y] == 0;\n  }\n}"
      }
    },
    "506": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "507": {
      "solution": {
        "math": ""
      }
    },
    "508": {
      "solution": {
        "tree": ""
      }
    },
    "509": {
      "solution": {
        "memoization": "class Solution {\npublic:\n    int fib(int n) {\n        vector<int> memo(n + 1, -1); \n        return fibHelper(n, memo);\n    }\n    \nprivate:\n    int fibHelper(int n, vector<int>& memo) {\n        if (n <= 1) return n; // Base cases: fib(0) = 0, fib(1) = 1\n        \n        if (memo[n] != -1) return memo[n];\n                \n        memo[n] = fibHelper(n - 1, memo) + fibHelper(n - 2, memo);\n        return memo[n];\n    }\n};\n"
      }
    },
    "510": {
      "solution": {
        "binary-search-tree": ""
      }
    },
    "511": {
      "solution": {
        "database": ""
      }
    },
    "512": {
      "solution": {
        "database": ""
      }
    },
    "513": {
      "solution": {
        "tree": ""
      }
    },
    "514": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "515": {
      "solution": {
        "tree": ""
      }
    },
    "516": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "517": {
      "solution": {
        "greedy": ""
      }
    },
    "518": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "519": {
      "solution": {
        "reservoir-sampling": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Random;\n\npublic class Solution {\n    private int m, n, totalCells;\n    private Map<Integer, Integer> map;\n    private Random rand;\n\n    public Solution(int m, int n) {\n        this.m = m;\n        this.n = n;\n        this.totalCells = m * n;\n        this.map = new HashMap<>();\n        this.rand = new Random();\n    }\n\n    public int[] flip() {\n        int randomCell = rand.nextInt(totalCells);\n        totalCells--;\n\n        // Use map to get the actual position or the random position\n        int position = map.getOrDefault(randomCell, randomCell);\n\n        // Map the selected position to the last available cell position\n        map.put(randomCell, map.getOrDefault(totalCells, totalCells));\n\n        return new int[]{position / n, position % n};\n    }\n\n    public void reset() {\n        map.clear();\n        totalCells = m * n;\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(m, n);\n * int[] param_1 = obj.flip();\n * obj.reset();\n */"
      }
    },
    "520": {
      "solution": {
        "string": ""
      }
    },
    "521": {
      "solution": {
        "string": ""
      }
    },
    "522": {
      "solution": {
        "two-pointers": ""
      }
    },
    "523": {
      "solution": {
        "prefix-sum": "import java.util.HashMap;\n\npublic class Solution {\n    public boolean checkSubarraySum(int[] nums, int k) {\n        HashMap<Integer, Integer> remainderMap = new HashMap<>();\n        remainderMap.put(0, -1); // Base case: remainder 0 at index -1\n        \n        int prefixSum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum += nums[i];\n            \n            // Compute remainder\n            int remainder = k == 0 ? prefixSum : (prefixSum % k + k) % k; // Handle negative remainders\n            \n            // Check if the remainder is already seen\n            if (remainderMap.containsKey(remainder)) {\n                // Ensure subarray length is at least 2\n                if (i - remainderMap.get(remainder) > 1) {\n                    return true;\n                }\n            } else {\n                remainderMap.put(remainder, i);\n            }\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {23, 2, 4, 6, 7};\n        int k = 6;\n        System.out.println(solution.checkSubarraySum(nums, k)); // Output: true\n    }\n}\n"
      }
    },
    "524": {
      "solution": {
        "two-pointers": ""
      }
    },
    "525": {
      "solution": {
        "prefix-sum": "import java.util.HashMap;\n\npublic class Solution {\n    public int findMaxLength(int[] nums) {\n        HashMap<Integer, Integer> prefixSumMap = new HashMap<>();\n        \n        // Initialize with the base case: sum 0 at index -1\n        prefixSumMap.put(0, -1);\n        \n        int prefixSum = 0;\n        int maxLength = 0;\n        \n        for (int i = 0; i < nums.length; i++) {\n            prefixSum += (nums[i] == 1) ? 1 : -1;\n            \n            if (prefixSumMap.containsKey(prefixSum)) {\n                maxLength = Math.max(maxLength, i - prefixSumMap.get(prefixSum));\n            } else {\n                prefixSumMap.put(prefixSum, i);\n            }\n        }\n        \n        return maxLength;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {0, 1, 0, 1, 1, 0};\n        System.out.println(solution.findMaxLength(nums)); // Output: 6\n    }\n}\n"
      }
    },
    "526": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "527": {
      "solution": {
        "trie": ""
      }
    },
    "528": {
      "solution": {
        "randomized": "import java.util.Random;\nimport java.util.TreeMap;\n\nclass Solution {\n    private int[] prefixSums;\n    private int totalSum;\n    private Random rand;\n\n    public Solution(int[] w) {\n        prefixSums = new int[w.length];\n        prefixSums[0] = w[0];\n        for (int i = 1; i < w.length; i++) {\n            prefixSums[i] = prefixSums[i - 1] + w[i];\n        }\n        totalSum = prefixSums[prefixSums.length - 1];\n        rand = new Random();\n    }\n\n    public int pickIndex() {\n        int target = rand.nextInt(totalSum) + 1;\n        int low = 0, high = prefixSums.length - 1;\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            if (prefixSums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(w);\n * int param_1 = obj.pickIndex();\n */"
      }
    },
    "529": {
      "solution": {
        "matrix": "class Solution {\n\n  private static final int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},\n                                       {0, 1},   {1, -1}, {1, 0},  {1, 1}};\n\n  public char[][] updateBoard(char[][] board, int[] click) {\n    int i = click[0];\n    int j = click[1];\n    if (board[i][j] == 'M') {\n      board[i][j] = 'X';\n      return board;\n    }\n\n    dfs(board, i, j);\n    return board;\n  }\n\n  private void dfs(char[][] board, int i, int j) {\n    if (i < 0 || i == board.length || j < 0 || j == board[0].length)\n      return;\n    if (board[i][j] != 'E')\n      return;\n\n    int minesCount = getMinesCount(board, i, j);\n    board[i][j] = minesCount == 0 ? 'B' : (char) ('0' + minesCount);\n\n    if (minesCount == 0)\n      for (int[] dir : dirs)\n        dfs(board, i + dir[0], j + dir[1]);\n  }\n\n  private int getMinesCount(char[][] board, int i, int j) {\n    int minesCount = 0;\n    for (int[] dir : dirs) {\n      int x = i + dir[0];\n      int y = j + dir[1];\n      if (x < 0 || x == board.length || y < 0 || y == board[0].length)\n        continue;\n      if (board[x][y] == 'M')\n        ++minesCount;\n    }\n    return minesCount;\n  }\n}"
      }
    },
    "530": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int minDiff;\n    private Integer prev;\n\n    public int getMinimumDifference(TreeNode root) {\n        minDiff = Integer.MAX_VALUE;\n        prev = null;\n        inorder(root);\n        return minDiff;\n    }\n    \n    private void inorder(TreeNode node) {\n        if (node == null) {\n            return;\n        }\n        \n        inorder(node.left);\n        if (prev != null) {\n            minDiff = Math.min(minDiff, node.val - prev);\n        }\n        prev = node.val;\n        inorder(node.right);\n    }\n}\n"
      }
    },
    "531": {
      "solution": {
        "matrix": ""
      }
    },
    "532": {
      "solution": {
        "two-pointers": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Solution {\n    public int findPairs(int[] nums, int k) {\n        if (nums == null || nums.length < 2 || k < 0) {\n            return 0;\n        }\n\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        Set<Integer> countedPairs = new HashSet<>();\n        int count = 0;\n\n        for (int num : nums) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        for (int num : nums) {\n            if (frequencyMap.containsKey(num + k) && !countedPairs.contains(num)) {\n                if (k == 0) {\n                    if (frequencyMap.get(num) > 1) {\n                        count++;\n                        countedPairs.add(num);\n                    }\n                } else {\n                    count++;\n                    countedPairs.add(num);\n                }\n            }\n        }\n\n        return count;\n    }\n}\n"
      }
    },
    "533": {
      "solution": {
        "matrix": ""
      }
    },
    "534": {
      "solution": {
        "database": ""
      }
    },
    "535": {
      "solution": {
        "hash-function": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Codec {\n    private static final String BASE_URL = \"http://tinyurl.com/\";\n    private Map<String, String> shortToLongMap = new HashMap<>();\n    private Map<String, String> longToShortMap = new HashMap<>();\n    \n    private String getHash(String url) {\n        return Integer.toHexString(url.hashCode());\n    }\n\n    public String encode(String longUrl) {\n        if (longToShortMap.containsKey(longUrl)) {\n            return BASE_URL + longToShortMap.get(longUrl);\n        }\n\n        String shortKey = getHash(longUrl);\n        while (shortToLongMap.containsKey(shortKey)) {\n            longUrl += \" \";\n            shortKey = getHash(longUrl);\n        }\n        \n        shortToLongMap.put(shortKey, longUrl);\n        longToShortMap.put(longUrl, shortKey);\n        \n        return BASE_URL + shortKey;\n    }\n\n    public String decode(String shortUrl) {\n        String shortKey = shortUrl.replace(BASE_URL, \"\");\n        return shortToLongMap.get(shortKey);\n    }\n\n}\n"
      }
    },
    "536": {
      "solution": {
        "stack": ""
      }
    },
    "537": {
      "solution": {
        "math": ""
      }
    },
    "538": {
      "solution": {
        "binary-search-tree": ""
      }
    },
    "539": {
      "solution": {
        "sorting": ""
      }
    },
    "540": {
      "solution": {
        "array": ""
      }
    },
    "541": {
      "solution": {
        "two-pointers": ""
      }
    },
    "542": {
      "solution": {
        "matrix": "public class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    public int[][] updateMatrix(int[][] matrix) {\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        int[][] distances = new int[rows][cols];\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (matrix[i][j] == 1) {\n                    distances[i][j] = Integer.MAX_VALUE;\n                }\n            }\n        }\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (matrix[i][j] == 0) {\n                    dfs(matrix, distances, i, j);\n                }\n            }\n        }\n\n        return distances;\n    }\n\n    private void dfs(int[][] matrix, int[][] distances, int row, int col) {\n        for (int[] dir : DIRECTIONS) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if (newRow >= 0 && newRow < matrix.length && newCol >= 0 && newCol < matrix[0].length) {\n                if (distances[newRow][newCol] > distances[row][col] + 1) {\n                    distances[newRow][newCol] = distances[row][col] + 1;\n                    dfs(matrix, distances, newRow, newCol);\n                }\n            }\n        }\n    }\n}\n"
      }
    },
    "543": {
      "solution": {
        "tree": ""
      }
    },
    "544": {
      "solution": {
        "recursion": ""
      }
    },
    "545": {
      "solution": {
        "tree": ""
      }
    },
    "546": {
      "solution": {
        "memoization": "class Solution {\npublic:\n    int removeBoxes(vector<int>& boxes) {\n        int n = boxes.size();\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(n, -1)));\n        return helper(0, n - 1, 0, boxes, dp);\n    }\n\nprivate:\n    int helper(int l, int r, int k, vector<int>& boxes, vector<vector<vector<int>>>& dp) {\n        if (l > r) return 0; // No boxes left to remove\n        \n        if (dp[l][r][k] != -1) return dp[l][r][k]; // Return cached result\n        \n        // Extend the streak of the same color\n        int l_orig = l, k_orig = k;\n        while (l + 1 <= r && boxes[l] == boxes[l + 1]) {\n            ++l;\n            ++k;\n        }\n        \n        // Case 1: Remove the current streak\n        int res = (k + 1) * (k + 1) + helper(l + 1, r, 0, boxes, dp);\n        \n        // Case 2: Try merging with future streaks of the same color\n        for (int m = l + 1; m <= r; ++m) {\n            if (boxes[m] == boxes[l_orig]) {\n                res = max(res, helper(l + 1, m - 1, 0, boxes, dp) + helper(m, r, k + 1, boxes, dp));\n            }\n        }\n        \n        return dp[l_orig][r][k_orig] = res; // Cache and return result\n    }\n};\n"
      }
    },
    "547": {
      "solution": {
        "union-find": "class UF {\n  public UF(int n) {\n    size = n;\n    id = new int[n];\n    for (int i = 0; i < n; ++i)\n      id[i] = i;\n  }\n\n  public void union(int u, int v) {\n    final int i = find(u);\n    final int j = find(v);\n    if (i == j)\n      return;\n    id[i] = j;\n    --size;\n  }\n\n  public int getSize() {\n    return size;\n  }\n\n  private int size;\n  private int[] id;\n\n  private int find(int u) {\n    return id[u] == u ? u : (id[u] = find(id[u]));\n  }\n}\n\nclass Solution {\n  public int findCircleNum(int[][] M) {\n    final int n = M.length;\n    UF uf = new UF(n);\n\n    for (int i = 0; i < n; ++i)\n      for (int j = i; j < n; ++j)\n        if (M[i][j] == 1)\n          uf.union(i, j);\n\n    return uf.getSize();\n  }\n}\n"
      }
    },
    "548": {
      "solution": {
        "prefix-sum": "class Solution {\n  public boolean splitArray(int[] nums) {\n    int n = nums.length;\n    if (n < 7)\n      return false;\n\n    int[] prefix = new int[n];\n\n    for (int i = 0; i < n; ++i)\n      prefix[i] = i == 0 ? nums[0] : prefix[i - 1] + nums[i];\n\n    for (int j = 3; j < n - 3; ++j) {\n      HashSet<Integer> seen = new HashSet<>();\n      for (int i = 1; i < j - 1; ++i)\n        if (prefix[i - 1] == prefix[j - 1] - prefix[i])\n          seen.add(prefix[i - 1]);\n      for (int k = j + 2; k < n - 1; ++k)\n        if (prefix[n - 1] - prefix[k] == prefix[k - 1] - prefix[j] &&\n            seen.contains(prefix[k - 1] - prefix[j]))\n          return true;\n    }\n\n    return false;\n  }\n}"
      }
    },
    "549": {
      "solution": {
        "tree": ""
      }
    },
    "550": {
      "solution": {
        "database": ""
      }
    },
    "551": {
      "solution": {
        "string": ""
      }
    },
    "552": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "553": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "554": {
      "solution": {
        "hash-table": ""
      }
    },
    "555": {
      "solution": {
        "greedy": ""
      }
    },
    "556": {
      "solution": {
        "two-pointers": "public class Solution {\n    public int nextGreaterElement(int n) {\n        char[] digits = Integer.toString(n).toCharArray();\n        int length = digits.length;\n\n        int left = length - 2;\n        while (left >= 0 && digits[left] >= digits[left + 1]) {\n            left--;\n        }\n\n        if (left == -1) {\n            return -1; \n        }\n\n        int right = length - 1;\n        while (digits[right] <= digits[left]) {\n            right--;\n        }\n\n        char temp = digits[left];\n        digits[left] = digits[right];\n        digits[right] = temp;\n\n        reverse(digits, left + 1, length - 1);\n        \n        try {\n            long result = Long.parseLong(new String(digits));\n            return (result <= Integer.MAX_VALUE) ? (int) result : -1;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    }\n\n    private void reverse(char[] arr, int start, int end) {\n        while (start < end) {\n            char temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}\n"
      }
    },
    "557": {
      "solution": {
        "two-pointers": ""
      }
    },
    "558": {
      "solution": {
        "tree": ""
      }
    },
    "559": {
      "solution": {
        "tree": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    int maxDepth(Node* root) {\n        if (root == nullptr)\n            return 0;\n\n        int ans = 0;\n\n        for (Node* child : root->children)\n            ans = max(ans, maxDepth(child));\n\n        return 1 + ans;\n    }\n};"
      }
    },
    "560": {
      "solution": {
        "prefix-sum": "import java.util.HashMap;\n\npublic class Solution {\n    public int subarraySum(int[] nums, int k) {\n        HashMap<Integer, Integer> prefixSumMap = new HashMap<>();\n        \n        // Initialize with the base case: prefix sum of 0 appears once\n        prefixSumMap.put(0, 1);\n        \n        int prefixSum = 0;  \n        int count = 0;      \n\n        for (int num : nums) {\n            prefixSum += num;\n            \n            if (prefixSumMap.containsKey(prefixSum - k)) {\n                count += prefixSumMap.get(prefixSum - k);\n            }\n            \n            prefixSumMap.put(prefixSum, prefixSumMap.getOrDefault(prefixSum, 0) + 1);\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, 1, 1};\n        int k = 2;\n        System.out.println(solution.subarraySum(nums, k)); // Output: 2\n    }\n}\n"
      }
    },
    "561": {
      "solution": {
        "counting-sort": "class Solution {\n    public int arrayPairSum(int[] nums) {\n        int maxNum = 10000;\n        int[] count = new int[2 * maxNum + 1];\n\n        for (int num : nums) {\n            count[num + maxNum]++;\n        }\n\n        int sum = 0;\n        boolean add = true;\n        for (int i = 0; i < count.length; i++) {\n            while (count[i] > 0) {\n                if (add) {\n                    sum += i - maxNum;\n                }\n                add = !add;\n                count[i]--;\n            }\n        }\n\n        return sum;\n    }\n}\n"
      }
    },
    "562": {
      "solution": {
        "matrix": "class Solution {\n  public int longestLine(int[][] mat) {\n    final int m = mat.length;\n    final int n = mat[0].length;\n    int ans = 0;\n    // dp[i][j][0] := horizontal  Represents the length of the longest line of consecutive 1s ending at cell (i, j) horizontally.\n    // dp[i][j][1] := vertical\n    // dp[i][j][2] := diagonal\n    // dp[i][j][3] := anti-diagonal\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (mat[i][j] == 1) {\n          dp[i][j][0] = j > 0 ? dp[i][j - 1][0] + 1 : 1;\n          dp[i][j][1] = i > 0 ? dp[i - 1][j][1] + 1 : 1;\n          dp[i][j][2] = (i > 0 && j > 0) ? dp[i - 1][j - 1][2] + 1 : 1;\n          dp[i][j][3] = (i > 0 && j < n - 1) ? dp[i - 1][j + 1][3] + 1 : 1;\n          for (int k = 0; k < 4; ++k)\n            ans = Math.max(ans, dp[i][j][k]);\n        }\n\n    return ans;\n  }\n}"
      }
    },
    "563": {
      "solution": {
        "tree": ""
      }
    },
    "564": {
      "solution": {
        "math": ""
      }
    },
    "565": {
      "solution": {
        "depth-first-search": ""
      }
    },
    "566": {
      "solution": {
        "matrix": "class Solution {\n  public int[][] matrixReshape(int[][] nums, int r, int c) {\n    if (nums.length == 0 || r * c != nums.length * nums[0].length)\n      return nums;\n\n    int[][] ans = new int[r][c];\n    int k = 0;\n\n    for (int[] row : nums)\n      for (int num : row) {\n        ans[k / c][k % c] = num;\n        ++k;\n      }\n\n    return ans;\n  }\n}"
      }
    },
    "567": {
      "solution": {
        "two-pointers": "",
        "sliding-window": "import java.util.Arrays;\n\npublic class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        if (s1.length() > s2.length()) {\n            return false;\n        }\n        \n        int[] countS1 = new int[26];\n        int[] countWindow = new int[26];        \n        for (char c : s1.toCharArray()) {\n            countS1[c - 'a']++;\n        }        \n        for (int i = 0; i < s1.length(); i++) {\n            countWindow[s2.charAt(i) - 'a']++;\n        }        \n        for (int i = 0; i <= s2.length() - s1.length(); i++) {\n            if (Arrays.equals(countS1, countWindow)) {\n                return true;\n            }            \n            if (i + s1.length() < s2.length()) {\n                countWindow[s2.charAt(i) - 'a']--;\n                countWindow[s2.charAt(i + s1.length()) - 'a']++;\n            }\n        }\n        \n        return false;\n    }\n}\n"
      }
    },
    "568": {
      "solution": {
        "matrix": ""
      }
    },
    "569": {
      "solution": {
        "database": ""
      }
    },
    "570": {
      "solution": {
        "database": ""
      }
    },
    "571": {
      "solution": {
        "database": ""
      }
    },
    "572": {
      "solution": {
        "hash-function": ""
      }
    },
    "573": {
      "solution": {
        "math": ""
      }
    },
    "574": {
      "solution": {
        "database": ""
      }
    },
    "575": {
      "solution": {
        "hash-table": ""
      }
    },
    "576": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "577": {
      "solution": {
        "database": ""
      }
    },
    "578": {
      "solution": {
        "database": ""
      }
    },
    "579": {
      "solution": {
        "database": ""
      }
    },
    "580": {
      "solution": {
        "database": ""
      }
    },
    "581": {
      "solution": {
        "two-pointers": "public class Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        int n = nums.length;\n        int left = 0, right = n - 1;\n        \n        while (left < n - 1 && nums[left] <= nums[left + 1]) {\n            left++;\n        }\n        \n        if (left == n - 1) {\n            return 0;\n        }\n        \n        while (right > 0 && nums[right] >= nums[right - 1]) {\n            right--;\n        }\n        \n        int subarrayMin = Integer.MAX_VALUE, subarrayMax = Integer.MIN_VALUE;\n        for (int i = left; i <= right; i++) {\n            subarrayMin = Math.min(subarrayMin, nums[i]);\n            subarrayMax = Math.max(subarrayMax, nums[i]);\n        }\n        \n        while (left > 0 && nums[left - 1] > subarrayMin) {\n            left--;\n        }\n        \n        while (right < n - 1 && nums[right + 1] < subarrayMax) {\n            right++;\n        }\n        \n        return right - left + 1;\n    }\n}\n"
      }
    },
    "582": {
      "solution": {
        "tree": ""
      }
    },
    "583": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "584": {
      "solution": {
        "database": ""
      }
    },
    "585": {
      "solution": {
        "database": ""
      }
    },
    "586": {
      "solution": {
        "database": ""
      }
    },
    "587": {
      "solution": {
        "geometry": "class Solution {\npublic:\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\n        auto cross = [](const vector<int>& O, const vector<int>& A,\n                        const vector<int>& B) -> int {\n            return (A[0] - O[0]) * (B[1] - O[1]) -\n                   (A[1] - O[1]) * (B[0] - O[0]);\n        };\n\n        int n = trees.size();\n        if (n <= 3)\n            return trees; // All points form the convex hull\n\n        // Sort points lexicographically\n        sort(trees.begin(), trees.end());\n\n        vector<vector<int>> hull;\n\n        // Build lower hull\n        for (const auto& point : trees) {\n            while (hull.size() >= 2 &&\n                   cross(hull[hull.size() - 2], hull[hull.size() - 1], point) <\n                       0) {\n                hull.pop_back();\n            }\n            hull.push_back(point);\n        }\n\n        // Build upper hull\n        int lowerSize = hull.size();\n        for (int i = n - 1; i >= 0; --i) {\n            while (hull.size() > lowerSize &&\n                   cross(hull[hull.size() - 2], hull[hull.size() - 1],\n                         trees[i]) < 0) {\n                hull.pop_back();\n            }\n            hull.push_back(trees[i]);\n        }\n\n        hull.pop_back();\n\n        // Remove duplicates\n        sort(hull.begin(), hull.end());\n        hull.erase(unique(hull.begin(), hull.end()), hull.end());\n\n        return hull;\n    }\n};\n"
      }
    },
    "588": {
      "solution": {
        "trie": ""
      }
    },
    "589": {
      "solution": {
        "stack": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\n    public List<Integer> preorder(Node root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) {\n            return result;\n        }\n\n        Stack<Node> stack = new Stack<>();\n        stack.push(root);\n\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            result.add(node.val);\n            for (int i = node.children.size() - 1; i >= 0; i--) {\n                stack.push(node.children.get(i));\n            }\n        }\n\n        return result;\n    }\n}"
      }
    },
    "590": {
      "solution": {
        "stack": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\n    public List<Integer> postorder(Node root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) {\n            return result;\n        }\n\n        Stack<Node> stack = new Stack<>();\n        stack.push(root);\n\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            result.add(0, node.val);\n            for (Node child : node.children) {\n                stack.push(child);\n            }\n        }\n\n        return result;\n    }\n}"
      }
    },
    "591": {
      "solution": {
        "stack": ""
      }
    },
    "592": {
      "solution": {
        "math": ""
      }
    },
    "593": {
      "solution": {
        "geometry": ""
      }
    },
    "594": {
      "solution": {
        "sliding-window": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    public int findLHS(int[] nums) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        int maxLen = 0;\n        \n        for (int num : nums) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        for (int num : frequencyMap.keySet()) {\n            if (frequencyMap.containsKey(num + 1)) {\n                int currentLen = frequencyMap.get(num) + frequencyMap.get(num + 1);\n                maxLen = Math.max(maxLen, currentLen);\n            }\n        }\n        \n        return maxLen;\n    }\n}\n"
      }
    },
    "595": {
      "solution": {
        "database": ""
      }
    },
    "596": {
      "solution": {
        "database": ""
      }
    },
    "597": {
      "solution": {
        "database": ""
      }
    },
    "598": {
      "solution": {
        "math": ""
      }
    },
    "599": {
      "solution": {
        "hash-table": ""
      }
    },
    "600": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "601": {
      "solution": {
        "database": ""
      }
    },
    "602": {
      "solution": {
        "database": ""
      }
    },
    "603": {
      "solution": {
        "database": ""
      }
    },
    "604": {
      "solution": {
        "iterator": "class StringIterator {\n    private List<Node> d = new ArrayList<>();\n    private int p;\n\n    public StringIterator(String compressedString) {\n        int n = compressedString.length();\n        int i = 0;\n        while (i < n) {\n            char c = compressedString.charAt(i);\n            int x = 0;\n            while (++i < n && Character.isDigit(compressedString.charAt(i))) {\n                x = x * 10 + (compressedString.charAt(i) - '0');\n            }\n            d.add(new Node(c, x));\n        }\n    }\n\n    public char next() {\n        if (!hasNext()) {\n            return ' ';\n        }\n        char ans = d.get(p).c;\n        if (--d.get(p).x == 0) {\n            ++p;\n        }\n        return ans;\n    }\n\n    public boolean hasNext() {\n        return p < d.size() && d.get(p).x > 0;\n    }\n}\n\nclass Node {\n    char c;\n    int x;\n\n    Node(char c, int x) {\n        this.c = c;\n        this.x = x;\n    }\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * StringIterator obj = new StringIterator(compressedString);\n * char param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */"
      }
    },
    "605": {
      "solution": {
        "greedy": ""
      }
    },
    "606": {
      "solution": {
        "tree": ""
      }
    },
    "607": {
      "solution": {
        "database": ""
      }
    },
    "608": {
      "solution": {
        "database": ""
      }
    },
    "609": {
      "solution": {
        "hash-table": ""
      }
    },
    "610": {
      "solution": {
        "database": ""
      }
    },
    "611": {
      "solution": {
        "two-pointers": "import java.util.Arrays;\n\npublic class Solution {\n    public int triangleNumber(int[] nums) {\n        Arrays.sort(nums);\n        int count = 0;\n        for (int i = nums.length - 1; i >= 2; i--) {\n            int left = 0, right = i - 1;\n            while (left < right) {\n                if (nums[left] + nums[right] > nums[i]) {\n                    count += right - left;\n                    right--;\n                } else {\n                    left++;\n                }\n            }\n        }\n        return count;\n    }\n}\n"
      }
    },
    "612": {
      "solution": {
        "database": ""
      }
    },
    "613": {
      "solution": {
        "database": ""
      }
    },
    "614": {
      "solution": {
        "database": ""
      }
    },
    "615": {
      "solution": {
        "database": ""
      }
    },
    "616": {
      "solution": {
        "string-matching": ""
      }
    },
    "617": {
      "solution": {
        "tree": ""
      }
    },
    "618": {
      "solution": {
        "database": ""
      }
    },
    "619": {
      "solution": {
        "database": ""
      }
    },
    "620": {
      "solution": {
        "database": ""
      }
    },
    "621": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "622": {
      "solution": {
        "queue": ""
      }
    },
    "623": {
      "solution": {
        "tree": ""
      }
    },
    "624": {
      "solution": {
        "greedy": ""
      }
    },
    "625": {
      "solution": {
        "greedy": ""
      }
    },
    "626": {
      "solution": {
        "database": ""
      }
    },
    "627": {
      "solution": {
        "database": ""
      }
    },
    "628": {
      "solution": {
        "sorting": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maximumProduct(vector<int>& nums) {\n        // Sort the array\n        sort(nums.begin(), nums.end());\n        \n        // The maximum product can be either:\n        // 1. Product of the three largest numbers\n        // 2. Product of the two smallest numbers and the largest number\n        int n = nums.size();\n        return max(nums[n - 1] * nums[n - 2] * nums[n - 3], nums[0] * nums[1] * nums[n - 1]);\n    }\n};\n"
      }
    },
    "629": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "630": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "631": {
      "solution": {
        "matrix": ""
      }
    },
    "632": {
      "solution": {
        "sliding-window": "import java.util.Comparator;\nimport java.util.PriorityQueue;\n\nclass Solution {\n    public int[] smallestRange(List<List<Integer>> nums) {\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(o -> nums.get(o[0]).get(o[1])));\n        int maxElement = Integer.MIN_VALUE;\n        int start = 0, end = Integer.MAX_VALUE;\n        \n        for (int i = 0; i < nums.size(); i++) {\n            minHeap.offer(new int[]{i, 0});\n            maxElement = Math.max(maxElement, nums.get(i).get(0));\n        }\n        \n        while (true) {\n            int[] current = minHeap.poll();\n            int listIdx = current[0];\n            int elementIdx = current[1];            \n            int currentRange = maxElement - nums.get(listIdx).get(elementIdx);            \n            if (currentRange < end - start) {\n                start = nums.get(listIdx).get(elementIdx);\n                end = maxElement;\n            }            \n            elementIdx++;\n            if (elementIdx == nums.get(listIdx).size()) {\n                break;\n            }            \n            minHeap.offer(new int[]{listIdx, elementIdx});\n            maxElement = Math.max(maxElement, nums.get(listIdx).get(elementIdx));\n        }\n        \n        return new int[]{start, end};\n    }\n}\n"
      }
    },
    "633": {
      "solution": {
        "two-pointers": "public class Solution {\n    public boolean judgeSquareSum(int c) {\n        long left = 0;\n        long right = (long) Math.sqrt(c);\n\n        while (left <= right) {\n            long sum = left * left + right * right;\n            if (sum == c) {\n                return true;\n            } else if (sum < c) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n\n        return false;\n    }\n}\n"
      }
    },
    "634": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "635": {
      "solution": {
        "ordered-set": ""
      }
    },
    "636": {
      "solution": {
        "stack": ""
      }
    },
    "637": {
      "solution": {
        "tree": ""
      }
    },
    "638": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "639": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "640": {
      "solution": {
        "math": ""
      }
    },
    "641": {
      "solution": {
        "queue": ""
      }
    },
    "642": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "643": {
      "solution": {
        "sliding-window": "public class Solution {\n    public double findMaxAverage(int[] nums, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; ++i) {\n            sum += nums[i];\n        }\n        \n        double res = sum;\n        \n        for (int i = k; i < nums.length; ++i) {\n            sum += nums[i] - nums[i - k];\n            res = Math.max(res, sum);\n        }\n        \n        return res / k;\n    }\n}\n"
      }
    },
    "644": {
      "solution": {
        "prefix-sum": "class Solution {\n  public double findMaxAverage(int[] nums, int k) {\n    double kErr = 1e-5;\n    double l = (double) Arrays.stream(nums).min().getAsInt();\n    double r = (double) Arrays.stream(nums).max().getAsInt();\n\n    while (r - l > kErr) {\n      double m = (l + r) / 2;\n      if (check(nums, k, m))\n        l = m;\n      else\n        r = m;\n    }\n\n    return l;\n  }\n\n  private boolean check(int[] nums, int k, double m) {\n    double sum = 0;\n    double prevSum = 0;\n    double minPrevSum = 0;\n\n    for (int i = 0; i < nums.length; ++i) {\n      sum += nums[i] - m;\n      if (i >= k) {\n        prevSum += nums[i - k] - m;\n        minPrevSum = Math.min(minPrevSum, prevSum);\n      }\n      if (i + 1 >= k && sum >= minPrevSum)\n        return true;\n    }\n\n    return false;\n  }\n}"
      }
    },
    "645": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "646": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "647": {
      "solution": {
        "two-pointers": "public class Solution {\n    public int countSubstrings(String s) {\n        int n = s.length();\n        int count = 0;\n\n        for (int i = 0; i < n; i++) {\n            count += countPalindromesAroundCenter(s, i, i); // Odd length palindromes\n            count += countPalindromesAroundCenter(s, i, i + 1); // Even length palindromes\n        }\n\n        return count;\n    }\n\n    private int countPalindromesAroundCenter(String s, int left, int right) {\n        int count = 0;\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            count++;\n            left--;\n            right++;\n        }\n        return count;\n    }\n}\n"
      }
    },
    "648": {
      "solution": {
        "trie": ""
      }
    },
    "649": {
      "solution": {
        "queue": ""
      }
    },
    "650": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "651": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "652": {
      "solution": {
        "tree": ""
      }
    },
    "653": {
      "solution": {
        "two-pointers": ""
      }
    },
    "654": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "655": {
      "solution": {
        "tree": ""
      }
    },
    "656": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "657": {
      "solution": {
        "string": ""
      }
    },
    "658": {
      "solution": {
        "two-pointers": "class Solution {\n    public List<Integer> findClosestElements(int[] arr, int k, int x) {\n        int left = 0;\n        int right = arr.length - k;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (x - arr[mid] <= arr[mid + k] - x) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = left; i < left + k; i++) {\n            result.add(arr[i]);\n        }\n\n        return result;\n    }\n}\n"
      }
    },
    "659": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "660": {
      "solution": {
        "math": ""
      }
    },
    "661": {
      "solution": {
        "matrix": ""
      }
    },
    "662": {
      "solution": {
        "tree": ""
      }
    },
    "663": {
      "solution": {
        "tree": ""
      }
    },
    "664": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "665": {
      "solution": {
        "array": ""
      }
    },
    "666": {
      "solution": {
        "tree": ""
      }
    },
    "667": {
      "solution": {
        "math": ""
      }
    },
    "668": {
      "solution": {
        "math": ""
      }
    },
    "669": {
      "solution": {
        "binary-search-tree": ""
      }
    },
    "670": {
      "solution": {
        "greedy": ""
      }
    },
    "671": {
      "solution": {
        "tree": ""
      }
    },
    "672": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "673": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "674": {
      "solution": {
        "array": ""
      }
    },
    "675": {
      "solution": {
        "matrix": ""
      }
    },
    "676": {
      "solution": {
        "trie": ""
      }
    },
    "677": {
      "solution": {
        "trie": ""
      }
    },
    "678": {
      "solution": {
        "stack": ""
      }
    },
    "679": {
      "solution": {
        "backtracking": ""
      }
    },
    "680": {
      "solution": {
        "two-pointers": ""
      }
    },
    "681": {
      "solution": {
        "backtracking": ""
      }
    },
    "682": {
      "solution": {
        "stack": ""
      }
    },
    "683": {
      "solution": {
        "sliding-window": "class Solution {\n    public int kEmptySlots(int[] bulbs, int k) {\n      int n = bulbs.length;\n        int ans = Integer.MAX_VALUE;\n        int[] day = new int[n]; // day[i] will store the day when bulb at position (i+1) is turned on\n\n        for (int i = 0; i < n; ++i)\n            day[bulbs[i] - 1] = i + 1;\n\n        int left = 0;\n        int right = left + k + 1;\n        \n        for (int i = 1; right < n; ++i) {\n            if (i == right) {\n                ans = Math.min(ans, Math.max(day[left], day[right]));\n                left = i;\n                right = i + k + 1;\n            } else if (day[i] < Math.max(day[left], day[right])) {\n                left = i;\n                right = i + k + 1;\n            }\n        }\n\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n    }\n}\n"
      }
    },
    "684": {
      "solution": {
        "union-find": "class Solution {\npublic:\n    vector<int> parent;\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n\n    bool unionSets(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX == rootY) {\n            return false; // Cycle detected\n        }\n        parent[rootX] = rootY; // Union operation\n        return true;\n    }\n\n    vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n        int n = edges.size();\n        parent.resize(n + 1);\n        for (int i = 1; i <= n; ++i) {\n            parent[i] = i;\n        }\n\n        for (const auto& edge : edges) {\n            if (!unionSets(edge[0], edge[1])) {\n                return edge;\n            }\n        }\n        return {};\n    }\n};\n"
      }
    },
    "685": {
      "solution": {
        "union-find": "class UF {\n  public UF(int n) {\n    id = new int[n];\n    for (int i = 0; i < n; ++i)\n      id[i] = i;\n  }\n\n  public boolean union(int u, int v) {\n    final int i = find(u);\n    final int j = find(v);\n    if (i == j)\n      return false;\n    id[i] = j;\n    return true;\n  }\n\n  private int[] id;\n\n  private int find(int u) {\n    return id[u] == u ? u : (id[u] = find(id[u]));\n  }\n}\n\nclass Solution {\n  public int[] findRedundantDirectedConnection(int[][] edges) {\n    int[] ids = new int[edges.length + 1];\n    int nodeWithTwoParents = 0;\n\n    for (int[] edge : edges) {\n      final int v = edge[1];\n      if (++ids[v] == 2) {\n        nodeWithTwoParents = v;\n        break;\n      }\n    }\n\n    if (nodeWithTwoParents == 0)\n      return findRedundantDirectedConnection(edges, -1);\n\n    for (int i = edges.length - 1; i >= 0; --i)\n      if (edges[i][1] == nodeWithTwoParents)\n        if (findRedundantDirectedConnection(edges, i).length == 0)\n          return edges[i];\n\n    throw new IllegalArgumentException();\n  }\n\n  private int[] findRedundantDirectedConnection(int[][] edges, int skippedEdgeIndex) {\n    UF uf = new UF(edges.length + 1);\n\n    for (int i = 0; i < edges.length; ++i) {\n      if (i == skippedEdgeIndex)\n        continue;\n      if (!uf.union(edges[i][0], edges[i][1]))\n        return edges[i];\n    }\n\n    return new int[] {};\n  }\n}\n"
      }
    },
    "686": {
      "solution": {
        "string-matching": "class Solution {\npublic:\n    int repeatedStringMatch(string a, string b) {\n        int repeatCount = 1; \n        string repeatedA = a;\n\n        while (repeatedA.size() < b.size()) {\n            repeatedA += a;\n            repeatCount++;\n        }\n\n        if (repeatedA.find(b) != string::npos) {\n            return repeatCount;\n        }\n\n        repeatedA += a;\n        repeatCount++;\n\n        if (repeatedA.find(b) != string::npos) {\n            return repeatCount;\n        }\n\n        return -1;\n    }\n};\n"
      }
    },
    "687": {
      "solution": {
        "tree": ""
      }
    },
    "688": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "689": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "690": {
      "solution": {
        "tree": ""
      }
    },
    "691": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "692": {
      "solution": {
        "bucket-sort": "import java.util.*;\n\nclass Solution {\n    public List<String> topKFrequent(String[] words, int k) {\n        Map<String, Integer> frequencyMap = new HashMap<>();\n        for (String word : words) {\n            frequencyMap.put(word, frequencyMap.getOrDefault(word, 0) + 1);\n        }\n\n        List<String>[] buckets = new List[words.length + 1];\n        for (String word : frequencyMap.keySet()) {\n            int frequency = frequencyMap.get(word);\n            if (buckets[frequency] == null) {\n                buckets[frequency] = new ArrayList<>();\n            }\n            buckets[frequency].add(word);\n        }\n\n        List<String> result = new ArrayList<>();\n        for (int i = buckets.length - 1; i >= 0 && result.size() < k; i--) {\n            if (buckets[i] != null) {\n                Collections.sort(buckets[i]);\n                result.addAll(buckets[i]);\n            }\n        }\n\n        return result.subList(0, k);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.topKFrequent(new String[]{\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"}, 2)); // Output: [\"i\", \"love\"]\n    }\n}\n",
        "heap-(priority-queue)": "import java.util.*;\n\nclass Solution {\n    public List<String> topKFrequent(String[] words, int k) {\n        Map<String, Integer> frequencyMap = new HashMap<>();\n        for (String word : words) {\n            frequencyMap.put(word, frequencyMap.getOrDefault(word, 0) + 1);\n        }\n\n        PriorityQueue<String> minHeap = new PriorityQueue<>(\n                (a, b) -> frequencyMap.get(a).equals(frequencyMap.get(b))\n                        ? b.compareTo(a)\n                        : frequencyMap.get(a) - frequencyMap.get(b));\n\n        for (String word : frequencyMap.keySet()) {\n            minHeap.offer(word);\n            if (minHeap.size() > k) {\n                minHeap.poll();\n            }\n        }\n\n        List<String> result = new ArrayList<>();\n        while (!minHeap.isEmpty()) {\n            result.add(minHeap.poll());\n        }\n        Collections.reverse(result);\n        return result;\n    }\n}\n"
      }
    },
    "693": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "694": {
      "solution": {
        "union-find": ""
      }
    },
    "695": {
      "solution": {
        "union-find": "",
        "matrix": "class Solution {\n    private final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public int maxAreaOfIsland(int[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\n            return 0;\n        }\n\n        int m = grid.length;\n        int n = grid[0].length;\n        int maxArea = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    int area = dfs(grid, i, j);\n                    maxArea = Math.max(maxArea, area);\n                }\n            }\n        }\n\n        return maxArea;\n    }\n\n    private int dfs(int[][] grid, int i, int j) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {\n            return 0;\n        }\n\n        grid[i][j] = 0;\n        int area = 1;\n\n        for (int[] direction : DIRECTIONS) {\n            int newI = i + direction[0];\n            int newJ = j + direction[1];\n            area += dfs(grid, newI, newJ);\n        }\n\n        return area;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] grid = {\n            {0, 1, 0, 0},\n            {1, 1, 1, 0},\n            {0, 1, 0, 0},\n            {0, 0, 1, 1}\n        };\n\n        int result = solution.maxAreaOfIsland(grid);\n        System.out.println(\"Max Area of Island: \" + result); // Output: 6\n    }\n}\n"
      }
    },
    "696": {
      "solution": {
        "two-pointers": ""
      }
    },
    "697": {
      "solution": {
        "hash-table": ""
      }
    },
    "698": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "699": {
      "solution": {
        "ordered-set": ""
      }
    },
    "700": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if (root == null || root.val == val) {\n            return root;\n        }\n        \n        if (val < root.val) {\n            return searchBST(root.left, val);\n        } else {\n            return searchBST(root.right, val);\n        }\n    }\n}\n"
      }
    },
    "701": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        if (root == null) {\n            return new TreeNode(val);\n        }\n        \n        if (val < root.val) {\n            root.left = insertIntoBST(root.left, val);\n        } else {\n            root.right = insertIntoBST(root.right, val);\n        }\n        \n        return root;\n    }\n}\n"
      }
    },
    "702": {
      "solution": {
        "interactive": ""
      }
    },
    "703": {
      "solution": {
        "binary-search-tree": "import java.util.PriorityQueue;\n\nclass KthLargest {\n    private PriorityQueue<Integer> minHeap;\n    private int k;\n\n    public KthLargest(int k, int[] nums) {\n        this.k = k;\n        this.minHeap = new PriorityQueue<>(k);\n        \n        for (int num : nums) {\n            add(num);\n        }\n    }\n    \n    public int add(int val) {\n        if (minHeap.size() < k) {\n            minHeap.offer(val);\n        } else if (val > minHeap.peek()) {\n            minHeap.poll();\n            minHeap.offer(val);\n        }\n        return minHeap.peek();\n    }\n}\n"
      }
    },
    "704": {
      "solution": {
        "array": "",
        "binary-search": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int low = 0, high = nums.size() - 1;\n\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n\n            if (nums[mid] == target) {\n                return mid; \n            } else if (nums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1; \n            }\n        }\n\n        return -1; \n    }\n};\n"
      }
    },
    "705": {
      "solution": {
        "hash-function": ""
      }
    },
    "706": {
      "solution": {
        "hash-function": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass MyHashMap {\npublic:\n    MyHashMap() {\n        size = 1000;  \n        table.resize(size);  \n    }\n\n    int hash(int key) {\n        return key % size;\n    }\n\n    void put(int key, int value) {\n        int index = hash(key);  \n        for (auto& pair : table[index]) {\n            if (pair.first == key) { \n                pair.second = value;\n                return;\n            }\n        }\n        table[index].push_back({key, value});\n    }\n\n    int get(int key) {\n        int index = hash(key); \n        for (auto& pair : table[index]) {\n            if (pair.first == key) { \n                return pair.second;\n            }\n        }\n        return -1;  \n    }\n\n    void remove(int key) {\n        int index = hash(key); \n        for (auto it = table[index].begin(); it != table[index].end(); ++it) {\n            if (it->first == key) {  \n                table[index].erase(it);\n                return;\n            }\n        }\n    }\n\nprivate:\n    int size; \n    vector<vector<pair<int, int>>> table;  \n};\n\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * MyHashMap obj = new MyHashMap();\n * obj.put(key,value);\n * int param_2 = obj.get(key);\n * obj.remove(key);\n */"
      }
    },
    "707": {
      "solution": {
        "linked-list": ""
      }
    },
    "708": {
      "solution": {
        "linked-list": ""
      }
    },
    "709": {
      "solution": {
        "string": ""
      }
    },
    "710": {
      "solution": {
        "randomized": ""
      }
    },
    "711": {
      "solution": {
        "union-find": ""
      }
    },
    "712": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "713": {
      "solution": {
        "sliding-window": "class Solution {\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\n        if (k <= 1) return 0; /\n        int left = 0;\n        int product = 1;\n        int count = 0;\n        \n        for (int right = 0; right < nums.length; right++) {\n            product *= nums[right];\n            \n            while (product >= k) {\n                product /= nums[left];\n                left++;\n            }\n            \n            count += right - left + 1;\n        }\n        \n        return count;\n    }\n}"
      }
    },
    "714": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "715": {
      "solution": {
        "ordered-set": "",
        "segment-tree": "class Node{\n    public:\n    int l, r;\n    bool state;\n    Node *left = NULL, *right = NULL;\n    Node(int l, int r, bool st) {\n        this->l = l;\n        this->r = r;\n        this->state = st;\n    }\n};\n\nclass RangeModule {\npublic:\n    Node *root;\n\n    RangeModule() {\n        root = new Node(0, 1e9, false);\n    }\n\n    bool update(int l, int r, bool state, Node* root) {\n        if(root->l >= l && root->r <= r) {\n            root->state = state;\n            root->left = NULL;\n            root->right = NULL;\n            return state;\n        }\n        if(l >= root->r || r <= root->l)return root->state;\n\n        int mid = root->l + (root->r - root->l) / 2;\n        if(root->left == NULL) {\n            root->left = new Node(root->l, mid, root->state);\n            root->right = new Node(mid, root->r, root->state);\n        }\n\n        bool left = update(l, r, state, root->left);\n        bool right = update(l, r, state, root->right);\n        root->state = left & right;\n        return root->state;\n    }\n    \n    void addRange(int left, int right) {\n        update(left, right, true, root);\n    }\n\n    bool q(Node *root, int l, int r) {\n        //if(l >= root->r || r <= root->l)return true;\n        if((root->l >= l && root->r <= r) || root->left == NULL)return root->state;\n\n        int mid = root->l + (root->r - root->l) / 2;\n        if(r <= mid){\n            return q(root->left, l, r);\n        }else if(l >= mid){\n            return q(root->right, l, r);\n        }else{\n            return q(root->left, l, r) && q(root->right, l, r);\n        }\n    }\n    \n    bool queryRange(int left, int right) {\n        return q(root, left, right);\n    }\n    \n    void removeRange(int left, int right) {\n        update(left, right, false, root);\n    }\n};\n\n/**\n * Your RangeModule object will be instantiated and called as such:\n * RangeModule* obj = new RangeModule();\n * obj->addRange(left,right);\n * bool param_2 = obj->queryRange(left,right);\n * obj->removeRange(left,right);\n */"
      }
    },
    "716": {
      "solution": {
        "doubly-linked-list": "class Node {\n    public int val;\n    public Node prev, next;\n\n    public Node() {\n    }\n\n    public Node(int val) {\n        this.val = val;\n    }\n}\n\nclass DoubleLinkedList {\n    private final Node head = new Node();\n    private final Node tail = new Node();\n\n    public DoubleLinkedList() {\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public Node append(int val) {\n        Node node = new Node(val);\n        node.next = tail;\n        node.prev = tail.prev;\n        tail.prev = node;\n        node.prev.next = node;\n        return node;\n    }\n\n    public static Node remove(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n        return node;\n    }\n\n    public Node pop() {\n        return remove(tail.prev);\n    }\n\n    public int peek() {\n        return tail.prev.val;\n    }\n}\n\nclass MaxStack {\n    private DoubleLinkedList stack = new DoubleLinkedList();\n    private TreeMap<Integer, List<Node>> map = new TreeMap<>();\n\n    public MaxStack() {\n    }\n\n    public void push(int x) {\n        Node node = stack.append(x);\n        map.computeIfAbsent(x, k -> new ArrayList<>()).add(node);\n    }\n\n    public int pop() {\n        Node node = stack.pop();\n        List<Node> nodes = map.get(node.val);\n        int x = nodes.remove(nodes.size() - 1).val;\n        if (nodes.isEmpty()) {\n            map.remove(node.val);\n        }\n        return x;\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int peekMax() {\n        return map.lastackey();\n    }\n\n    public int popMax() {\n        int x = peekMax();\n        List<Node> nodes = map.get(x);\n        Node node = nodes.remove(nodes.size() - 1);\n        if (nodes.isEmpty()) {\n            map.remove(x);\n        }\n        DoubleLinkedList.remove(node);\n        return x;\n    }\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * MaxStack obj = new MaxStack();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.peekMax();\n * int param_5 = obj.popMax();\n */"
      }
    },
    "717": {
      "solution": {
        "array": ""
      }
    },
    "718": {
      "solution": {
        "sliding-window": "class Solution {\n    public int findLength(int[] A, int[] B) {\n        int m = A.length;\n        int n = B.length;\n        int[][] dp = new int[m + 1][n + 1];\n        int maxLen = 0;\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (A[i - 1] == B[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                    maxLen = Math.max(maxLen, dp[i][j]);\n                } else {\n                    dp[i][j] = 0;\n                }\n            }\n        }\n\n        return maxLen;\n    }\n}\n"
      }
    },
    "719": {
      "solution": {
        "two-pointers": "import java.util.Arrays;\n\npublic class Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        int left = 0;\n        int right = nums[n - 1] - nums[0];\n\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (countPairs(nums, mid) < k) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n\n        return left;\n    }\n\n    private int countPairs(int[] nums, int mid) {\n        int count = 0;\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            int j = i;\n            while (j < n && nums[j] - nums[i] <= mid) {\n                j++;\n            }\n            count += j - i - 1;\n        }\n        return count;\n    }\n}\n"
      }
    },
    "720": {
      "solution": {
        "trie": ""
      }
    },
    "721": {
      "solution": {
        "union-find": "class UF {\n  public UF(List<List<String>> accounts) {\n    for (List<String> account : accounts)\n      for (int i = 1; i < account.size(); ++i) {\n        final String email = account.get(i);\n        id.putIfAbsent(email, email);\n      }\n  }\n\n  public void union(final String u, final String v) {\n    id.put(find(u), find(v));\n  }\n\n  public String find(final String u) {\n    if (u != id.get(u))\n      id.put(u, find(id.get(u)));\n    return id.get(u);\n  }\n\n  private Map<String, String> id = new HashMap<>();\n}\n\nclass Solution {\n  public List<List<String>> accountsMerge(List<List<String>> accounts) {\n    List<List<String>> ans = new ArrayList<>();\n    Map<String, String> emailToName = new HashMap<>();\n    Map<String, TreeSet<String>> idEmailToEmails = new HashMap<>();\n    UF uf = new UF(accounts);\n    for (final List<String> account : accounts)\n      for (int i = 1; i < account.size(); ++i)\n        emailToName.putIfAbsent(account.get(i), account.get(0));\n    for (final List<String> account : accounts)\n      for (int i = 2; i < account.size(); ++i)\n        uf.union(account.get(i), account.get(i - 1));\n\n    for (final List<String> account : accounts)\n      for (int i = 1; i < account.size(); ++i) {\n        final String id = uf.find(account.get(i));\n        idEmailToEmails.putIfAbsent(id, new TreeSet<>());\n        idEmailToEmails.get(id).add(account.get(i));\n      }\n\n    for (final String idEmail : idEmailToEmails.keySet()) {\n      List<String> emails = new ArrayList<>(idEmailToEmails.get(idEmail));\n      final String name = emailToName.get(idEmail);\n      emails.add(0, name);\n      ans.add(emails);\n    }\n\n    return ans;\n  }\n}\n"
      }
    },
    "722": {
      "solution": {
        "string": ""
      }
    },
    "723": {
      "solution": {
        "two-pointers": ""
      }
    },
    "724": {
      "solution": {
        "prefix-sum": "public class Solution {\n    public int pivotIndex(int[] nums) {\n        int totalSum = 0;\n        for (int num : nums) {\n            totalSum += num;\n        }\n\n        int leftSum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            if (leftSum == totalSum - leftSum - nums[i]) {\n                return i;\n            }\n\n            leftSum += nums[i];\n        }\n\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, 7, 3, 6, 5, 6};\n        System.out.println(solution.pivotIndex(nums)); // Output: 3\n    }\n}\n"
      }
    },
    "725": {
      "solution": {
        "linked-list": ""
      }
    },
    "726": {
      "solution": {
        "stack": "class Solution {\n    public String countOfAtoms(String formula) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(formula.charAt(0));\n        char prevC = formula.charAt(0);\n        int length = formula.length();\n        for (int i = 1; i < length; i++) {\n            char c = formula.charAt(i);\n            boolean flag = Character.isLowerCase(c) || Character.isDigit(c) && Character.isDigit(prevC);\n            if (!flag)\n                sb.append(' ');\n            sb.append(c);\n            prevC = c;\n        }\n        String[] array = sb.toString().split(\" \");\n        Stack<String> stack = new Stack<String>();\n        int arrayLength = array.length;\n        for (int i = 0; i < arrayLength; i++) {\n            String str = array[i];\n            if (str.equals(\")\")) {\n                if (i < arrayLength - 1 && Character.isDigit(array[i + 1].charAt(0)))\n                    stack.push(str);\n                else {\n                    Stack<String> tempStack = new Stack<String>();\n                    while (!stack.peek().equals(\"(\"))\n                        tempStack.push(stack.pop());\n                    stack.pop();\n                    while (!tempStack.isEmpty())\n                        stack.push(tempStack.pop());\n                }\n            } else if (Character.isDigit(str.charAt(0))) {\n                int count = Integer.parseInt(str);\n                String prev = stack.pop();\n                if (prev.equals(\")\")) {\n                    Stack<String> tempStack = new Stack<String>();\n                    while (!stack.peek().equals(\"(\")) {\n                        String element = stack.pop();\n                        int index = element.indexOf(',');\n                        if (index >= 0) {\n                            String atom = element.substring(0, index);\n                            int atomCount = Integer.parseInt(element.substring(index + 1)) * count;\n                            tempStack.push(atom + \",\" + atomCount);\n                        } else\n                            tempStack.push(element + \",\" + str);\n                    }\n                    stack.pop();\n                    while (!tempStack.isEmpty())\n                        stack.push(tempStack.pop());\n                } else {\n                    String curStr = prev + \",\" + str;\n                    stack.push(curStr);\n                }\n            } else\n                stack.push(str);\n        }\n        TreeMap<String, Integer> map = new TreeMap<String, Integer>();\n        while (!stack.isEmpty()) {\n            String atomCount = stack.pop();\n            int index = atomCount.indexOf(',');\n            if (index >= 0) {\n                String atom = atomCount.substring(0, index);\n                int count = Integer.parseInt(atomCount.substring(index + 1));\n                count += map.getOrDefault(atom, 0);\n                map.put(atom, count);\n            } else {\n                int count = map.getOrDefault(atomCount, 0) + 1;\n                map.put(atomCount, count);\n            }\n        }\n        StringBuffer output = new StringBuffer();\n        Set<String> keySet = map.keySet();\n        for (String atom : keySet) {\n            int count = map.get(atom);\n            output.append(atom);\n            if (count > 1)\n                output.append(count);\n        }\n        return output.toString();\n    }\n}"
      }
    },
    "727": {
      "solution": {
        "sliding-window": "class Solution {\n  public String minWindow(String s1, String s2) {\n  int m = s2.length();\n  int n = s1.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int j = 0; j <= n; ++j)\n      dp[0][j] = j + 1;\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j)\n        if (s2.charAt(i - 1) == s1.charAt(j - 1))\n          dp[i][j] = dp[i - 1][j - 1];\n        else\n          dp[i][j] = dp[i][j - 1];\n\n    int bestLeft = 0;\n    int minLength = Integer.MAX_VALUE;\n\n    for (int j = 1; j <= n; ++j)\n      if (dp[m][j] > 0 && j - dp[m][j] + 1 < minLength) {\n        bestLeft = dp[m][j] - 1;\n        minLength = j - dp[m][j] + 1;\n      }\n\n    return minLength == Integer.MAX_VALUE ? \"\" : s1.substring(bestLeft, bestLeft + minLength);\n  }\n}"
      }
    },
    "728": {
      "solution": {
        "math": ""
      }
    },
    "729": {
      "solution": {
        "ordered-set": ""
      }
    },
    "730": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "731": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "732": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "733": {
      "solution": {
        "matrix": "class Solution {\n    // Directions: right, down, left, up\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n        int originalColor = image[sr][sc];\n        \n        // If the original color is the same as the new color, no need to proceed\n        if (originalColor != newColor) {\n            dfs(image, sr, sc, newColor, originalColor);\n        }\n        \n        return image;\n    }\n    \n    private void dfs(int[][] image, int i, int j, int newColor, int originalColor) {\n        if (i < 0 || i >= image.length || j < 0 || j >= image[0].length || image[i][j] != originalColor) {\n            return;\n        }\n        \n        image[i][j] = newColor;\n\n        for (int[] direction : DIRECTIONS) {\n            int newRow = i + direction[0];\n            int newCol = j + direction[1];\n            dfs(image, newRow, newCol, newColor, originalColor);\n        }\n    }\n}\n"
      }
    },
    "734": {
      "solution": {
        "hash-table": ""
      }
    },
    "735": {
      "solution": {
        "stack": "// [5,10,-5]\nclass Solution {\n    public int[] asteroidCollision(int[] asteroids) {\n        Stack<Integer> stack = new Stack<>();\n        for (final int a : asteroids)\n            if (a > 0) {\n                stack.push(a);\n            } else {\n                while (!stack.isEmpty() && stack.peek() > 0 && stack.peek() < -a)\n                    stack.pop();\n                if (stack.isEmpty() || stack.peek() < 0)\n                    stack.push(a);\n                else if (stack.peek() == -a)\n                    stack.pop();\n            }\n        int[] ans = new int[stack.size()];\n        for (int i = ans.length - 1; i >= 0; --i)\n            ans[i] = stack.pop();\n        return ans;\n    }\n}\n"
      }
    },
    "736": {
      "solution": {
        "stack": ""
      }
    },
    "737": {
      "solution": {
        "union-find": ""
      }
    },
    "738": {
      "solution": {
        "greedy": ""
      }
    },
    "739": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "740": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "741": {
      "solution": {
        "matrix": "public class Solution {\n    private int[][][] memo;\n\n    public int cherryPickup(int[][] grid) {\n        int n = grid.length;\n        memo = new int[n][n][n];\n        \n        // Initialize memoization array with -2 (uncomputed state)\n        for (int[][] row : memo) {\n            for (int[] col : row) {\n                Arrays.fill(col, -2);\n            }\n        }\n        \n        int result = dfs(grid, 0, 0, 0);\n        \n        return Math.max(0, result);\n    }\n\n    private int dfs(int[][] grid, int r1, int c1, int c2) {\n        int n = grid.length;\n        int r2 = r1 + c1 - c2;\n\n        // Out of bounds or blocked cell\n        if (r1 >= n || c1 >= n || r2 >= n || c2 >= n || grid[r1][c1] == -1 || grid[r2][c2] == -1) {\n            return -1;\n        }\n\n        // Base case: both players reached the bottom-right corner\n        if (r1 == n - 1 && c1 == n - 1) {\n            return grid[r1][c1];\n        }\n\n        // Return previously computed result\n        if (memo[r1][c1][c2] != -2) {\n            return memo[r1][c1][c2];\n        }\n\n        // Pick cherries at current positions\n        int cherries = grid[r1][c1];\n        if (c1 != c2) {\n            cherries += grid[r2][c2]; // Avoid double-counting if they're on the same cell\n        }\n\n        // Try all possible moves for both players\n        int maxCherries = Math.max(\n            Math.max(dfs(grid, r1 + 1, c1, c2 + 1), dfs(grid, r1 + 1, c1, c2)),\n            Math.max(dfs(grid, r1, c1 + 1, c2 + 1), dfs(grid, r1, c1 + 1, c2))\n        );\n\n        // If no valid path found, set to -1; otherwise, add collected cherries\n        if (maxCherries == -1) {\n            memo[r1][c1][c2] = -1;\n        } else {\n            memo[r1][c1][c2] = cherries + maxCherries;\n        }\n\n        return memo[r1][c1][c2];\n    }\n}\n"
      }
    },
    "742": {
      "solution": {
        "tree": ""
      }
    },
    "743": {
      "solution": {
        "shortest-path": "class T {\n  public int u;\n  public int d;\n  public T(int u, int d) {\n    this.u = u;\n    this.d = d;\n  }\n}\n\nclass Solution {\n  public int networkDelayTime(int[][] times, int n, int k) {\n    List<Pair<Integer, Integer>>[] graph = new List[n];\n    PriorityQueue<T> minHeap = new PriorityQueue<>((a, b) -> a.d - b.d);\n    boolean[] seen = new boolean[n];\n\n    for (int i = 0; i < n; ++i)\n      graph[i] = new ArrayList<>();\n\n    for (int[] t : times) {\n      final int u = t[0] - 1;\n      final int v = t[1] - 1;\n      final int w = t[2];\n      graph[u].add(new Pair<>(v, w));\n    }\n\n    minHeap.offer(new T(k - 1, 0));\n\n    while (!minHeap.isEmpty()) {\n      final int u = minHeap.peek().u;\n      final int d = minHeap.poll().d;\n      if (seen[u])\n        continue;\n      seen[u] = true;\n      if (--n == 0)\n        return d;\n      for (var node : graph[u]) {\n        final int v = node.getKey();\n        final int w = node.getValue();\n        minHeap.offer(new T(v, d + w));\n      }\n    }\n\n    return -1;\n  }\n}\n"
      }
    },
    "744": {
      "solution": {
        "array": ""
      }
    },
    "745": {
      "solution": {
        "trie": ""
      }
    },
    "746": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "747": {
      "solution": {
        "sorting": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int dominantIndex(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 1) {\n            return 0; // Single element is always dominant\n        }\n        \n        // Initialize variables to track the largest and second largest numbers\n        int max1 = -1, max2 = -1;\n        int maxIndex = -1;\n        \n        for (int i = 0; i < n; i++) {\n            if (nums[i] > max1) {\n                // Update max1 and max2\n                max2 = max1;\n                max1 = nums[i];\n                maxIndex = i;\n            } else if (nums[i] > max2) {\n                // Update max2\n                max2 = nums[i];\n            }\n        }\n        \n        // Check the dominance condition\n        return (max1 >= 2 * max2) ? maxIndex : -1;\n    }\n};\n"
      }
    },
    "748": {
      "solution": {
        "hash-table": ""
      }
    },
    "749": {
      "solution": {
        "matrix": ""
      }
    },
    "750": {
      "solution": {
        "matrix": ""
      }
    },
    "751": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "752": {
      "solution": {
        "breadth-first-search": ""
      }
    },
    "753": {
      "solution": {
        "eulerian-circuit": "class Solution {\n\n    public String crackSafe(int n, int k) {\n        if (n == 1) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < k; i++) {\n                sb.append(i);\n            }\n            return sb.toString();\n        }\n\n        StringBuilder result = new StringBuilder();\n        Set<String> visited = new HashSet<>();\n        Stack<String> stack = new Stack<>();\n        String start = String.join('', Collections.nCopies(n - 1, '0'));\n        stack.push(start);\n\n        while (!stack.isEmpty()) {\n            String node = stack.peek();\n            boolean hasUnvisitedEdge = false;\n\n            // Try all possible edges from this node by appending each digit from 0 to k-1\n            for (int i = 0; i < k; i++) {\n                String next = node + i;\n                if (!visited.contains(next)) {\n                    visited.add(next);\n                    stack.push(next.substring(1));\n                    hasUnvisitedEdge = true;\n                    break;\n                }\n            }\n\n            // If all edges from this node are visited, backtrack and append the last\n            // character to the result\n            if (!hasUnvisitedEdge) {\n                result.append(stack.pop().charAt(node.length() - 1));\n            }\n        }\n\n        result.append(start.substring(0, start.length() - 1));\n        return result.toString();\n    }\n\n    // public String crackSafe(int n, int k) {\n    // StringBuilder result = new StringBuilder();\n    // Set<String> visited = new HashSet<>();\n    // String start = String.join('', Collections.nCopies(n - 1, '0'));\n    // dfs(start, k, visited, result, n);\n    // result.append(start);\n    // return result.toString();\n    // }\n    // private void dfs(String node, int k, Set<String> visited, StringBuilder\n    // result, int n) {\n    // for (int i = 0; i < k; i++) {\n    // String next = node + i;\n    // if (!visited.contains(next)) {\n    // visited.add(next);\n    // dfs(next.substring(1), k, visited, result, n);\n    // result.append(i);\n    // }\n    // }\n    // }\n\n}"
      }
    },
    "754": {
      "solution": {
        "math": ""
      }
    },
    "755": {
      "solution": {
        "array": ""
      }
    },
    "756": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "757": {
      "solution": {
        "sorting": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\n        // Sort intervals by end point, and by start in descending order if ends are equal\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[1] < b[1] || (a[1] == b[1] && a[0] > b[0]);\n        });\n\n        int count = 0;\n        int largest = -1, secondLargest = -1;\n\n        for (const auto& interval : intervals) {\n            int start = interval[0], end = interval[1];\n\n            // If the current interval does not overlap with the largest and second largest\n            if (largest < start) {\n                count += 2; // Add two elements\n                secondLargest = end - 1; // Second largest is the second-to-last element in the interval\n                largest = end; // Largest is the last element in the interval\n            } else if (secondLargest < start) {\n                count += 1; // Add one element\n                secondLargest = largest; // Update second largest to the previous largest\n                largest = end; // Update largest to the end of the interval\n            }\n        }\n\n        return count;\n    }\n};\n"
      }
    },
    "758": {
      "solution": {
        "string-matching": ""
      }
    },
    "759": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "760": {
      "solution": {
        "hash-table": ""
      }
    },
    "761": {
      "solution": {
        "recursion": ""
      }
    },
    "762": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "763": {
      "solution": {
        "two-pointers": ""
      }
    },
    "764": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "765": {
      "solution": {
        "union-find": ""
      }
    },
    "766": {
      "solution": {
        "matrix": "class Solution {\n  public boolean isToeplitzMatrix(int[][] matrix) {\n    for (int i = 0; i + 1 < matrix.length; ++i)\n      for (int j = 0; j + 1 < matrix[0].length; ++j)\n        if (matrix[i][j] != matrix[i + 1][j + 1])\n          return false;\n    return true;\n  }\n}"
      }
    },
    "767": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "768": {
      "solution": {
        "monotonic-stack": "class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 0; i < n; i++) {\n            int max = arr[i];\n            while (!stack.isEmpty() && stack.peek() > arr[i]) {\n                max = Math.max(max, stack.pop());\n            }\n            stack.push(max);\n        }\n\n        return stack.size();\n    }\n}\n"
      }
    },
    "769": {
      "solution": {
        "monotonic-stack": "public class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int maxChunks = 0;\n        int maxElement = 0;\n\n        for (int i = 0; i < arr.length; i++) {\n            maxElement = Math.max(maxElement, arr[i]);\n            if (maxElement == i) {\n                maxChunks++;\n            }\n        }\n\n        return maxChunks;\n    }\n}\n"
      }
    },
    "770": {
      "solution": {
        "stack": ""
      }
    },
    "771": {
      "solution": {
        "hash-table": ""
      }
    },
    "772": {
      "solution": {
        "stack": ""
      }
    },
    "773": {
      "solution": {
        "matrix": ""
      }
    },
    "774": {
      "solution": {
        "array": ""
      }
    },
    "775": {
      "solution": {
        "math": ""
      }
    },
    "776": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int t;\n\n    public TreeNode[] splitBST(TreeNode root, int target) {\n        t = target;\n        return dfs(root);\n    }\n\n    private TreeNode[] dfs(TreeNode root) {\n        if (root == null) {\n            return new TreeNode[] {null, null};\n        }\n        if (root.val <= t) {\n            TreeNode[] ans = dfs(root.right);\n            root.right = ans[0];\n            ans[0] = root;\n            return ans;\n        } else {\n            TreeNode[] ans = dfs(root.left);\n            root.left = ans[1];\n            ans[1] = root;\n            return ans;\n        }\n    }\n}"
      }
    },
    "777": {
      "solution": {
        "two-pointers": ""
      }
    },
    "778": {
      "solution": {
        "union-find": ""
      }
    },
    "779": {
      "solution": {
        "recursion": "class Solution {\npublic:\n    int kthGrammar(int n, int k) {\n        if (n == 1 && k == 1) {\n            return 0;\n        }\n\n        int mid = (1 << (n - 1)) / 2;\n        if (k <= mid) {\n            return kthGrammar(n - 1, k);\n        } else {\n            return 1 - kthGrammar(n - 1, k - mid);\n        }\n    }\n};\n"
      }
    },
    "780": {
      "solution": {
        "math": ""
      }
    },
    "781": {
      "solution": {
        "greedy": ""
      }
    },
    "782": {
      "solution": {
        "matrix": "class Solution {\n  public int movesToChessboard(int[][] board) {\n    final int n = board.length;\n    int rowSum = 0;\n    int colSum = 0;\n    int rowSwaps = 0;\n    int colSwaps = 0;\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        if ((board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) == 1)\n          return -1;\n\n    for (int i = 0; i < n; ++i) {\n      rowSum += board[0][i];\n      colSum += board[i][0];\n    }\n\n    if (rowSum != n / 2 && rowSum != (n + 1) / 2)\n      return -1;\n    if (colSum != n / 2 && colSum != (n + 1) / 2)\n      return -1;\n\n    for (int i = 0; i < n; ++i) {\n      if (board[i][0] == (i & 1))\n        ++rowSwaps;\n      if (board[0][i] == (i & 1))\n        ++colSwaps;\n    }\n\n    if (n % 2 == 1) {\n      if (rowSwaps % 2 == 1)\n        rowSwaps = n - rowSwaps;\n      if (colSwaps % 2 == 1)\n        colSwaps = n - colSwaps;\n    } else {\n      rowSwaps = Math.min(rowSwaps, n - rowSwaps);\n      colSwaps = Math.min(colSwaps, n - colSwaps);\n    }\n\n    return (rowSwaps + colSwaps) / 2;\n  }\n}"
      }
    },
    "783": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private Integer prev;\n    private int minDiff;\n\n    public int minDiffInBST(TreeNode root) {\n        minDiff = Integer.MAX_VALUE;\n        prev = null;\n        inorder(root);\n        return minDiff;\n    }\n    \n    private void inorder(TreeNode node) {\n        if (node == null) {\n            return;\n        }\n        \n        inorder(node.left);\n        \n        if (prev != null) {\n            minDiff = Math.min(minDiff, node.val - prev);\n        }\n        prev = node.val;\n        \n        inorder(node.right);\n    }\n}\n"
      }
    },
    "784": {
      "solution": {
        "backtracking": "class Solution {\n    public List<String> letterCasePermutation(String S) {\n        List<String> ans = new ArrayList<>();\n        dfs(new StringBuilder(S), 0, ans);\n        return ans;\n    }\n\n    private void dfs(StringBuilder sb, int i, List<String> ans) {\n        if (i == sb.length()) {\n            ans.add(sb.toString());\n            return;\n        }\n        if (Character.isDigit(sb.charAt(i))) {\n            dfs(sb, i + 1, ans);\n            return;\n        }\n        sb.setCharAt(i, Character.toLowerCase(sb.charAt(i)));\n        dfs(sb, i + 1, ans);\n        sb.setCharAt(i, Character.toUpperCase(sb.charAt(i)));\n        dfs(sb, i + 1, ans);\n    }\n}\n"
      }
    },
    "785": {
      "solution": {
        "union-find": ""
      }
    },
    "786": {
      "solution": {
        "heap-(priority-queue)": "import java.util.PriorityQueue;\n\npublic class Solution {\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\n        int n = arr.length;\n        PriorityQueue<Fraction> minHeap = new PriorityQueue<>((a, b) -> Double.compare(a.value, b.value));\n\n        for (int i = 0; i < n - 1; i++) {\n            minHeap.offer(new Fraction(i, n - 1, (double) arr[i] / arr[n - 1]));\n        }\n\n        Fraction fraction = null;\n        for (int i = 0; i < k; i++) {\n            fraction = minHeap.poll();\n            int numeratorIndex = fraction.numeratorIndex;\n            int denominatorIndex = fraction.denominatorIndex;\n            if (denominatorIndex - 1 > numeratorIndex) {\n                minHeap.offer(new Fraction(numeratorIndex, denominatorIndex - 1,\n                        (double) arr[numeratorIndex] / arr[denominatorIndex - 1]));\n            }\n        }\n\n        return new int[] { arr[fraction.numeratorIndex], arr[fraction.denominatorIndex] };\n    }\n\n    private static class Fraction {\n        int numeratorIndex;\n        int denominatorIndex;\n        double value;\n\n        Fraction(int numeratorIndex, int denominatorIndex, double value) {\n            this.numeratorIndex = numeratorIndex;\n            this.denominatorIndex = denominatorIndex;\n            this.value = value;\n        }\n    }\n}\n"
      }
    },
    "787": {
      "solution": {
        "heap-(priority-queue)": "class T {\n  public int u;\n  public int d;\n  public int stops;\n  public T(int u, int d, int stops) {\n    this.u = u;\n    this.d = d;\n    this.stops = stops;\n  }\n}\n\nclass Solution {\n  public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n    List<Pair<Integer, Integer>>[] graph = new List[n];\n    PriorityQueue<T> minHeap = new PriorityQueue<>((a, b) -> a.d - b.d);\n    int[][] dist = new int[n][k + 2];\n    Arrays.stream(dist).forEach(A -> Arrays.fill(A, Integer.MAX_VALUE));\n\n    for (int i = 0; i < n; ++i)\n      graph[i] = new ArrayList<>();\n\n    for (int[] f : flights) {\n      final int u = f[0];\n      final int v = f[1];\n      final int w = f[2];\n      graph[u].add(new Pair<>(v, w));\n    }\n\n    minHeap.offer(new T(src, 0, k + 1));\n    dist[src][k + 1] = 0;\n\n    while (!minHeap.isEmpty()) {\n      final int u = minHeap.peek().u;\n      final int d = minHeap.peek().d;\n      final int stops = minHeap.poll().stops;\n      if (u == dst)\n        return d;\n      if (stops > 0)\n        for (var node : graph[u]) {\n          final int v = node.getKey();\n          final int w = node.getValue();\n          final int newDist = d + w;\n          if (newDist < dist[v][stops - 1]) {\n            dist[v][stops - 1] = newDist;\n            minHeap.offer(new T(v, d + w, stops - 1));\n          }\n        }\n    }\n\n    return -1;\n  }\n}"
      }
    },
    "788": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "789": {
      "solution": {
        "math": ""
      }
    },
    "790": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "791": {
      "solution": {
        "sorting": "#include <string>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    string customSortString(string order, string s) {\n        // Frequency map for characters in `s`\n        unordered_map<char, int> freq;\n        for (char c : s) {\n            freq[c]++;\n        }\n\n        // Build the result string based on `order`\n        string result;\n        for (char c : order) {\n            if (freq.count(c)) {\n                result.append(freq[c], c); // Append `freq[c]` occurrences of `c`\n                freq.erase(c); // Remove character from map\n            }\n        }\n\n        // Append remaining characters (not in `order`)\n        for (auto& [c, count] : freq) {\n            result.append(count, c);\n        }\n\n        return result;\n    }\n};\n"
      }
    },
    "792": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "793": {
      "solution": {
        "math": ""
      }
    },
    "794": {
      "solution": {
        "matrix": "class Solution {\n  public boolean validTicTacToe(String[] board) {\n    final int countX = sum(board, 'X');\n    final int countO = sum(board, 'O');\n\n    if (countX < countO || countX - countO > 1)\n      return false;\n    if (isWinned(board, 'X') && countX == countO ||\n        isWinned(board, 'O') && countX != countO)\n      return false;\n\n    return true;\n  }\n\n  private int sum(final String[] board, char c) {\n    int ans = 0;\n\n    for (String row : board)\n      ans += row.chars().filter(i -> i == c).count();\n\n    return ans;\n  }\n\n  private boolean isWinned(final String[] board, char c) {\n    String[] rotated = rotate(board);\n\n    return Arrays.stream(board).anyMatch(row -> row.chars().filter(i -> i == c).count() == 3)\n        || Arrays.stream(rotated).anyMatch(row -> row.chars().filter(i -> i == c).count() == 3)\n        || board[0].charAt(0) == c && board[1].charAt(1) == c && board[2].charAt(2) == c\n        || board[0].charAt(2) == c && board[1].charAt(1) == c && board[2].charAt(0) == c;\n  }\n\n  private String[] rotate(final String[] board) {\n    String[] rotated = new String[3];\n\n    for (final String row : board)\n      for (int i = 0; i < 3; ++i)\n        rotated[i] += row.charAt(i);\n\n    return rotated;\n  }\n}"
      }
    },
    "795": {
      "solution": {
        "two-pointers": ""
      }
    },
    "796": {
      "solution": {
        "string-matching": "class Solution {\npublic:\n    bool rotateString(string s, string goal) {\n        return s.length() == goal.length() &&\n               (s + s).find(goal) != string::npos;\n    }\n};"
      }
    },
    "797": {
      "solution": {
        "backtracking": ""
      }
    },
    "798": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "799": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "800": {
      "solution": {
        "enumeration": ""
      }
    },
    "801": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "802": {
      "solution": {
        "topological-sort": ""
      }
    },
    "803": {
      "solution": {
        "union-find": ""
      }
    },
    "804": {
      "solution": {
        "hash-table": ""
      }
    },
    "805": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "806": {
      "solution": {
        "string": ""
      }
    },
    "807": {
      "solution": {
        "matrix": ""
      }
    },
    "808": {
      "solution": {
        "probability-and-statistics": "class Solution {\n    public double soupServings(int n) {\n        // If n is large, directly return 1.0 as per problem statement\n        if (n >= 4800) return 1.0;\n        \n        // We need to calculate up to 2 * n\n        int m = n / 25 + (n % 25 == 0 ? 0 : 1);\n        \n        // dp[i][j] represents the probability that Chef A has i ml and Chef B has j ml\n        double[][] dp = new double[m + 1][m + 1];\n        \n        dp[0][0] = 0.5; // Both soups are empty initially\n        for (int i = 1; i <= m; i++) {\n            dp[0][i] = 1.0; // Chef A's soup is empty, Chef A has already lost\n            dp[i][0] = 0.0; // Chef B's soup is empty, Chef A wins\n        }\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= m; j++) {\n                dp[i][j] = 0.25 * (dp[Math.max(0, i - 4)][j] +\n                                   dp[Math.max(0, i - 3)][Math.max(0, j - 1)] +\n                                   dp[Math.max(0, i - 2)][Math.max(0, j - 2)] +\n                                   dp[Math.max(0, i - 1)][Math.max(0, j - 3)]);\n            }\n        }\n        \n        // The probability that both soups are empty at the same time when n ml are consumed in total\n        return dp[m][m];\n    }\n}\n"
      }
    },
    "809": {
      "solution": {
        "two-pointers": ""
      }
    },
    "810": {
      "solution": {
        "brainteaser": ""
      }
    },
    "811": {
      "solution": {
        "counting": ""
      }
    },
    "812": {
      "solution": {
        "geometry": ""
      }
    },
    "813": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "814": {
      "solution": {
        "tree": ""
      }
    },
    "815": {
      "solution": {
        "breadth-first-search": ""
      }
    },
    "816": {
      "solution": {
        "backtracking": ""
      }
    },
    "817": {
      "solution": {
        "linked-list": ""
      }
    },
    "818": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "819": {
      "solution": {
        "counting": ""
      }
    },
    "820": {
      "solution": {
        "trie": ""
      }
    },
    "821": {
      "solution": {
        "two-pointers": ""
      }
    },
    "822": {
      "solution": {
        "hash-table": ""
      }
    },
    "823": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "824": {
      "solution": {
        "string": ""
      }
    },
    "825": {
      "solution": {
        "two-pointers": ""
      }
    },
    "826": {
      "solution": {
        "two-pointers": ""
      }
    },
    "827": {
      "solution": {
        "matrix": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    private int n;\n\n    public int largestIsland(int[][] grid) {\n        n = grid.length;\n        Map<Integer, Integer> islandAreaMap = new HashMap<>();\n        int islandId = 2;  \n        for (int r = 0; r < n; r++) {\n            for (int c = 0; c < n; c++) {\n                if (grid[r][c] == 1) {\n                    int area = dfs(grid, r, c, islandId);\n                    islandAreaMap.put(islandId, area);\n                    islandId++;\n                }\n            }\n        }\n\n        int maxArea = islandAreaMap.values().stream().max(Integer::compare).orElse(0);  // In case all cells are 1s\n\n        for (int r = 0; r < n; r++) {\n            for (int c = 0; c < n; c++) {\n                if (grid[r][c] == 0) {\n                    Set<Integer> neighboringIslands = new HashSet<>();\n                    int potentialArea = 1;  // Start with 1 for the flipped cell\n\n                    for (int[] dir : DIRECTIONS) {\n                        int nr = r + dir[0], nc = c + dir[1];\n                        if (isInBounds(nr, nc) && grid[nr][nc] > 1) {\n                            neighboringIslands.add(grid[nr][nc]);\n                        }\n                    }\n\n                    // Sum the areas of all unique neighboring islands\n                    for (int id : neighboringIslands) {\n                        potentialArea += islandAreaMap.get(id);\n                    }\n\n                    maxArea = Math.max(maxArea, potentialArea);\n                }\n            }\n        }\n\n        return maxArea;\n    }\n\n    private int dfs(int[][] grid, int r, int c, int islandId) {\n        if (!isInBounds(r, c) || grid[r][c] != 1) {\n            return 0;\n        }\n\n        grid[r][c] = islandId;\n        int area = 1;\n\n        for (int[] dir : DIRECTIONS) {\n            area += dfs(grid, r + dir[0], c + dir[1], islandId);\n        }\n\n        return area;\n    }\n\n    private boolean isInBounds(int r, int c) {\n        return r >= 0 && r < n && c >= 0 && c < n;\n    }\n}\n",
        "union-find": ""
      }
    },
    "828": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "829": {
      "solution": {
        "enumeration": ""
      }
    },
    "830": {
      "solution": {
        "string": ""
      }
    },
    "831": {
      "solution": {
        "string": ""
      }
    },
    "832": {
      "solution": {
        "matrix": "class Solution {\n  public int[][] flipAndInvertImage(int[][] A) {\n    int n = A.length;\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < (n + 1) / 2; ++j) {\n        int temp = A[i][j];\n        A[i][j] = A[i][n - j - 1] ^ 1;\n        A[i][n - j - 1] = temp ^ 1;\n      }\n\n    return A;\n  }\n}",
        "two-pointers": ""
      }
    },
    "833": {
      "solution": {
        "sorting": "class Solution {\n  public String findReplaceString(String S, int[] indexes, String[] sources, String[] targets) {\n    List<Pair<Integer, Integer>> sortedIndexes = new ArrayList<>();\n\n    for (int i = 0; i < indexes.length; ++i)\n      sortedIndexes.add(new Pair<>(indexes[i], i));\n\n    Collections.sort(sortedIndexes, (a, b) -> b.getKey() - a.getKey());\n\n    for (var sortedIndex : sortedIndexes) {\n      final int index = sortedIndex.getKey();\n      final int i = sortedIndex.getValue();\n      final String source = sources[i];\n      final String target = targets[i];\n      if (S.substring(index, index + source.length()).equals(source))\n        S = S.substring(0, index) + target + S.substring(index + source.length());\n    }\n\n    return S;\n  }\n}\n"
      }
    },
    "834": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "835": {
      "solution": {
        "matrix": "class Solution {\n  public int largestOverlap(int[][] A, int[][] B) {\n    int n = A.length;\n    int magic = 100;\n    int ans = 0;\n    List<int[]> onesA = new ArrayList<>();\n    List<int[]> onesB = new ArrayList<>();\n    Map<Integer, Integer> map = new HashMap<>();\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j) {\n        if (A[i][j] == 1)\n          onesA.add(new int[] {i, j});\n        if (B[i][j] == 1)\n          onesB.add(new int[] {i, j});\n      }\n\n    for (int[] a : onesA)\n      for (int[] b : onesB) {\n        final int key = (a[0] - b[0]) * magic + a[1] - b[1];\n        map.put(key, map.getOrDefault(key, 0) + 1);\n      }\n\n    for (final int value : map.values())\n      ans = Math.max(ans, value);\n\n    return ans;\n  }\n}\n"
      }
    },
    "836": {
      "solution": {
        "geometry": ""
      }
    },
    "837": {
      "solution": {
        "probability-and-statistics": "class Solution {\n    public double new21Game(int N, int K, int W) {\n        if (K == 0 || N >= K + W) return 1.0;\n        \n        double[] dp = new double[N + 1];\n        double sum = 0.0;\n        dp[0] = 1.0;\n        sum += dp[0];\n        \n        for (int i = 1; i <= N; i++) {\n            dp[i] = sum / W;\n            if (i < K) sum += dp[i];\n            if (i - W >= 0) sum -= dp[i - W];\n        }\n        \n        double probability = 0.0;\n        for (int i = K; i <= N; i++) {\n            probability += dp[i];\n        }\n        \n        return probability;\n    }\n}\n"
      }
    },
    "838": {
      "solution": {
        "two-pointers": ""
      }
    },
    "839": {
      "solution": {
        "union-find": ""
      }
    },
    "840": {
      "solution": {
        "matrix": "public class Solution {\n    public int numMagicSquaresInside(int[][] grid) {\n        int count = 0;\n        \n        for (int r = 0; r < grid.length - 2; r++) {\n            for (int c = 0; c < grid[0].length - 2; c++) {\n                if (isMagicSquare(grid, r, c)) {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    private boolean isMagicSquare(int[][] grid, int r, int c) {\n        if (grid[r + 1][c + 1] != 5) return false;\n\n        boolean[] seen = new boolean[10];\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                int num = grid[r + i][c + j];\n                if (num < 1 || num > 9 || seen[num]) return false;\n                seen[num] = true;\n            }\n        }\n\n        return (grid[r][c] + grid[r][c + 1] + grid[r][c + 2] == 15) &&  // Row 1\n               (grid[r + 1][c] + grid[r + 1][c + 1] + grid[r + 1][c + 2] == 15) &&  // Row 2\n               (grid[r + 2][c] + grid[r + 2][c + 1] + grid[r + 2][c + 2] == 15) &&  // Row 3\n               (grid[r][c] + grid[r + 1][c] + grid[r + 2][c] == 15) &&  // Column 1\n               (grid[r][c + 1] + grid[r + 1][c + 1] + grid[r + 2][c + 1] == 15) &&  // Column 2\n               (grid[r][c + 2] + grid[r + 1][c + 2] + grid[r + 2][c + 2] == 15) &&  // Column 3\n               (grid[r][c] + grid[r + 1][c + 1] + grid[r + 2][c + 2] == 15) &&  // Diagonal 1\n               (grid[r][c + 2] + grid[r + 1][c + 1] + grid[r + 2][c] == 15);    // Diagonal 2\n    }\n}\n"
      }
    },
    "841": {
      "solution": {
        "graph": ""
      }
    },
    "842": {
      "solution": {
        "backtracking": ""
      }
    },
    "843": {
      "solution": {
        "interactive": ""
      }
    },
    "844": {
      "solution": {
        "two-pointers": ""
      }
    },
    "845": {
      "solution": {
        "two-pointers": ""
      }
    },
    "846": {
      "solution": {
        "greedy": ""
      }
    },
    "847": {
      "solution": {
        "bitmask": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nclass Solution {\npublic:\n    int shortestPathLength(vector<vector<int>>& graph) {\n        int n = graph.size();\n        if (n == 1) return 0; // Only one node, no steps needed\n\n        int finalMask = (1 << n) - 1; // All nodes visited\n        queue<tuple<int, int, int>> q; // {node, mask, steps}\n        vector<vector<bool>> visited(n, vector<bool>(1 << n, false));\n\n        for (int i = 0; i < n; ++i) {\n            q.emplace(i, 1 << i, 0);\n            visited[i][1 << i] = true;\n        }\n\n        while (!q.empty()) {\n            auto [node, mask, steps] = q.front();\n            q.pop();\n\n            // If all nodes are visited\n            if (mask == finalMask) return steps;\n\n            for (int neighbor : graph[node]) {\n                int nextMask = mask | (1 << neighbor); // Mark neighbor as visited\n                if (!visited[neighbor][nextMask]) {\n                    visited[neighbor][nextMask] = true;\n                    q.emplace(neighbor, nextMask, steps + 1);\n                }\n            }\n        }\n\n        return -1;\n    }\n};\n"
      }
    },
    "848": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "849": {
      "solution": {
        "array": ""
      }
    },
    "850": {
      "solution": {
        "line-sweep": "class Event {\n  public int x;\n  public int y1;\n  public int y2;\n  public char type;\n  public Event(int x, int y1, int y2, char type) {\n    this.x = x;\n    this.y1 = y1;\n    this.y2 = y2;\n    this.type = type;\n  }\n}\n\nclass Solution {\n  public int rectangleArea(int[][] rectangles) {\n  int kMod = 1_000_000_007;\n    List<Event> events = new ArrayList<>();\n\n    for (int[] right : rectangles) {\n      events.add(new Event(right[0], right[1], right[3], 's'));\n      events.add(new Event(right[2], right[1], right[3], 'e'));\n    }\n\n    Collections.sort(events, (a, b) -> a.x - b.x);\n\n    long ans = 0;\n    int prevX = 0;\n    List<Pair<Integer, Integer>> yPairs = new ArrayList<>();\n\n    for (Event e : events) {\n      if (e.x > prevX) {\n      int width = e.x - prevX;\n        ans = (ans + width * getHeight(yPairs)) % kMod;\n        prevX = e.x;\n      }\n      if (e.type == 's') {\n        yPairs.add(new Pair<>(e.y1, e.y2));\n        Collections.sort(yPairs, Comparator.comparing(Pair::getKey));\n      } else { // type == 'e'\n        yPairs.remove(new Pair<>(e.y1, e.y2));\n      }\n    }\n\n    return (int) (ans % kMod);\n  }\n\n  private long getHeight(List<Pair<Integer, Integer>> yPairs) {\n    int height = 0;\n    int prevY = 0;\n\n    for (Pair<Integer, Integer> pair : yPairs) {\n    int y1 = pair.getKey();\n    int y2 = pair.getValue();\n      prevY = Math.max(prevY, y1);\n      if (y2 > prevY) {\n        height += y2 - prevY;\n        prevY = y2;\n      }\n    }\n\n    return height;\n  }\n}"
      }
    },
    "851": {
      "solution": {
        "topological-sort": ""
      }
    },
    "852": {
      "solution": {
        "array": "",
        "binary-search": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int peakIndexInMountainArray(vector<int>& arr) {\n        int low = 0, high = arr.size() - 1;\n\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n\n            if (arr[mid] < arr[mid + 1]) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n\n        return low; \n    }\n};\n"
      }
    },
    "853": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "854": {
      "solution": {
        "breadth-first-search": ""
      }
    },
    "855": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "856": {
      "solution": {
        "stack": ""
      }
    },
    "857": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "858": {
      "solution": {
        "geometry": ""
      }
    },
    "859": {
      "solution": {
        "hash-table": ""
      }
    },
    "860": {
      "solution": {
        "greedy": ""
      }
    },
    "861": {
      "solution": {
        "matrix": ""
      }
    },
    "862": {
      "solution": {
        "monotonic-queue": "import java.util.Deque;\nimport java.util.LinkedList;\n\npublic class Solution {\n\n    public int shortestSubarray(int[] nums, int K) {\n        int n = nums.length;\n        long[] prefixSum = new long[n + 1];        \n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n        \n        Deque<Integer> deque = new LinkedList<>();\n        int minLength = Integer.MAX_VALUE;\n        \n        for (int i = 0; i <= n; i++) {\n            while (!deque.isEmpty() && prefixSum[i] - prefixSum[deque.peekFirst()] >= K) {\n                minLength = Math.min(minLength, i - deque.pollFirst());\n            }            \n            while (!deque.isEmpty() && prefixSum[i] <= prefixSum[deque.peekLast()]) {\n                deque.pollLast();\n            }\n            \n            deque.addLast(i);\n        }\n        \n        return minLength == Integer.MAX_VALUE ? -1 : minLength;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {2, -1, 2};\n        int K = 3;\n        System.out.println(solution.shortestSubarray(nums, K)); \n    }\n}\n"
      }
    },
    "863": {
      "solution": {
        "tree": ""
      }
    },
    "864": {
      "solution": {
        "matrix": ""
      }
    },
    "865": {
      "solution": {
        "tree": ""
      }
    },
    "866": {
      "solution": {
        "number-theory": ""
      }
    },
    "867": {
      "solution": {
        "matrix": "class Solution {\n    public int[][] transpose(int[][] matrix) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int[][] result = new int[n][m];\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                result[j][i] = matrix[i][j];\n            }\n        }\n\n        return result;\n    }\n}"
      }
    },
    "868": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "869": {
      "solution": {
        "counting": "class Solution {\npublic:\n    string countDigits(int num) {\n        string freq(10, '0');\n        while (num > 0) {\n            ++freq[num % 10];\n            num /= 10;\n        }\n        return freq;\n    }\n\n    bool reorderedPowerOf2(int n) {\n        string targetFreq = countDigits(n);\n\n        for (int i = 0; i < 31; ++i) {\n            int powerOf2 = 1 << i; // Compute 2^i\n            if (countDigits(powerOf2) == targetFreq) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n"
      }
    },
    "870": {
      "solution": {
        "two-pointers": ""
      }
    },
    "871": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "872": {
      "solution": {
        "tree": ""
      }
    },
    "873": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "874": {
      "solution": {
        "hash-table": ""
      }
    },
    "875": {
      "solution": {
        "array": ""
      }
    },
    "876": {
      "solution": {
        "two-pointers": ""
      }
    },
    "877": {
      "solution": {
        "game-theory": "class Solution {\npublic:\n    bool stoneGame(vector<int>& piles) {\n        return true;\n    }\n};\n"
      }
    },
    "878": {
      "solution": {
        "math": ""
      }
    },
    "879": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "880": {
      "solution": {
        "stack": ""
      }
    },
    "881": {
      "solution": {
        "two-pointers": ""
      }
    },
    "882": {
      "solution": {
        "shortest-path": "class Solution {\n  public int reachableNodes(int[][] edges, int maxMoves, int n) {\n    List<Pair<Integer, Integer>>[] graph = new List[n];\n    Queue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]); // (d, u)\n    int[] dist = new int[n];\n    Arrays.fill(dist, maxMoves + 1);\n\n    for (int i = 0; i < n; ++i)\n      graph[i] = new ArrayList<>();\n\n    for (int[] e : edges) {\n      final int u = e[0];\n      final int v = e[1];\n      final int cnt = e[2];\n      graph[u].add(new Pair<>(v, cnt));\n      graph[v].add(new Pair<>(u, cnt));\n    }\n\n    minHeap.offer(new int[] {0, 0});\n    dist[0] = 0;\n\n    while (!minHeap.isEmpty()) {\n      final int d = minHeap.peek()[0];\n      final int u = minHeap.poll()[1];\n      if (d >= maxMoves)\n        break;\n      for (var node : graph[u]) {\n        final int v = node.getKey();\n        final int w = node.getValue();\n        final int newDist = d + w + 1;\n        if (newDist < dist[v]) {\n          dist[v] = newDist;\n          minHeap.offer(new int[] {newDist, v});\n        }\n      }\n    }\n\n    final int reachableNodes = (int) Arrays.stream(dist).filter(d -> d <= maxMoves).count();\n    int reachableSubnodes = 0;\n\n    for (int[] e : edges) {\n      final int u = e[0];\n      final int v = e[1];\n      final int cnt = e[2];\n      final int a = dist[u] > maxMoves ? 0 : Math.min(maxMoves - dist[u], cnt);\n      final int b = dist[v] > maxMoves ? 0 : Math.min(maxMoves - dist[v], cnt);\n      reachableSubnodes += Math.min(a + b, cnt);\n    }\n\n    return reachableNodes + reachableSubnodes;\n  }\n}"
      }
    },
    "883": {
      "solution": {
        "matrix": ""
      }
    },
    "884": {
      "solution": {
        "hash-table": ""
      }
    },
    "885": {
      "solution": {
        "matrix": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    public int[][] spiralMatrixIII(int R, int C, int rStart, int cStart) {\n        // Result array to store the visited cells in spiral order\n        int[][] result = new int[R * C][2];\n        int index = 0; \n        result[index++] = new int[]{rStart, cStart};\n\n        // Variables to track the current position and the number of steps to take in each direction\n        int steps = 1;\n        int r = rStart, c = cStart;\n        \n        // Continue until we have visited all the cells\n        while (index < R * C) {\n            // Loop over directions (right -> down -> left -> up)\n            for (int[] direction : DIRECTIONS) {\n                for (int i = 0; i < steps; i++) {\n                    // Move in the current direction\n                    r += direction[0];\n                    c += direction[1];\n                    \n                    // If the new cell is within bounds, add it to the result\n                    if (r >= 0 && r < R && c >= 0 && c < C) {\n                        result[index++] = new int[]{r, c};\n                    }\n                }\n                // After moving right or left, increase the number of steps\n                if (direction[0] != 0) {\n                    steps++;\n                }\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution spiralMatrix = new Solution();\n        int R = 5, C = 6, rStart = 1, cStart = 4;\n        int[][] result = spiralMatrix.spiralMatrixIII(R, C, rStart, cStart);\n        \n        for (int[] cell : result) {\n            System.out.println(\"[\" + cell[0] + \", \" + cell[1] + \"]\");\n        }\n    }\n}\n"
      }
    },
    "886": {
      "solution": {
        "union-find": ""
      }
    },
    "887": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "888": {
      "solution": {
        "sorting": ""
      }
    },
    "889": {
      "solution": {
        "tree": ""
      }
    },
    "890": {
      "solution": {
        "hash-table": ""
      }
    },
    "891": {
      "solution": {
        "sorting": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int sumSubseqWidths(vector<int>& nums) {\n        const int MOD = 1e9 + 7;\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        \n        // Precompute powers of 2 modulo MOD\n        vector<long long> power(n, 1);\n        for (int i = 1; i < n; ++i) {\n            power[i] = (power[i - 1] * 2) % MOD;\n        }\n        \n        long long result = 0;\n        for (int i = 0; i < n; ++i) {\n            long long add = (power[i] - power[n - i - 1] + MOD) % MOD;\n            result = (result + nums[i] * add % MOD) % MOD;\n        }\n        \n        return result;\n    }\n};\n"
      }
    },
    "892": {
      "solution": {
        "geometry": "class Solution {\npublic:\n    int surfaceArea(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int totalSurfaceArea = 0;\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] > 0) {\n                    // Add the top and bottom surface areas\n                    totalSurfaceArea += 2;\n                    // Add the side areas\n                    totalSurfaceArea += grid[i][j] * 4;\n\n                    // Subtract overlap with the cell above\n                    if (i > 0)\n                        totalSurfaceArea -= 2 * min(grid[i][j], grid[i - 1][j]);\n\n                    // Subtract overlap with the cell to the left\n                    if (j > 0)\n                        totalSurfaceArea -= 2 * min(grid[i][j], grid[i][j - 1]);\n                }\n            }\n        }\n\n        return totalSurfaceArea;\n    }\n};\n"
      }
    },
    "893": {
      "solution": {
        "sorting": ""
      }
    },
    "894": {
      "solution": {
        "memoization": "// n = 7\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n  public List<TreeNode> allPossibleFBT(int n) {\n    if (n % 2 == 0)\n      return new ArrayList<>();\n    if (n == 1)\n      return Arrays.asList(new TreeNode(0));\n    if (memo.containsKey(n))\n      return memo.get(n);\n\n    List<TreeNode> ans = new ArrayList<>();\n\n    for (int leftCount = 0; leftCount < n; ++leftCount) {\n      final int rightCount = n - 1 - leftCount;\n      for (TreeNode left : allPossibleFBT(leftCount))\n        for (TreeNode right : allPossibleFBT(rightCount)) {\n          ans.add(new TreeNode(0));\n          ans.get(ans.size() - 1).left = left;\n          ans.get(ans.size() - 1).right = right;\n        }\n    }\n\n    memo.put(n, ans);\n    return ans;\n  }\n  private Map<Integer, List<TreeNode>> memo = new HashMap<>();\n}"
      }
    },
    "895": {
      "solution": {
        "stack": "class FreqStack {\n  public void push(int val) {\n    count.merge(val, 1, Integer::sum);\n    countToStack.putIfAbsent(count.get(val), new ArrayDeque<>());\n    countToStack.get(count.get(val)).push(val);\n    maxFreq = Math.max(maxFreq, count.get(val));\n  }\n\n  public int pop() {\n    final int val = countToStack.get(maxFreq).pop();\n    count.merge(val, -1, Integer::sum);\n    if (countToStack.get(maxFreq).isEmpty())\n      --maxFreq;\n    return val;\n  }\n\n  private int maxFreq = 0;\n  private Map<Integer, Integer> count = new HashMap<>();\n  private Map<Integer, Deque<Integer>> countToStack = new HashMap<>();\n}\n\n/**\n * Your FreqStack object will be instantiated and called as such:\n * FreqStack obj = new FreqStack();\n * obj.push(val);\n * int param_2 = obj.pop();\n */"
      }
    },
    "896": {
      "solution": {
        "array": ""
      }
    },
    "897": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private TreeNode result;\n\n    public TreeNode increasingBST(TreeNode root) {\n        TreeNode dummy = new TreeNode();\n        result = dummy;\n        inorder(root);\n        return dummy.right;\n    }\n    \n    private void inorder(TreeNode node) {\n        if (node == null) {\n            return;\n        }\n        \n        inorder(node.left);\n        \n        result.right = new TreeNode(node.val);\n        result = result.right;\n        \n        inorder(node.right);\n    }\n}\n"
      }
    },
    "898": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "899": {
      "solution": {
        "sorting": "class Solution {\n public:\n  string orderlyQueue(string s, int k) {\n    if (k > 1) {\n      ranges::sort(s);\n      return s;\n    }\n\n    string ans = s;\n\n    for (int i = 1; i < s.length(); ++i)\n      ans = min(ans, s.substr(i) + s.substr(0, i));\n\n    return ans;\n  }\n};"
      }
    },
    "900": {
      "solution": {
        "iterator": "class RLEIterator {\n    private int[] encoding;\n    private int index;\n\n    public RLEIterator(int[] encoding) {\n        this.encoding = encoding;\n        this.index = 0;\n    }\n\n    public int next(int n) {\n        while (index < encoding.length) {\n            if (n <= encoding[index]) {\n                encoding[index] -= n;\n                return encoding[index + 1];\n            } else {\n                n -= encoding[index];\n                index += 2;\n            }\n        }\n        return -1; \n    }\n}\n\n/**\n * Your RLEIterator object will be instantiated and called as such:\n * RLEIterator obj = new RLEIterator(encoding);\n * int param_1 = obj.next(n);\n */"
      }
    },
    "901": {
      "solution": {
        "monotonic-stack": "import java.util.Stack;\n\nclass StockSpanner {\n    Stack<int[]> stack;\n\n    public StockSpanner() {\n        stack = new Stack<>();\n    }\n\n    public int next(int price) {\n        int span = 1;\n        while (!stack.isEmpty() && stack.peek()[0] <= price) {\n            span += stack.pop()[1];\n        }\n        stack.push(new int[]{price, span});\n        return span;\n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner obj = new StockSpanner();\n * int param_1 = obj.next(price);\n */\n"
      }
    },
    "902": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "903": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "904": {
      "solution": {
        "sliding-window": "class Solution {\n    public int totalFruit(int[] tree) {\n        int maxFruits = 0;\n        int start = 0;\n        Map<Integer, Integer> fruitCount = new HashMap<>();\n        \n        for (int end = 0; end < tree.length; end++) {\n            fruitCount.put(tree[end], fruitCount.getOrDefault(tree[end], 0) + 1);\n            \n            while (fruitCount.size() > 2) {\n                fruitCount.put(tree[start], fruitCount.get(tree[start]) - 1);\n                if (fruitCount.get(tree[start]) == 0) {\n                    fruitCount.remove(tree[start]);\n                }\n                start++;\n            }\n            \n            maxFruits = Math.max(maxFruits, end - start + 1);\n        }\n        \n        return maxFruits;\n    }\n}\n"
      }
    },
    "905": {
      "solution": {
        "two-pointers": ""
      }
    },
    "906": {
      "solution": {
        "enumeration": ""
      }
    },
    "907": {
      "solution": {
        "monotonic-stack": "import java.util.Stack;\n\npublic class Solution {\n    public int sumSubarrayMins(int[] arr) {\n        int MOD = 1_000_000_007;\n        int n = arr.length;\n        \n        Stack<Integer> stack = new Stack<>();        \n        int[] prevLess = new int[n];\n        int[] nextLess = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {\n                stack.pop();\n            }\n            prevLess[i] = stack.isEmpty() ? -1 : stack.peek();\n            stack.push(i);\n        }\n        \n        stack.clear();\n        \n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {\n                stack.pop();\n            }\n            nextLess[i] = stack.isEmpty() ? n : stack.peek();\n            stack.push(i);\n        }\n        \n        long result = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int leftCount = i - prevLess[i];\n            int rightCount = nextLess[i] - i;\n            result = (result + (long) arr[i] * leftCount * rightCount) % MOD;\n        }\n        \n        return (int) result;\n    }\n}\n"
      }
    },
    "908": {
      "solution": {
        "math": ""
      }
    },
    "909": {
      "solution": {
        "matrix": "import java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Solution {\n    public int snakesAndLadders(int[][] board) {\n        int n = board.length;\n        int[] flattenedBoard = new int[n * n];\n        \n        int index = 0;\n        boolean leftToRight = true;\n        for (int i = n - 1; i >= 0; i--) {\n            if (leftToRight) {\n                for (int j = 0; j < n; j++) {\n                    flattenedBoard[index++] = board[i][j];\n                }\n            } else {\n                for (int j = n - 1; j >= 0; j--) {\n                    flattenedBoard[index++] = board[i][j];\n                }\n            }\n            leftToRight = !leftToRight;\n        }\n\n        Queue<Integer> queue = new ArrayDeque<>();\n        boolean[] visited = new boolean[n * n];\n        queue.offer(0);\n        visited[0] = true;\n        int moves = 0;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int current = queue.poll();\n                \n                if (current == n * n - 1) { \n                    return moves;\n                }\n\n                for (int dice = 1; dice <= 6; dice++) {\n                    int next = current + dice;\n                    if (next >= n * n) break; \n                    int destination = flattenedBoard[next] == -1 ? next : flattenedBoard[next] - 1;\n                    if (!visited[destination]) {\n                        visited[destination] = true;\n                        queue.offer(destination);\n                    }\n                }\n            }\n            moves++; \n        }\n\n        return -1; \n    }\n}\n"
      }
    },
    "910": {
      "solution": {
        "sorting": "class Solution {\npublic:\n    int smallestRangeII(vector<int>& nums, int k) {\n        ranges::sort(nums);\n\n        int ans = nums.back() - nums.front();\n        const int left = nums.front() + k;\n        const int right = nums.back() - k;\n\n        for (int i = 0; i + 1 < nums.size(); ++i) {\n            const int mn = min(left, nums[i + 1] - k);\n            const int mx = max(right, nums[i] + k);\n            ans = min(ans, mx - mn);\n        }\n\n        return ans;\n    }\n};"
      }
    },
    "911": {
      "solution": {
        "design": ""
      }
    },
    "912": {
      "solution": {
        "radix-sort": "import java.util.Arrays;\n\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        if (nums == null || nums.length < 2) {\n            return nums;\n        }\n\n        // Find the maximum absolute value to handle negative numbers\n        int max = Arrays.stream(nums).map(Math::abs).max().getAsInt();\n        int exp = 1;\n\n        while (max / exp > 0) {\n            countingSort(nums, exp);\n            exp *= 10;\n        }\n\n        return nums;\n    }\n\n    private void countingSort(int[] nums, int exp) {\n        int n = nums.length;\n        int[] output = new int[n];\n        int[] count = new int[19]; // 19 because the range of values is [-9, 9]\n\n        for (int num : nums) {\n            int index = (num / exp) % 10 + 9; // Shifting by 9 to handle negative numbers\n            count[index]++;\n        }\n\n        for (int i = 1; i < 19; i++) {\n            count[i] += count[i - 1];\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            int index = (nums[i] / exp) % 10 + 9;\n            output[count[index] - 1] = nums[i];\n            count[index]--;\n        }\n\n        System.arraycopy(output, 0, nums, 0, n);\n    }\n}\n",
        "bucket-sort": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        if (nums == null || nums.length == 0) return nums;\n\n        int n = nums.length;\n        int minValue = nums[0];\n        int maxValue = nums[0];\n\n        for (int num : nums) {\n            if (num < minValue) {\n                minValue = num;\n            } else if (num > maxValue) {\n                maxValue = num;\n            }\n        }\n\n        int bucketCount = (maxValue - minValue) / n + 1;\n        List<Integer>[] buckets = new List[bucketCount];\n        for (int i = 0; i < bucketCount; i++) {\n            buckets[i] = new ArrayList<>();\n        }\n\n        for (int num : nums) {\n            int bucketIndex = (num - minValue) / n;\n            buckets[bucketIndex].add(num);\n        }\n\n        int index = 0;\n        for (List<Integer> bucket : buckets) {\n            Collections.sort(bucket);\n            for (int num : bucket) {\n                nums[index++] = num;\n            }\n        }\n\n        return nums;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {5, 2, 9, 1, 5, 6};\n        int[] sorted = solution.sortArray(nums);\n        for (int num : sorted) {\n            System.out.print(num + \" \");\n        }\n        // Output: 1 2 5 5 6 9\n    }\n}\n",
        "merge-sort": "class Solution {\n    public int[] sortArray(int[] nums) {\n        mergeSort(nums, 0, nums.length - 1);\n        return nums;\n    }\n    \n    private void mergeSort(int[] nums, int left, int right) {\n        if (left < right) {\n            int mid = left + (right - left) / 2;\n            mergeSort(nums, left, mid);\n            mergeSort(nums, mid + 1, right);\n            merge(nums, left, mid, right);\n        }\n    }\n    \n    private void merge(int[] nums, int left, int mid, int right) {\n        int n1 = mid - left + 1;\n        int n2 = right - mid;\n        \n        int[] leftArr = new int[n1];\n        int[] rightArr = new int[n2];\n        \n        for (int i = 0; i < n1; i++) {\n            leftArr[i] = nums[left + i];\n        }\n        \n        for (int j = 0; j < n2; j++) {\n            rightArr[j] = nums[mid + 1 + j];\n        }\n        \n        int i = 0, j = 0, k = left;\n        \n        while (i < n1 && j < n2) {\n            if (leftArr[i] <= rightArr[j]) {\n                nums[k++] = leftArr[i++];\n            } else {\n                nums[k++] = rightArr[j++];\n            }\n        }\n        \n        while (i < n1) {\n            nums[k++] = leftArr[i++];\n        }\n        \n        while (j < n2) {\n            nums[k++] = rightArr[j++];\n        }\n    }\n}\n"
      }
    },
    "913": {
      "solution": {
        "topological-sort": "// Input: graph = [[1,3],[0],[3],[0,2]]\n\nclass Solution {\n\n    public static final int HOLE = 0, MOUSE_START = 1, CAT_START = 2;\n    public static final int MOUSE_TURN = 0, CAT_TURN = 1;\n    public static final int MOUSE_WIN = 1, CAT_WIN = 2, UNKNOWN = 0;\n\n    public int catMouseGame(int[][] graph) {\n\n        int n = graph.length;\n        int[][][] degrees = new int[n][n][2];\n        int[][][] results = new int[n][n][2];\n        Queue<int[]> queue = new ArrayDeque<>();\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                degrees[i][j][MOUSE_TURN] = graph[i].length;\n                degrees[i][j][CAT_TURN] = graph[j].length;\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j : graph[HOLE]) {\n                degrees[i][j][CAT_TURN]--;\n            }\n        }\n\n        for (int i = 1; i < n; i++) {\n            results[i][i][MOUSE_TURN] = CAT_WIN;\n            results[i][i][CAT_TURN] = CAT_WIN;\n            queue.offer(new int[] { i, i, MOUSE_TURN });\n            queue.offer(new int[] { i, i, CAT_TURN });\n        }\n\n        for (int j = 1; j < n; j++) {\n            results[0][j][MOUSE_TURN] = MOUSE_WIN;\n            results[0][j][CAT_TURN] = MOUSE_WIN;\n            queue.offer(new int[] { 0, j, MOUSE_TURN });\n            queue.offer(new int[] { 0, j, CAT_TURN });\n        }\n\n        while (!queue.isEmpty()) {\n            int[] state = queue.poll();\n            int Mouse = state[0], Cat = state[1], turn = state[2];\n            int result = results[Mouse][Cat][turn];\n            List<int[]> prevStates = getPrevStates(Mouse, Cat, turn, graph);\n\n            for (int[] prevState : prevStates) {\n                int prevMouse = prevState[0], prevCat = prevState[1], prevTurn = prevState[2];\n\n                if (results[prevMouse][prevCat][prevTurn] == UNKNOWN) {\n                    boolean winState = (result == MOUSE_WIN && prevTurn == MOUSE_TURN)\n                            || (result == CAT_WIN && prevTurn == CAT_TURN);\n\n                    if (winState) {\n                        results[prevMouse][prevCat][prevTurn] = result;\n                        queue.offer(new int[] { prevMouse, prevCat, prevTurn });\n                    } else {\n                        degrees[prevMouse][prevCat][prevTurn]--;\n\n                        if (degrees[prevMouse][prevCat][prevTurn] == 0) {\n                            results[prevMouse][prevCat][prevTurn] = result;\n                            queue.offer(new int[] { prevMouse, prevCat, prevTurn });\n                        }\n                    }\n                }\n            }\n        }\n\n        return results[MOUSE_START][CAT_START][MOUSE_TURN];\n    }\n\n    private List<int[]> getPrevStates(int Mouse, int Cat, int turn, int[][] graph) {\n        List<int[]> prevStates = new ArrayList<>();\n        int prevTurn = turn == MOUSE_TURN ? CAT_TURN : MOUSE_TURN;\n\n        if (prevTurn == CAT_TURN) {\n            for (int prevCat : graph[Cat]) {\n                if (prevCat != HOLE) {\n                    prevStates.add(new int[] { Mouse, prevCat, prevTurn });\n                }\n            }\n        } else {\n            for (int prevMouse : graph[Mouse]) {\n                prevStates.add(new int[] { prevMouse, Cat, prevTurn });\n            }\n        }\n\n        return prevStates;\n    }\n\n}"
      }
    },
    "914": {
      "solution": {
        "number-theory": ""
      }
    },
    "915": {
      "solution": {
        "array": ""
      }
    },
    "916": {
      "solution": {
        "hash-table": ""
      }
    },
    "917": {
      "solution": {
        "two-pointers": ""
      }
    },
    "918": {
      "solution": {
        "monotonic-queue": "import java.util.Deque;\nimport java.util.LinkedList;\n\npublic class Solution {\n    public int maxSubarraySumCircular(int[] nums) {\n        int n = nums.length;\n        int[] extendedNums = new int[2 * n];        \n        System.arraycopy(nums, 0, extendedNums, 0, n);\n        System.arraycopy(nums, 0, extendedNums, n, n);        \n        long[] prefixSum = new long[2 * n + 1];\n        for (int i = 0; i < 2 * n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + extendedNums[i];\n        }\n        \n        Deque<Integer> deque = new LinkedList<>();\n        deque.add(0);\n        int maxSum = Integer.MIN_VALUE;\n        \n        for (int i = 1; i <= 2 * n; i++) {\n            if (deque.peekFirst() < i - n) {\n                deque.pollFirst();\n            }            \n            maxSum = Math.max(maxSum, (int)(prefixSum[i] - prefixSum[deque.peekFirst()]));\n            \n            // Maintain the deque's monotonic property\n            while (!deque.isEmpty() && prefixSum[i] <= prefixSum[deque.peekLast()]) {\n                deque.pollLast();\n            }\n            \n            deque.addLast(i);\n        }\n        \n        return maxSum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, -2, 3, -2};\n        System.out.println(solution.maxSubarraySumCircular(nums));  // Output: 3\n    }\n}\n"
      }
    },
    "919": {
      "solution": {
        "tree": ""
      }
    },
    "920": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "921": {
      "solution": {
        "stack": ""
      }
    },
    "922": {
      "solution": {
        "sorting": "class Solution {\npublic:\n    vector<int> sortArrayByParityII(vector<int>& nums) {\n        int n = nums.size();\n        int evenIdx = 0, oddIdx = 1; // Pointers for even and odd indices\n\n        while (evenIdx < n && oddIdx < n) {\n            // Find the first mispositioned even index\n            while (evenIdx < n && nums[evenIdx] % 2 == 0) {\n                evenIdx += 2;\n            }\n\n            // Find the first mispositioned odd index\n            while (oddIdx < n && nums[oddIdx] % 2 == 1) {\n                oddIdx += 2;\n            }\n\n            // Swap the mispositioned elements\n            if (evenIdx < n && oddIdx < n) {\n                swap(nums[evenIdx], nums[oddIdx]);\n            }\n        }\n\n        return nums;\n    }\n};\n"
      }
    },
    "923": {
      "solution": {
        "two-pointers": "import java.util.Arrays;\n\npublic class Solution {\n    public int threeSumMulti(int[] arr, int target) {\n        int MOD = 1_000_000_007;\n        Arrays.sort(arr);\n        int n = arr.length;\n        long result = 0;\n\n        for (int left = 0; left < n; left++) {\n            int T = target - arr[left];\n            int right = left + 1, k = n - 1;\n            while (right < k) {\n                if (arr[right] + arr[k] < T) {\n                    right++;\n                } else if (arr[right] + arr[k] > T) {\n                    k--;\n                } else if (arr[right] != arr[k]) {\n                    int leftCount = 1, rightCount = 1;\n                    while (right + 1 < k && arr[right] == arr[right + 1]) {\n                        leftCount++;\n                        right++;\n                    }\n                    while (k - 1 > right && arr[k] == arr[k - 1]) {\n                        rightCount++;\n                        k--;\n                    }\n                    result += leftCount * rightCount;\n                    result %= MOD;\n                    right++;\n                    k--;\n                } else {\n                    result += (k - right + 1) * (k - right) / 2;\n                    result %= MOD;\n                    break;\n                }\n            }\n        }\n\n        return (int) result;\n    }\n}\n"
      }
    },
    "924": {
      "solution": {
        "union-find": "// Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\nclass UF {\n    public UF(int n) {\n        id = new int[n];\n        for (int i = 0; i < n; ++i)\n            id[i] = i;\n    }\n\n    public void union(int u, int v) {\n        id[find(u)] = find(v);\n    }\n\n    public int find(int u) {\n        return id[u] == u ? u : (id[u] = find(id[u]));\n    }\n\n    private int[] id;\n}\n\nclass Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        final int n = graph.length;\n        UF uf = new UF(n);\n        int[] ufSize = new int[n];\n        int[] malwareCount = new int[n];\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                if (graph[i][j] == 1)\n                    uf.union(i, j);\n        for (int i = 0; i < n; ++i)\n            ++ufSize[uf.find(i)];\n        for (final int i : initial)\n            ++malwareCount[uf.find(i)];\n        Arrays.sort(initial);\n        int ans = initial[0];\n        int maxUfSize = 0;\n        for (final int i : initial) {\n            final int id = uf.find(i);\n            if (ufSize[id] > maxUfSize && malwareCount[id] == 1) {\n                maxUfSize = ufSize[id];\n                ans = i;\n            }\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "925": {
      "solution": {
        "two-pointers": ""
      }
    },
    "926": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "927": {
      "solution": {
        "math": ""
      }
    },
    "928": {
      "solution": {
        "union-find": ""
      }
    },
    "929": {
      "solution": {
        "hash-table": ""
      }
    },
    "930": {
      "solution": {
        "sliding-window": "class Solution {\n    public int numSubarraysWithSum(int[] nums, int goal) {\n        Map<Integer, Integer> prefixSumCount = new HashMap<>();\n        prefixSumCount.put(0, 1);\n        int prefixSum = 0;\n        int count = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n            int currentSum = prefixSum - goal;\n            if (prefixSumCount.containsKey(currentSum)) {\n                count += prefixSumCount.get(currentSum);\n            }\n            prefixSumCount.put(prefixSum, prefixSumCount.getOrDefault(prefixSum, 0) + 1);\n        }\n\n        return count;\n    }\n}\n"
      }
    },
    "931": {
      "solution": {
        "matrix": ""
      }
    },
    "932": {
      "solution": {
        "divide-and-conquer": ""
      }
    },
    "933": {
      "solution": {
        "queue": ""
      }
    },
    "934": {
      "solution": {
        "breadth-first-search": "class Solution {\npublic:\n    vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    void dfsMarkIsland(vector<vector<int>>& grid, int x, int y,\n                       queue<pair<int, int>>& q) {\n        int n = grid.size();\n        if (x < 0 || y < 0 || x >= n || y >= n || grid[x][y] != 1)\n            return;\n\n        grid[x][y] = 2;\n        q.push({x, y});\n\n        for (auto dir : directions) {\n            dfsMarkIsland(grid, x + dir[0], y + dir[1], q);\n        }\n    }\n\n    int shortestBridge(vector<vector<int>>& grid) {\n        int n = grid.size();\n        queue<pair<int, int>> q;\n\n        bool found = false;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    dfsMarkIsland(grid, i, j, q);\n                    found = true;\n                    break;\n                }\n            }\n            if (found)\n                break;\n        }\n\n        int steps = 0;\n        while (!q.empty()) {\n            int size = q.size();\n            for (int i = 0; i < size; ++i) {\n                auto [x, y] = q.front();\n                q.pop();\n\n                for (auto dir : directions) {\n                    int nx = x + dir[0];\n                    int ny = y + dir[1];\n\n                    if (nx < 0 || ny < 0 || nx >= n || ny >= n)\n                        continue;\n\n                    if (grid[nx][ny] == 1) {\n                        return steps;\n                    }\n\n                    if (grid[nx][ny] == 0) {\n                        grid[nx][ny] = 2;\n                        q.push({nx, ny});\n                    }\n                }\n            }\n            ++steps;\n        }\n\n        return -1;\n    }\n};\n"
      }
    },
    "935": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "936": {
      "solution": {
        "queue": ""
      }
    },
    "937": {
      "solution": {
        "sorting": ""
      }
    },
    "938": {
      "solution": {
        "binary-search-tree": ""
      }
    },
    "939": {
      "solution": {
        "geometry": ""
      }
    },
    "940": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "941": {
      "solution": {
        "array": ""
      }
    },
    "942": {
      "solution": {
        "two-pointers": ""
      }
    },
    "943": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "944": {
      "solution": {
        "string": ""
      }
    },
    "945": {
      "solution": {
        "counting": ""
      }
    },
    "946": {
      "solution": {
        "stack": ""
      }
    },
    "947": {
      "solution": {
        "union-find": ""
      }
    },
    "948": {
      "solution": {
        "two-pointers": ""
      }
    },
    "949": {
      "solution": {
        "enumeration": ""
      }
    },
    "950": {
      "solution": {
        "queue": ""
      }
    },
    "951": {
      "solution": {
        "tree": ""
      }
    },
    "952": {
      "solution": {
        "union-find": ""
      }
    },
    "953": {
      "solution": {
        "hash-table": ""
      }
    },
    "954": {
      "solution": {
        "greedy": ""
      }
    },
    "955": {
      "solution": {
        "greedy": ""
      }
    },
    "956": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "957": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "958": {
      "solution": {
        "tree": ""
      }
    },
    "959": {
      "solution": {
        "union-find": ""
      }
    },
    "960": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "961": {
      "solution": {
        "hash-table": ""
      }
    },
    "962": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "963": {
      "solution": {
        "geometry": "class Solution {\npublic:\n    double minAreaFreeRect(vector<vector<int>>& points) {\n        long ans = LONG_MAX;\n        // For each A, B pair points, {hash(A, B): (ax, ay, bx, by)}.\n        unordered_map<int, vector<tuple<int, int, int, int>>> centerToPoints;\n\n        for (const vector<int>& A : points)\n            for (const vector<int>& B : points) {\n                const int center = hash(A, B);\n                centerToPoints[center].emplace_back(A[0], A[1], B[0], B[1]);\n            }\n\n        // For all pair points \"that share the same center\".\n        for (const auto& [_, points] : centerToPoints)\n            for (const auto& [ax, ay, bx, by] : points)\n                for (const auto& [cx, cy, dx, dy] : points)\n                    // AC is perpendicular to AD.\n                    // AC dot AD = (cx - ax, cy - ay) dot (dx - ax, dy - ay) ==\n                    // 0.\n                    if ((cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0) {\n                        const long squaredArea =\n                            dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy);\n                        if (squaredArea > 0)\n                            ans = min(ans, squaredArea);\n                    }\n\n        return ans == LONG_MAX ? 0 : sqrt(ans);\n    }\n\nprivate:\n    int hash(const vector<int>& p, const vector<int>& q) {\n        return ((long)(p[0] + q[0]) << 16) + (p[1] + q[1]);\n    }\n\n    long dist(int px, int py, int qx, int qy) {\n        return (px - qx) * (px - qx) + (py - qy) * (py - qy);\n    }\n};"
      }
    },
    "964": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "965": {
      "solution": {
        "tree": ""
      }
    },
    "966": {
      "solution": {
        "hash-table": ""
      }
    },
    "967": {
      "solution": {
        "backtracking": ""
      }
    },
    "968": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "969": {
      "solution": {
        "two-pointers": ""
      }
    },
    "970": {
      "solution": {
        "enumeration": ""
      }
    },
    "971": {
      "solution": {
        "tree": ""
      }
    },
    "972": {
      "solution": {
        "math": ""
      }
    },
    "973": {
      "solution": {
        "quickselect": "import java.util.*;\n\npublic class Solution {\n    public int[][] kClosest(int[][] points, int k) {\n        int left = 0, right = points.length - 1;\n        while (left <= right) {\n            int pivotIndex = partition(points, left, right);\n            if (pivotIndex == k - 1) {\n                break;\n            } else if (pivotIndex < k - 1) {\n                left = pivotIndex + 1;\n            } else {\n                right = pivotIndex - 1;\n            }\n        }\n        \n        int[][] result = new int[k][2];\n        for (int i = 0; i < k; i++) {\n            result[i] = points[i];\n        }\n        \n        return result;\n    }\n    \n    private int partition(int[][] points, int left, int right) {\n        int pivotIndex = left + (right - left) / 2;\n        int[] pivot = points[pivotIndex];\n        int pivotDist = distance(pivot);\n        swap(points, pivotIndex, right);\n        int storeIndex = left;\n        for (int i = left; i < right; i++) {\n            if (distance(points[i]) < pivotDist) {\n                swap(points, storeIndex++, i);\n            }\n        }\n        swap(points, storeIndex, right);\n        return storeIndex;\n    }\n    \n    private int distance(int[] point) {\n        return point[0] * point[0] + point[1] * point[1];\n    }\n    \n    private void swap(int[][] points, int i, int j) {\n        int[] temp = points[i];\n        points[i] = points[j];\n        points[j] = temp;\n    }\n}\n",
        "heap-(priority-queue)": "import java.util.*;\n\npublic class Solution {\n    public int[][] kClosest(int[][] points, int k) {\n        // Step 1: Calculate distances and store in a max heap (priority queue)\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> distance(b) - distance(a));\n        \n        for (int[] point : points) {\n            maxHeap.offer(point);\n            if (maxHeap.size() > k) {\n                maxHeap.poll(); // Maintain heap size k by removing the farthest point\n            }\n        }\n        \n        // Step 2: Convert max heap to result array\n        int[][] result = new int[k][2];\n        int index = 0;\n        while (!maxHeap.isEmpty()) {\n            result[index++] = maxHeap.poll();\n        }\n        \n        return result;\n    }\n    \n    // Helper method to calculate distance from origin (0, 0)\n    private int distance(int[] point) {\n        return point[0] * point[0] + point[1] * point[1];\n    }\n}\n"
      }
    },
    "974": {
      "solution": {
        "prefix-sum": "import java.util.HashMap;\n\npublic class Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        HashMap<Integer, Integer> countMap = new HashMap<>();        \n        countMap.put(0, 1);\n\n        int prefixSum = 0;\n        int count = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n            int remainder = (prefixSum % k + k) % k;\n            count += countMap.getOrDefault(remainder, 0);\n            countMap.put(remainder, countMap.getOrDefault(remainder, 0) + 1);\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {23, 2, 4, 6, 7};\n        int k = 6;\n        System.out.println(solution.subarraysDivByK(nums, k)); // Output: 4\n    }\n}\n"
      }
    },
    "975": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "976": {
      "solution": {
        "greedy": ""
      }
    },
    "977": {
      "solution": {
        "two-pointers": "import java.util.Arrays;\n\npublic class Solution {\n    public int[] sortedSquares(int[] nums) {\n        int n = nums.length;\n        int[] result = new int[n];\n        int left = 0, right = n - 1;\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (Math.abs(nums[left]) > Math.abs(nums[right])) {\n                result[i] = nums[left] * nums[left];\n                left++;\n            } else {\n                result[i] = nums[right] * nums[right];\n                right--;\n            }\n        }\n\n        return result;\n    }\n}\n"
      }
    },
    "978": {
      "solution": {
        "sliding-window": "class Solution {\n    public int maxTurbulenceSize(int[] arr) {\n        int ans = 1;\n        int increasing = 1;\n        int decreasing = 1;\n\n        for (int i = 1; i < arr.length; ++i) {\n            if (arr[i] > arr[i - 1]) {\n                increasing = decreasing + 1;\n                decreasing = 1;\n            } else if (arr[i] < arr[i - 1]) {\n                decreasing = increasing + 1;\n                increasing = 1;\n            } else {\n                increasing = 1;\n                decreasing = 1;\n            }\n            ans = Math.max(ans, Math.max(increasing, decreasing));\n        }\n\n        return ans;\n    }\n}\n"
      }
    },
    "979": {
      "solution": {
        "tree": ""
      }
    },
    "980": {
      "solution": {
        "matrix": "public class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    private int emptyCells = 0;\n    private int uniquePaths = 0;\n\n    public int uniquePathsIII(int[][] grid) {\n        int startRow = 0, startCol = 0;\n        \n        for (int r = 0; r < grid.length; r++) {\n            for (int c = 0; c < grid[0].length; c++) {\n                if (grid[r][c] == 1) {  \n                    startRow = r;\n                    startCol = c;\n                }\n                if (grid[r][c] != -1) {  \n                    emptyCells++;\n                }\n            }\n        }\n        \n        dfs(grid, startRow, startCol, 1);  \n        return uniquePaths;\n    }\n\n    private void dfs(int[][] grid, int row, int col, int visitedCells) {\n        if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] == -1) {\n            return;\n        }\n        \n        if (grid[row][col] == 2) {\n            if (visitedCells == emptyCells) {\n                uniquePaths++;\n            }\n            return;\n        }\n        \n        int temp = grid[row][col];\n        grid[row][col] = -1;  \n\n        for (int[] direction : DIRECTIONS) {\n            int newRow = row + direction[0];\n            int newCol = col + direction[1];\n            dfs(grid, newRow, newCol, visitedCells + 1);\n        }\n        \n        grid[row][col] = temp;\n    }\n}\n"
      }
    },
    "981": {
      "solution": {
        "design": ""
      }
    },
    "982": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "983": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "984": {
      "solution": {
        "greedy": ""
      }
    },
    "985": {
      "solution": {
        "array": ""
      }
    },
    "986": {
      "solution": {
        "two-pointers": ""
      }
    },
    "987": {
      "solution": {
        "tree": ""
      }
    },
    "988": {
      "solution": {
        "tree": ""
      }
    },
    "989": {
      "solution": {
        "math": ""
      }
    },
    "990": {
      "solution": {
        "union-find": ""
      }
    },
    "991": {
      "solution": {
        "greedy": ""
      }
    },
    "992": {
      "solution": {
        "sliding-window": "class Solution {\n    public int subarraysWithKDistinct(int[] nums, int k) {\n        return atMostackDistinct(nums, k) - atMostackDistinct(nums, k - 1);\n    }\n    \n    private int atMostackDistinct(int[] nums, int k) {\n        int n = nums.length;\n        int left = 0;\n        int count = 0;\n        Map<Integer, Integer> frequency = new HashMap<>();\n        int distinctCount = 0;\n        \n        for (int right = 0; right < n; right++) {\n            int num = nums[right];\n            if (frequency.getOrDefault(num, 0) == 0) {\n                distinctCount++;\n            }\n            frequency.put(num, frequency.getOrDefault(num, 0) + 1);\n            \n            while (distinctCount > k) {\n                int leftNum = nums[left++];\n                frequency.put(leftNum, frequency.get(leftNum) - 1);\n                if (frequency.get(leftNum) == 0) {\n                    distinctCount--;\n                }\n            }\n            \n            count += right - left + 1;\n        }\n        \n        return count;\n    }\n}\n"
      }
    },
    "993": {
      "solution": {
        "tree": ""
      }
    },
    "994": {
      "solution": {
        "matrix": ""
      }
    },
    "995": {
      "solution": {
        "sliding-window": "public class Solution {\n    public int minKBitFlips(int[] nums, int k) {\n        int ans = 0;\n        int flippedTime = 0;\n        int left = 0;\n        for (int right = 0; right < nums.length; ++right) {\n            if (right >= k && nums[right - k] == 2)\n                --flippedTime;\n\n            if (flippedTime % 2 == nums[right]) {\n                if (right + k > nums.length)\n                    return -1;\n                ++ans;\n                ++flippedTime;\n                nums[right] = 2;\n            }\n        }\n\n        return ans;\n    }\n}\n"
      }
    },
    "996": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "997": {
      "solution": {
        "graph": ""
      }
    },
    "998": {
      "solution": {
        "tree": ""
      }
    },
    "999": {
      "solution": {
        "matrix": ""
      }
    },
    "1000": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1001": {
      "solution": {
        "hash-table": ""
      }
    },
    "1002": {
      "solution": {
        "hash-table": ""
      }
    },
    "1003": {
      "solution": {
        "stack": ""
      }
    },
    "1004": {
      "solution": {
        "sliding-window": "public class Solution {\n    public int longestOnes(int[] nums, int k) {\n        int left = 0;\n        int right = 0;\n        int maxOnes = 0;\n        int zerosCount = 0;\n\n        for (right = 0; right < nums.length; right++) {\n            if (nums[right] == 0) {\n                zerosCount++;\n            }\n\n            while (zerosCount > k) {\n                if (nums[left] == 0) {\n                    zerosCount--;\n                }\n                left++;\n            }\n\n            maxOnes = Math.max(maxOnes, right - left + 1);\n        }\n\n        return maxOnes;\n    }\n\n// /**\n//  * @param {number[]} nums\n//  * @param {number} k\n//  * @return {number}\n//  */\n// var longestOnes = function(nums, k) {\n//     let ans = 0;\n//     for (let l = 0, r = 0; r < nums.length; ++r) {\n//         if (nums[r] == 0)\n//             --k;\n//         while (k < 0)\n//             if (nums[l++] == 0)\n//                 ++k;\n//         ans = Math.max(ans, r - l + 1);\n//     }\n//     return ans;\n// };\n// console.log(longestOnes([1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0], 2))\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0};\n        int k = 2;\n        System.out.println(solution.longestOnes(nums, k)); // Output: 6\n    }\n}"
      }
    },
    "1005": {
      "solution": {
        "sorting": "#include <algorithm> // for sort, min\n#include <numeric>   // for accumulate\n#include <ranges>    // for ranges::sort\n#include <vector>\n\nclass Solution {\npublic:\n    int largestSumAfterKNegations(std::vector<int>& nums, int k) {\n        std::ranges::sort(nums); // Sort in ascending order\n\n        // Negate negative numbers\n        for (int i = 0; i < nums.size(); ++i) {\n            if (nums[i] > 0 || k == 0)\n                break;\n            nums[i] = -nums[i];\n            --k;\n        }\n\n        // Calculate the sum and handle remaining k\n        return std::accumulate(nums.begin(), nums.end(), 0) -\n               (k % 2) * std::ranges::min(nums) * 2;\n    }\n};\n"
      }
    },
    "1006": {
      "solution": {
        "stack": ""
      }
    },
    "1007": {
      "solution": {
        "greedy": ""
      }
    },
    "1008": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int index = 0;\n\n    public TreeNode bstFromPreorder(int[] preorder) {\n        return bstFromPreorder(preorder, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n    \n    private TreeNode bstFromPreorder(int[] preorder, int lower, int upper) {\n        if (index == preorder.length || preorder[index] < lower || preorder[index] > upper) {\n            return null;\n        }\n        \n        int val = preorder[index++];\n        TreeNode root = new TreeNode(val);\n        root.left = bstFromPreorder(preorder, lower, val - 1);\n        root.right = bstFromPreorder(preorder, val + 1, upper);\n        \n        return root;\n    }\n}\n"
      }
    },
    "1009": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "1010": {
      "solution": {
        "counting": ""
      }
    },
    "1011": {
      "solution": {
        "array": ""
      }
    },
    "1012": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1013": {
      "solution": {
        "greedy": ""
      }
    },
    "1014": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1015": {
      "solution": {
        "math": ""
      }
    },
    "1016": {
      "solution": {
        "string": ""
      }
    },
    "1017": {
      "solution": {
        "math": ""
      }
    },
    "1018": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "1019": {
      "solution": {
        "monotonic-stack": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public int[] nextLargerNodes(ListNode head) {\n        List<Integer> nums = new ArrayList<>();\n        for (; head != null; head = head.next) {\n            nums.add(head.val);\n        }\n        Deque<Integer> stack = new ArrayDeque<>();\n        int n = nums.size();\n        int[] ans = new int[n];\n        for (int i = n - 1; i >= 0; --i) {\n            while (!stack.isEmpty() && stack.peek() <= nums.get(i)) {\n                stack.pop();\n            }\n            if (!stack.isEmpty()) {\n                ans[i] = stack.peek();\n            }\n            stack.push(nums.get(i));\n        }\n        return ans;\n    }\n}"
      }
    },
    "1020": {
      "solution": {
        "union-find": ""
      }
    },
    "1021": {
      "solution": {
        "stack": ""
      }
    },
    "1022": {
      "solution": {
        "tree": ""
      }
    },
    "1023": {
      "solution": {
        "string-matching": "class Solution {\npublic:\n    vector<bool> camelMatch(vector<string>& queries, string pattern) {\n        vector<bool> result;\n\n        auto matches = [](const string& query, const string& pattern) {\n            int i = 0, j = 0;\n            int n = query.size(), m = pattern.size();\n\n            while (i < n && j < m) {\n                if (query[i] == pattern[j]) {\n                    i++;\n                    j++;\n                }\n                // If the characters match, continue\n                else if (isupper(query[i])) {\n                    return false; // Query has an uppercase letter where pattern\n                                  // has a lowercase or doesn't match\n                } else {\n                    i++;\n                }\n            }\n\n            // After traversal, check if the rest of pattern is fully matched\n            if (j == m) {\n                // Check that the remaining query is entirely lowercase (as\n                // pattern ends with lowercase or uppercase)\n                while (i < n) {\n                    if (isupper(query[i])) {\n                        return false;\n                    }\n                    i++;\n                }\n                return true;\n            }\n            return false;\n        };\n\n        for (const string& query : queries) {\n            result.push_back(matches(query, pattern));\n        }\n\n        return result;\n    }\n};\n"
      }
    },
    "1024": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1025": {
      "solution": {
        "brainteaser": ""
      }
    },
    "1026": {
      "solution": {
        "tree": ""
      }
    },
    "1027": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1028": {
      "solution": {
        "tree": ""
      }
    },
    "1029": {
      "solution": {
        "sorting": "class Solution {\npublic:\n    int twoCitySchedCost(vector<vector<int>>& costs) {\n        const int n = costs.size() / 2;\n        int ans = 0;\n\n        // How much money can we save if we fly a person to A instead of B?\n        // To save money, we should\n        //   1. Fly the person with the maximum saving to A.\n        //   2. Fly the person with the minimum saving to B.\n\n        // Sort `costs` in ascending order by the money saved if we fly a person\n        // to B instead of A.\n        ranges::sort(costs, ranges::less{},\n                     [](const vector<int>& cost) { return cost[0] - cost[1]; });\n\n        for (int i = 0; i < n; ++i)\n            ans += costs[i][0] + costs[i + n][1];\n\n        return ans;\n    }\n};"
      }
    },
    "1030": {
      "solution": {
        "matrix": ""
      }
    },
    "1031": {
      "solution": {
        "sliding-window": "public class Solution {\n    public int maxSumTwoNoOverlap(int[] nums, int L, int M) {\n        int n = nums.length;\n        int[] prefixSum = new int[n + 1];\n        \n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n        \n        int maxL = 0, maxM = 0, result = 0;\n        \n        for (int i = L + M; i <= n; i++) {\n            maxL = Math.max(maxL, prefixSum[i - M] - prefixSum[i - M - L]);\n            maxM = Math.max(maxM, prefixSum[i - L] - prefixSum[i - L - M]);\n            result = Math.max(result, Math.max(maxL + prefixSum[i] - prefixSum[i - M], maxM + prefixSum[i] - prefixSum[i - L]));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {0, 6, 5, 2, 2, 5, 1, 9, 4};\n        int L = 1;\n        int M = 2;\n        System.out.println(solution.maxSumTwoNoOverlap(nums, L, M)); // Output: 20\n    }\n}\n"
      }
    },
    "1032": {
      "solution": {
        "data-stream": ""
      }
    },
    "1033": {
      "solution": {
        "brainteaser": ""
      }
    },
    "1034": {
      "solution": {
        "matrix": ""
      }
    },
    "1035": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1036": {
      "solution": {
        "breadth-first-search": ""
      }
    },
    "1037": {
      "solution": {
        "geometry": ""
      }
    },
    "1038": {
      "solution": {
        "binary-search-tree": ""
      }
    },
    "1039": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1040": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1041": {
      "solution": {
        "math": ""
      }
    },
    "1042": {
      "solution": {
        "graph": ""
      }
    },
    "1043": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1044": {
      "solution": {
        "suffix-array": "import java.util.Arrays;\n\npublic class Solution {\n\n    public String longestDupSubstring(String s) {\n        int n = s.length();\n        int[] suffixArray = buildSuffixArray(s);\n        int[] lcpArray = buildLCPArray(suffixArray, s);\n\n        int pos = -1, maxLen = 0;\n        for (int i = 0; i < n - 1; i++) {\n            if (lcpArray[i] > maxLen) {\n                maxLen = lcpArray[i];\n                pos = suffixArray[i];\n            }\n        }\n\n        return pos == -1 ? \"\" : s.substring(pos, pos + maxLen);\n    }\n\n    private int[] buildSuffixArray(String S) {\n        int n = S.length();\n        Integer[] order = new Integer[n];\n        for (int i = 0; i < n; i++)\n            order[i] = n - 1 - i;\n\n        Arrays.sort(order, (a, b) -> Character.compare(S.charAt(a), S.charAt(b)));\n\n        int[] suffixArray = new int[n];\n        int[] classes = new int[n];\n        for (int i = 0; i < n; i++) {\n            suffixArray[i] = order[i];\n            classes[i] = S.charAt(i);\n        }\n\n        for (int len = 1; len < n; len *= 2) {\n            int[] c = classes.clone();\n            for (int i = 0; i < n; i++) {\n                classes[suffixArray[i]] = i > 0 && c[suffixArray[i - 1]] == c[suffixArray[i]] && suffixArray[i - 1] + len < n\n                        && c[suffixArray[i - 1] + len / 2] == c[suffixArray[i] + len / 2] ? classes[suffixArray[i - 1]] : i;\n            }\n\n            int[] count = new int[n];\n            for (int i = 0; i < n; i++)\n                count[i] = i;\n            int[] s = suffixArray.clone();\n            for (int i = 0; i < n; i++) {\n                int s1 = s[i] - len;\n                if (s1 >= 0)\n                    suffixArray[count[classes[s1]]++] = s1;\n            }\n        }\n\n        return suffixArray;\n    }\n\n    private int[] buildLCPArray(int[] suffixArray, String s) {\n        int n = suffixArray.length;\n        int[] rank = new int[n];\n        for (int i = 0; i < n; i++)\n            rank[suffixArray[i]] = i;\n        int[] lcpArray = new int[n - 1];\n        for (int i = 0, h = 0; i < n; i++) {\n            if (rank[i] < n - 1) {\n                int j = suffixArray[rank[i] + 1];\n                while (i + h < n && j + h < n && s.charAt(i + h) == s.charAt(j + h)) {\n                    h++;\n                }\n                lcpArray[rank[i]] = h;\n                if (h > 0) {\n                    h--;\n                }\n            }\n        }\n        return lcpArray;\n    }\n}\n",
        "rolling-hash": "class Solution {\n    public String longestDupSubstring(String s) {\n        int kMod = 1_000_000_007;\n        int n = s.length();\n        int[] pows = new int[n];\n        int bestStart = -1;\n        int left = 1;\n        int right = n;\n\n        pows[0] = 1;\n        for (int i = 1; i < n; ++i)\n            pows[i] = (int) ((pows[i - 1] * 26L) % (long) kMod);\n\n        while (left < right) {\n            int mid = (left + right) / 2;\n            int start = getStart(s, mid, pows, kMod);\n            if (start == -1) {\n                right = mid;\n            } else {\n                bestStart = start;\n                left = mid + 1;\n            }\n        }\n\n        if (bestStart == -1)\n            return \"\";\n        if (getStart(s, left, pows, kMod) == -1)\n            return s.substring(bestStart, bestStart + left - 1);\n        return s.substring(bestStart, bestStart + left);\n    }\n\n    private int getStart(String s, int k, int[] pows, int kMod) {\n        Map<Long, List<Integer>> hashToStarts = new HashMap<>();\n        long hash = 0;\n\n        for (int i = 0; i < k; ++i)\n            hash = ((hash * 26) % kMod + val(s.charAt(i))) % kMod;\n        hashToStarts.put(hash, new ArrayList<>());\n        hashToStarts.get(hash).add(0);\n\n        for (int i = k; i < s.length(); ++i) {\n            int startIndex = i - k + 1;\n            hash = ((hash - (long) (pows[k - 1]) * val(s.charAt(i - k))) % kMod + kMod) % kMod;\n            hash = (hash * 26 + val(s.charAt(i))) % kMod;\n            if (hashToStarts.containsKey(hash)) {\n                String currSub = s.substring(startIndex, startIndex + k);\n                for (int start : hashToStarts.get(hash))\n                    if (s.substring(start, start + k).equals(currSub))\n                        return startIndex;\n            }\n            hashToStarts.put(hash, new ArrayList<>());\n            hashToStarts.get(hash).add(startIndex);\n        }\n\n        return -1;\n    }\n\n    private int val(char c) {\n        return c - 'a';\n    }\n}"
      }
    },
    "1045": {
      "solution": {
        "database": ""
      }
    },
    "1046": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1047": {
      "solution": {
        "stack": ""
      }
    },
    "1048": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1049": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1050": {
      "solution": {
        "database": ""
      }
    },
    "1051": {
      "solution": {
        "counting-sort": "class Solution {\n    public int heightChecker(int[] heights) {\n        int maxNum = 100; // As the problem states that heights are between 1 and 100\n        int[] count = new int[maxNum + 1];\n        \n        for (int height : heights) {\n            count[height]++;\n        }\n        \n        int[] sortedHeights = new int[heights.length];\n        int index = 0;\n        for (int i = 1; i <= maxNum; i++) {\n            while (count[i] > 0) {\n                sortedHeights[index++] = i;\n                count[i]--;\n            }\n        }\n        \n        // Count the number of heights that are out of place\n        int result = 0;\n        for (int i = 0; i < heights.length; i++) {\n            if (heights[i] != sortedHeights[i]) {\n                result++;\n            }\n        }\n        \n        return result;\n    }\n}\n"
      }
    },
    "1052": {
      "solution": {
        "sliding-window": "public class Solution {\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\n        int n = customers.length;\n        int totalSatisfied = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (grumpy[i] == 0) {\n                totalSatisfied += customers[i];\n            }\n        }\n\n        int maxAdditionalSatisfied = 0;\n        int currentAdditionalSatisfied = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (grumpy[i] == 1) {\n                currentAdditionalSatisfied += customers[i];\n            }\n            if (i >= X) {\n                if (grumpy[i - X] == 1) {\n                    currentAdditionalSatisfied -= customers[i - X];\n                }\n            }\n\n            maxAdditionalSatisfied = Math.max(maxAdditionalSatisfied, currentAdditionalSatisfied);\n        }\n\n        return totalSatisfied + maxAdditionalSatisfied;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] customers = {1, 0, 1, 2, 1, 1, 7, 5};\n        int[] grumpy = {0, 1, 0, 1, 0, 1, 0, 1};\n        int X = 3;\n        System.out.println(solution.maxSatisfied(customers, grumpy, X)); \n    }\n}\n"
      }
    },
    "1053": {
      "solution": {
        "greedy": ""
      }
    },
    "1054": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1055": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1056": {
      "solution": {
        "math": ""
      }
    },
    "1057": {
      "solution": {
        "greedy": ""
      }
    },
    "1058": {
      "solution": {
        "greedy": ""
      }
    },
    "1059": {
      "solution": {
        "topological-sort": "import java.util.List;\n\nclass Solution {\n    private List<Integer>[] g;\n    private int[] f;\n    private boolean[] vis;\n    private int k;\n\n    public boolean leadsToDestination(int n, int[][] edges, int source, int destination) {\n        Set<Integer>[] graph = new Set[n]; // node => set of its next nodes\n\n        for (int i = 0; i < n; i++) {\n            graph[i] = new HashSet<Integer>();\n        }\n\n        int[] inDegrees = new int[n];\n        for (int[] edge : edges) {\n            graph[edge[0]].add(edge[1]);\n            inDegrees[edge[1]]++;\n        }\n\n        LinkedList<Integer> q = new LinkedList<Integer>();\n        q.add(source);\n\n        while (!q.isEmpty()) {\n            int cur = q.poll();\n            if (graph[cur].size() == 0 && cur != destination) {\n                return false;\n            }\n\n            for (int nei : graph[cur]) {\n                if (inDegrees[nei] < 0) {\n                    return false;\n                }\n\n                inDegrees[nei]--;\n\n                q.add(nei);\n            }\n        }\n\n        return true;\n    }\n}"
      }
    },
    "1060": {
      "solution": {
        "array": ""
      }
    },
    "1061": {
      "solution": {
        "union-find": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\nprivate:\n    vector<int> parent;\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unionSets(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rootX < rootY) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootX] = rootY;\n            }\n        }\n    }\n\npublic:\n    string smallestEquivalentString(string s1, string s2, string baseStr) {\n        parent.resize(26);\n        for (int i = 0; i < 26; ++i) {\n            parent[i] = i; \n        }\n\n        for (int i = 0; i < s1.size(); ++i) {\n            unionSets(s1[i] - 'a', s2[i] - 'a');\n        }\n\n        string result;\n        for (char c : baseStr) {\n            result += (find(c - 'a') + 'a');\n        }\n        return result;\n    }\n};\n"
      }
    },
    "1062": {
      "solution": {
        "suffix-array": "import java.util.*;\n\npublic class Solution {\n    public String longestRepeatingSubstring(String s) {\n        int n = s.length();\n        int[] suffixArray = buildSuffixArray(s);\n        int[] lcpArray = buildLCPArray(s, suffixArray);\n        \n        int left = 1, right = n;\n        int maxLength = 0;\n        String result = \"\";\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (hasRepeatedSubstring(mid, n, suffixArray, lcpArray)) {\n                maxLength = mid;\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        for (int i = 0; i <= n - maxLength; i++) {\n            String candidate = s.substring(suffixArray[i], suffixArray[i] + maxLength);\n            if (hasRepeatedSubstring(candidate, s, maxLength)) {\n                return candidate;\n            }\n        }\n        \n        return result;\n    }\n    \n    private boolean hasRepeatedSubstring(int len, int n, int[] suffixArray, int[] lcpArray) {\n        for (int i = 1; i < n; i++) {\n            if (lcpArray[i] >= len) {\n                int start1 = suffixArray[i - 1];\n                int start2 = suffixArray[i];\n                if ((start1 < n - len && start2 > n - len) || (start1 > n - len && start2 < n - len)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    private boolean hasRepeatedSubstring(String candidate, String s, int len) {\n        int count = 0;\n        int index = s.indexOf(candidate);\n        while (index != -1) {\n            count++;\n            index = s.indexOf(candidate, index + 1);\n        }\n        return count > 1;\n    }\n    \n    private int[] buildSuffixArray(String s) {\n        int n = s.length();\n        Integer[] order = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            order[i] = i;\n        }\n        \n        Arrays.sort(order, (a, b) -> Character.compare(s.charAt(a), s.charAt(b)));\n        \n        int[] suffixArray = new int[n];\n        int[] classes = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            suffixArray[i] = order[i];\n            classes[i] = s.charAt(i);\n        }\n        \n        for (int len = 1; len < n; len *= 2) {\n            int[] c = classes.clone();\n            for (int i = 0; i < n; i++) {\n                classes[suffixArray[i]] = i > 0 && c[suffixArray[i - 1]] == c[suffixArray[i]] && suffixArray[i - 1] + len < n\n                        && c[suffixArray[i - 1] + len / 2] == c[suffixArray[i] + len / 2] ? classes[suffixArray[i - 1]] : i;\n            }\n            \n            int[] count = new int[n];\n            for (int i = 0; i < n; i++) {\n                count[i] = i;\n            }\n            \n            int[] s = suffixArray.clone();\n            for (int i = 0; i < n; i++) {\n                int s1 = s[i] - len;\n                if (s1 >= 0) {\n                    suffixArray[count[classes[s1]]++] = s1;\n                }\n            }\n        }\n        \n        return suffixArray;\n    }\n    \n    private int[] buildLCPArray(String s, int[] suffixArray) {\n        int n = s.length();\n        int[] rank = new int[n];\n        for (int i = 0; i < n; i++) {\n            rank[suffixArray[i]] = i;\n        }\n        \n        int[] lcpArray = new int[n - 1];\n        int h = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (rank[i] > 0) {\n                int j = suffixArray[rank[i] - 1];\n                while (i + h < n && j + h < n && s.charAt(i + h) == s.charAt(j + h)) {\n                    h++;\n                }\n                lcpArray[rank[i] - 1] = h;\n                if (h > 0) {\n                    h--;\n                }\n            }\n        }\n        \n        return lcpArray;\n    }\n}\n",
        "dynamic-programming": "class Solution {\n    public int longestRepeatingSubstring(String s) {\n        int n = s.length();\n        int ans = 0;\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (s.charAt(i) == s.charAt(j)) {\n                    dp[i][j] = i > 0 ? dp[i - 1][j - 1] + 1 : 1;\n                    ans = Math.max(ans, dp[i][j]);\n                }\n            }\n        }\n        return ans;\n    }\n}"
      }
    },
    "1063": {
      "solution": {
        "monotonic-stack": "class Solution {\n    public int validSubarrays(int[] nums) {\n        int n = nums.length;\n        int[] right = new int[n];\n        Arrays.fill(right, n);\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = n - 1; i >= 0; --i) {\n            while (!stack.isEmpty() && nums[stack.peek()] >= nums[i]) {\n                stack.pop();\n            }\n            if (!stack.isEmpty()) {\n                right[i] = stack.peek();\n            }\n            stack.push(i);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans += right[i] - i;\n        }\n        return ans;\n    }\n}"
      }
    },
    "1064": {
      "solution": {
        "array": ""
      }
    },
    "1065": {
      "solution": {
        "trie": "class Trie {\npublic:\n    vector<Trie*> children;\n    bool isEnd = false;\n\n    Trie() {\n        children.resize(26);\n    }\n\n    void insert(string word) {\n        Trie* node = this;\n        for (char c : word) {\n            c -= 'a';\n            if (!node->children[c]) node->children[c] = new Trie();\n            node = node->children[c];\n        }\n        node->isEnd = true;\n    }\n};\n\nclass Solution {\npublic:\n    vector<vector<int>> indexPairs(string text, vector<string>& words) {\n        Trie* trie = new Trie();\n        for (auto w : words) trie->insert(w);\n        int n = text.size();\n        vector<vector<int>> ans;\n        for (int i = 0; i < n; ++i) {\n            Trie* node = trie;\n            for (int j = i; j < n; ++j) {\n                int idx = text[j] - 'a';\n                if (!node->children[idx]) break;\n                node = node->children[idx];\n                if (node->isEnd) ans.push_back({i, j});\n            }\n        }\n        return ans;\n    }\n};"
      }
    },
    "1066": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1067": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1068": {
      "solution": {
        "database": ""
      }
    },
    "1069": {
      "solution": {
        "database": ""
      }
    },
    "1070": {
      "solution": {
        "database": ""
      }
    },
    "1071": {
      "solution": {
        "math": ""
      }
    },
    "1072": {
      "solution": {
        "matrix": ""
      }
    },
    "1073": {
      "solution": {
        "math": ""
      }
    },
    "1074": {
      "solution": {
        "matrix": "class Solution {\n  public int numSubmatrixSumTarget(int[][] matrix, int target) {\n    int m = matrix.length;\n    int n = matrix[0].length;\n    int ans = 0;\n\n    for (int[] row : matrix)\n      for (int i = 1; i < n; ++i)\n        row[i] += row[i - 1];\n\n    for (int baseCol = 0; baseCol < n; ++baseCol)\n      for (int j = baseCol; j < n; ++j) {\n        Map<Integer, Integer> prefixCount = new HashMap<>();\n        prefixCount.put(0, 1);\n        int sum = 0;\n        for (int i = 0; i < m; ++i) {\n          if (baseCol > 0)\n            sum -= matrix[i][baseCol - 1];\n          sum += matrix[i][j];\n          ans += prefixCount.getOrDefault(sum - target, 0);\n          prefixCount.merge(sum, 1, Integer::sum);\n        }\n      }\n\n    return ans;\n  }\n}"
      }
    },
    "1075": {
      "solution": {
        "database": ""
      }
    },
    "1076": {
      "solution": {
        "database": ""
      }
    },
    "1077": {
      "solution": {
        "database": ""
      }
    },
    "1078": {
      "solution": {
        "string": ""
      }
    },
    "1079": {
      "solution": {
        "backtracking": ""
      }
    },
    "1080": {
      "solution": {
        "tree": ""
      }
    },
    "1081": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "1082": {
      "solution": {
        "database": ""
      }
    },
    "1083": {
      "solution": {
        "database": ""
      }
    },
    "1084": {
      "solution": {
        "database": ""
      }
    },
    "1085": {
      "solution": {
        "math": ""
      }
    },
    "1086": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1087": {
      "solution": {
        "backtracking": ""
      }
    },
    "1088": {
      "solution": {
        "backtracking": ""
      }
    },
    "1089": {
      "solution": {
        "two-pointers": "public class Solution {\n    public void duplicateZeros(int[] arr) {\n        int n = arr.length;\n        \n        int zeroCount = 0;\n        for (int num : arr) {\n            if (num == 0) {\n                zeroCount++;\n            }\n        }\n        \n        int lastIndex = n - 1;\n        for (int i = lastIndex; i >= 0; i--) {\n            if (arr[i] == 0) {\n                if (i + zeroCount <= lastIndex) {\n                    arr[i + zeroCount] = 0;\n                }\n                zeroCount--;\n                if (i + zeroCount <= lastIndex) {\n                    arr[i + zeroCount] = 0;\n                }\n            } else {\n                if (i + zeroCount <= lastIndex) {\n                    arr[i + zeroCount] = arr[i];\n                }\n            }\n        }\n    }\n}\n"
      }
    },
    "1090": {
      "solution": {
        "counting": ""
      }
    },
    "1091": {
      "solution": {
        "matrix": "class Solution {\n\n  private static int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n\n  public int shortestPathBinaryMatrix(int[][] grid) {\n    int n = grid.length;\n    if (grid[0][0] == 0 && n == 1)\n      return 1;\n    if (grid[0][0] == 1 || grid[n - 1][n - 1] == 1)\n      return -1;\n\n    Queue<Pair<Integer, Integer>> q = new ArrayDeque<>(List.of(new Pair<>(0, 0)));\n    boolean[][] seen = new boolean[n][n];\n    seen[0][0] = true;\n\n    for (int step = 1; !q.isEmpty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        int i = q.peek().getKey();\n        int j = q.poll().getValue();\n\n        for (int[] dir : dirs) {\n          int x = i + dir[0];\n          int y = j + dir[1];\n          if (x < 0 || x == n || y < 0 || y == n)\n            continue;\n          if (grid[x][y] != 0 || seen[x][y])\n            continue;\n          if (x == n - 1 && y == n - 1)\n            return step + 1;\n          q.offer(new Pair<>(x, y));\n          seen[x][y] = true;\n        }\n      }\n\n    return -1;\n  }\n}"
      }
    },
    "1092": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1093": {
      "solution": {
        "probability-and-statistics": "class Solution {\n    public double[] sampleStats(int[] count) {\n      int n = Arrays.stream(count).sum();\n        return new double[] {\n                getMinimum(count), \n                getMaximum(count), \n                getMean(count, n), \n                (getLeftMedian(count, n) + getRightMedian(count, n)) / 2.0,\n                getMode(count),\n        };\n    }\n\n    private double getMinimum(int[] count) {\n        for (int i = 0; i < count.length; ++i)\n            if (count[i] > 0)\n                return i;\n        return -1;\n    }\n\n    private double getMaximum(int[] count) {\n        for (int i = count.length - 1; i >= 0; --i)\n            if (count[i] > 0)\n                return i;\n        return -1;\n    }\n\n    private double getMean(int[] count, double n) {\n        double mean = 0;\n        for (int i = 0; i < count.length; ++i)\n            mean += ((long) i * (long) count[i]) / n;\n        return mean;\n    }\n\n    private double getLeftMedian(int[] count, double n) {\n        int numCount = 0;\n        for (int i = 0; i < count.length; ++i) {\n            numCount += count[i];\n            if (numCount >= n / 2)\n                return i;\n        }\n        return -1;\n    }\n\n    private double getRightMedian(int[] count, double n) {\n        int numCount = 0;\n        for (int i = count.length - 1; i >= 0; --i) {\n            numCount += count[i];\n            if (numCount >= n / 2)\n                return i;\n        }\n        return -1;\n    }\n\n    private double getMode(int[] count) {\n        int mode = -1;\n        int maxCount = 0;\n        for (int i = 0; i < count.length; ++i)\n            if (count[i] > maxCount) {\n                maxCount = count[i];\n                mode = i;\n            }\n        return mode;\n    }\n}"
      }
    },
    "1094": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1095": {
      "solution": {
        "interactive": ""
      }
    },
    "1096": {
      "solution": {
        "stack": ""
      }
    },
    "1097": {
      "solution": {
        "database": ""
      }
    },
    "1098": {
      "solution": {
        "database": ""
      }
    },
    "1099": {
      "solution": {
        "two-pointers": "class Solution {\n    public int twoSumLessThanK(int[] nums, int k) {\n        Arrays.sort(nums);\n        int ans = -1;\n        int n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            int j = search(nums, k - nums[i], i + 1, n) - 1;\n            if (i < j) {\n                ans = Math.max(ans, nums[i] + nums[j]);\n            }\n        }\n        return ans;\n    }\n\n    private int search(int[] nums, int x, int left, int right) {\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            if (nums[mid] >= x) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n"
      }
    },
    "1100": {
      "solution": {
        "sliding-window": "public class Solution {\n    public int numKLenSubstrNoRepeats(String S, int K) {\n        int n = S.length();\n        if (n < K) return 0;\n\n        HashSet<Character> set = new HashSet<>();\n        int count = 0;\n\n        for (int i = 0; i <= n - K; i++) {\n            set.clear();\n            boolean isValid = true;\n            for (int j = i; j < i + K; j++) {\n                char ch = S.charAt(j);\n                if (set.contains(ch)) {\n                    isValid = false;\n                    break;\n                }\n                set.add(ch);\n            }\n            if (isValid) {\n                count++;\n            }\n        }\n        return count;\n    }\n}"
      }
    },
    "1101": {
      "solution": {
        "union-find": ""
      }
    },
    "1102": {
      "solution": {
        "union-find": ""
      }
    },
    "1103": {
      "solution": {
        "math": ""
      }
    },
    "1104": {
      "solution": {
        "tree": ""
      }
    },
    "1105": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1106": {
      "solution": {
        "recursion": "class Solution {\npublic:\n    bool parseBoolExpr(string expression) {\n        return evaluate(expression, 0, expression.size() - 1);\n    }\n\nprivate:\n    bool evaluate(const string& expr, int start, int end) {\n        char op = expr[start];\n\n        if (op == 't')\n            return true;\n        if (op == 'f')\n            return false;\n\n        if (op == '!') {\n            return !evaluate(expr, start + 2, end - 1);\n        } else if (op == '&') {\n            bool result = true;\n            for (int i = start + 2; i < end;) {\n                int nextPos = findNext(expr, i, end);\n                result &= evaluate(expr, i, nextPos - 1);\n                i = nextPos + 1;\n            }\n            return result;\n        } else if (op == '|') {\n            bool result = false;\n            for (int i = start + 2; i < end;) {\n                int nextPos = findNext(expr, i, end);\n                result |= evaluate(expr, i, nextPos - 1);\n                i = nextPos + 1;\n            }\n            return result;\n        }\n        return false;\n    }\n\n    int findNext(const string& expr, int start, int end) {\n        int balance = 0;\n        for (int i = start; i <= end; ++i) {\n            if (expr[i] == '(')\n                ++balance;\n            else if (expr[i] == ')')\n                --balance;\n            else if (expr[i] == ',' && balance == 0)\n                return i;\n        }\n        return end + 1;\n    }\n};\n"
      }
    },
    "1107": {
      "solution": {
        "database": ""
      }
    },
    "1108": {
      "solution": {
        "string": ""
      }
    },
    "1109": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1110": {
      "solution": {
        "tree": ""
      }
    },
    "1111": {
      "solution": {
        "stack": ""
      }
    },
    "1112": {
      "solution": {
        "database": ""
      }
    },
    "1113": {
      "solution": {
        "shortest-path": "class Solution {\npublic:\n    int largestUniqueNumber(vector<int>& nums) {\n        int cnt[1001]{};\n        for (int& x : nums) {\n            ++cnt[x];\n        }\n        for (int x = 1000; ~x; --x) {\n            if (cnt[x] == 1) {\n                return x;\n            }\n        }\n        return -1;\n    }\n};"
      }
    },
    "1114": {
      "solution": {
        "concurrency": "class Foo {\n    private final Object lock = new Object();\n    private boolean firstExecuted;\n    private boolean secondExecuted;\n\n    public Foo() {\n        firstExecuted = false;\n        secondExecuted = false;\n    }\n\n    public void first(Runnable printFirst) throws InterruptedException {\n        synchronized (lock) {\n            printFirst.run();\n            firstExecuted = true;\n            lock.notifyAll(); // Notify waiting threads that first() has completed\n        }\n    }\n\n    public void second(Runnable printSecond) throws InterruptedException {\n        synchronized (lock) {\n            while (!firstExecuted) {\n                lock.wait(); // Wait until first() has completed\n            }\n            printSecond.run();\n            secondExecuted = true;\n            lock.notifyAll(); // Notify waiting threads that second() has completed\n        }\n    }\n\n    public void third(Runnable printThird) throws InterruptedException {\n        synchronized (lock) {\n            while (!secondExecuted) {\n                lock.wait(); // Wait until second() has completed\n            }\n            printThird.run();\n        }\n    }\n}\n"
      }
    },
    "1115": {
      "solution": {
        "concurrency": "import java.util.concurrent.Semaphore;\n\nclass FooBar {\n    private int n;\n    private Semaphore fooSemaphore;\n    private Semaphore barSemaphore;\n\n    public FooBar(int n) {\n        this.n = n;\n        this.fooSemaphore = new Semaphore(1); // Initially fooSemaphore is available\n        this.barSemaphore = new Semaphore(0); // Initially barSemaphore is not available\n    }\n\n    public void foo(Runnable printFoo) throws InterruptedException {\n        for (int i = 0; i < n; i++) {\n            fooSemaphore.acquire();\n            printFoo.run();\n            barSemaphore.release();\n        }\n    }\n\n    public void bar(Runnable printBar) throws InterruptedException {\n        for (int i = 0; i < n; i++) {\n            barSemaphore.acquire();\n            printBar.run();\n            fooSemaphore.release();\n        }\n    }\n\n    public static void main(String[] args) {\n        FooBar fooBar = new FooBar(5);\n\n        Runnable printFoo = () -> System.out.print(\"foo\");\n        Runnable printBar = () -> System.out.print(\"bar\");\n\n        Thread threadFoo = new Thread(() -> {\n            try {\n                fooBar.foo(printFoo);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n\n        Thread threadBar = new Thread(() -> {\n            try {\n                fooBar.bar(printBar);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n\n        threadFoo.start();\n        threadBar.start();\n    }\n\n}\n"
      }
    },
    "1116": {
      "solution": {
        "concurrency": "import java.util.concurrent.Semaphore;\nimport java.util.function.IntConsumer;\n\nclass ZeroEvenOdd {\n    private int n;\n    private Semaphore zeroSemaphore;\n    private Semaphore evenSemaphore;\n    private Semaphore oddSemaphore;\n\n    public ZeroEvenOdd(int n) {\n        this.n = n;\n        this.zeroSemaphore = new Semaphore(1);\n        this.evenSemaphore = new Semaphore(0);\n        this.oddSemaphore = new Semaphore(0);\n    }\n\n    public void zero(IntConsumer printNumber) throws InterruptedException {\n        for (int i = 1; i <= n; i++) {\n            zeroSemaphore.acquire();\n            printNumber.accept(0);\n            if (i % 2 == 0) {\n                evenSemaphore.release();\n            } else {\n                oddSemaphore.release();\n            }\n        }\n    }\n\n    public void even(IntConsumer printNumber) throws InterruptedException {\n        for (int i = 2; i <= n; i += 2) {\n            evenSemaphore.acquire();\n            printNumber.accept(i);\n            zeroSemaphore.release();\n        }\n    }\n\n    public void odd(IntConsumer printNumber) throws InterruptedException {\n        for (int i = 1; i <= n; i += 2) {\n            oddSemaphore.acquire();\n            printNumber.accept(i);\n            zeroSemaphore.release();\n        }\n    }\n}\n"
      }
    },
    "1117": {
      "solution": {
        "concurrency": "import java.util.concurrent.Semaphore;\n\nclass H2O {\n    private Semaphore hydrogenSemaphore;\n    private Semaphore oxygenSemaphore;\n    private int hydrogenCount;\n\n    public H2O() {\n        hydrogenSemaphore = new Semaphore(2); // Allow up to 2 hydrogen atoms\n        oxygenSemaphore = new Semaphore(1); // Allow up to 1 oxygen atom\n        hydrogenCount = 0;\n    }\n\n    public void hydrogen(Runnable releaseHydrogen) throws InterruptedException {\n        hydrogenSemaphore.acquire();\n        synchronized (this) {\n            hydrogenCount++;\n            releaseHydrogen.run();\n            if (hydrogenCount == 2) {\n                oxygenSemaphore.release();            }\n        }\n    }\n\n    public void oxygen(Runnable releaseOxygen) throws InterruptedException {\n        oxygenSemaphore.acquire();\n        synchronized (this) {\n            releaseOxygen.run();\n            hydrogenCount = 0;\n            hydrogenSemaphore.release(2);\n        }\n    }\n}\n"
      }
    },
    "1118": {
      "solution": {
        "math": ""
      }
    },
    "1119": {
      "solution": {
        "string": ""
      }
    },
    "1120": {
      "solution": {
        "tree": ""
      }
    },
    "1121": {
      "solution": {
        "counting": ""
      }
    },
    "1122": {
      "solution": {
        "counting-sort": "class Solution {\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\n        int maxNum = 1000; // assuming the values in arr1 are between 0 and 1000\n        int[] count = new int[maxNum + 1];\n        \n        for (int num : arr1) {\n            count[num]++;\n        }\n        \n        int[] result = new int[arr1.length];\n        int index = 0;\n        \n        for (int num : arr2) {\n            while (count[num] > 0) {\n                result[index++] = num;\n                count[num]--;\n            }\n        }\n        \n        for (int i = 0; i <= maxNum; i++) {\n            while (count[i] > 0) {\n                result[index++] = i;\n                count[i]--;\n            }\n        }\n        \n        return result;\n    }\n}\n"
      }
    },
    "1123": {
      "solution": {
        "tree": ""
      }
    },
    "1124": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "1125": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1126": {
      "solution": {
        "database": ""
      }
    },
    "1127": {
      "solution": {
        "database": ""
      }
    },
    "1128": {
      "solution": {
        "counting": ""
      }
    },
    "1129": {
      "solution": {
        "breadth-first-search": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {\n        vector<vector<pair<int, int>>> graph(n); // {neighbor, color}\n        for (const auto& edge : redEdges) {\n            graph[edge[0]].emplace_back(edge[1], 0); // Red edge (color = 0)\n        }\n        for (const auto& edge : blueEdges) {\n            graph[edge[0]].emplace_back(edge[1], 1); // Blue edge (color = 1)\n        }\n\n        vector<vector<int>> dist(n, vector<int>(2, INT_MAX));\n        dist[0][0] = dist[0][1] = 0; \n\n        queue<tuple<int, int, int>> q;\n        q.emplace(0, 0, 0); \n        q.emplace(0, 1, 0); \n\n        while (!q.empty()) {\n            auto [node, color, d] = q.front();\n            q.pop();\n\n            for (const auto& [neighbor, edgeColor] : graph[node]) {\n                if (edgeColor != color && d + 1 < dist[neighbor][edgeColor]) {\n                    dist[neighbor][edgeColor] = d + 1;\n                    q.emplace(neighbor, edgeColor, d + 1);\n                }\n            }\n        }\n\n        vector<int> result(n, -1);\n        for (int i = 0; i < n; ++i) {\n            int minDist = min(dist[i][0], dist[i][1]);\n            result[i] = (minDist == INT_MAX) ? -1 : minDist;\n        }\n\n        return result;\n    }\n};\n"
      }
    },
    "1130": {
      "solution": {
        "monotonic-stack": "class Solution {\n  public int mctFromLeafValues(int[] arr) {\n    int ans = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    stack.push(Integer.MAX_VALUE);\n\n    for (int a : arr) {\n      while (stack.peek() <= a) {\n        int mid = stack.pop();\n        ans += Math.min(stack.peek(), a) * mid;\n      }\n      stack.push(a);\n    }\n\n    while (stack.size() > 2)\n      ans += stack.pop() * stack.peek();\n\n    return ans;\n  }\n}"
      }
    },
    "1131": {
      "solution": {
        "math": ""
      }
    },
    "1132": {
      "solution": {
        "database": ""
      }
    },
    "1133": {
      "solution": {
        "sorting": "class Solution {\npublic:\n    int largestUniqueNumber(vector<int>& nums) {\n        int cnt[1001]{};\n        for (int& x : nums) {\n            ++cnt[x];\n        }\n        for (int x = 1000; ~x; --x) {\n            if (cnt[x] == 1) {\n                return x;\n            }\n        }\n        return -1;\n    }\n};"
      }
    },
    "1134": {
      "solution": {
        "math": ""
      }
    },
    "1135": {
      "solution": {
        "minimum-spanning-tree": "class UnionFind {\n public:\n  UnionFind(int n) : parent(n), rank(n) {\n    iota(parent.begin(), parent.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      parent[i] = j;\n    } else if (rank[i] > rank[j]) {\n      parent[j] = i;\n    } else {\n      parent[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return parent[u] == u ? u : parent[u] = find(parent[u]);\n  }\n\n private:\n  vector<int> parent;\n  vector<int> rank;\n};\n\nclass Solution {\n public:\n  int minimumCost(int n, vector<vector<int>>& connections) {\n    int ans = 0;\n    UnionFind uf(n + 1);\n\n    // Sort by cost.\n    ranges::sort(connections, ranges::less{},\n                 [](const vector<int>& connection) { return connection[2]; });\n\n    for (const vector<int>& connection : connections) {\n      const int u = connection[0];\n      const int v = connection[1];\n      const int cost = connection[2];\n      if (uf.find(u) == uf.find(v))\n        continue;\n      uf.unionByRank(u, v);\n      ans += cost;\n    }\n\n    const int root = uf.find(1);\n    for (int i = 1; i <= n; ++i)\n      if (uf.find(i) != root)\n        return -1;\n\n    return ans;\n  }\n};"
      }
    },
    "1136": {
      "solution": {
        "topological-sort": "class Solution {\n    public int minimumSemesters(int n, int[][] relations) {\n        List<Integer>[] g = new List[n];\n        Arrays.setAll(g, k -> new ArrayList<>());\n        int[] indeg = new int[n];\n        for (var r : relations) {\n            int prev = r[0] - 1, nxt = r[1] - 1;\n            g[prev].add(nxt);\n            ++indeg[nxt];\n        }\n        Deque<Integer> q = new ArrayDeque<>();\n        for (int i = 0; i < n; ++i) {\n            if (indeg[i] == 0) {\n                q.offer(i);\n            }\n        }\n        int ans = 0;\n        while (!q.isEmpty()) {\n            ++ans;\n            for (int k = q.size(); k > 0; --k) {\n                int i = q.poll();\n                --n;\n                for (int j : g[i]) {\n                    if (--indeg[j] == 0) {\n                        q.offer(j);\n                    }\n                }\n            }\n        }\n        return n == 0 ? ans : -1;\n    }\n}"
      }
    },
    "1137": {
      "solution": {
        "dynamic-programming": "",
        "memoization": "public class Solution {\n    private HashMap<Integer, Integer> memo = new HashMap<>();\n\n    public int tribonacci(int n) {\n        if (n == 0)\n            return 0;\n        if (n == 1 || n == 2)\n            return 1;\n\n        if (memo.containsKey(n)) {\n            return memo.get(n);\n        }\n\n        int result = tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);\n        memo.put(n, result);\n\n        return result;\n    }\n\n}"
      }
    },
    "1138": {
      "solution": {
        "hash-table": ""
      }
    },
    "1139": {
      "solution": {
        "matrix": "public class Solution {\n    public int largest1BorderedSquare(int[][] grid) {\n        int rows = grid.length, cols = grid[0].length;\n        int[][] horizontal = new int[rows][cols];\n        int[][] vertical = new int[rows][cols];\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 1) {\n                    horizontal[i][j] = (j > 0 ? horizontal[i][j - 1] : 0) + 1;\n                    vertical[i][j] = (i > 0 ? vertical[i - 1][j] : 0) + 1;\n                }\n            }\n        }\n\n        int maxSide = 0;  \n        for (int i = rows - 1; i >= 0; i--) {\n            for (int j = cols - 1; j >= 0; j--) {\n                int possibleSide = Math.min(horizontal[i][j], vertical[i][j]);\n                \n                while (possibleSide > maxSide) {\n                    if (horizontal[i - possibleSide + 1][j] >= possibleSide &&\n                        vertical[i][j - possibleSide + 1] >= possibleSide) {\n                        maxSide = possibleSide; \n                    }\n                    possibleSide--; \n                }\n            }\n        }\n\n        return maxSide * maxSide;\n    }\n}\n"
      }
    },
    "1140": {
      "solution": {
        "breadth-first-search": "class Solution {\npublic:\n    int stoneGameII(vector<int>& piles) {\n        int n = piles.size();\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n        vector<int> suffixSum(n + 1, 0);\n\n        for (int i = n - 1; i >= 0; --i) {\n            suffixSum[i] = suffixSum[i + 1] + piles[i];\n        }\n\n        for (int i = n - 1; i >= 0; --i) {\n            for (int M = 1; M <= n; ++M) {\n                for (int X = 1; X <= 2 * M && i + X <= n; ++X) {\n                    dp[i][M] =\n                        max(dp[i][M], suffixSum[i] - dp[i + X][max(M, X)]);\n                }\n            }\n        }\n\n        return dp[0][1];\n    }\n};\n"
      }
    },
    "1141": {
      "solution": {
        "database": ""
      }
    },
    "1142": {
      "solution": {
        "database": ""
      }
    },
    "1143": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1144": {
      "solution": {
        "greedy": ""
      }
    },
    "1145": {
      "solution": {
        "tree": ""
      }
    },
    "1146": {
      "solution": {
        "design": ""
      }
    },
    "1147": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1148": {
      "solution": {
        "database": ""
      }
    },
    "1149": {
      "solution": {
        "database": ""
      }
    },
    "1150": {
      "solution": {
        "array": ""
      }
    },
    "1151": {
      "solution": {
        "sliding-window": "class Solution {\n  public int minSwaps(int[] data) {\n      int sum = 0;\n      for (int v : data) {\n          sum += v;\n      }\n      int sumK = 0;\n      for (int i = 0; i < sum; ++i) {\n          sumK += data[i];\n      }\n      int max = sumK;\n      for (int i = sum; i < data.length; ++i) {\n          sumK += data[i];\n          sumK -= data[i - sum];\n          max = Math.max(max, sumK);\n      }\n      return sum - max;\n  }\n}"
      }
    },
    "1152": {
      "solution": {
        "sorting": ""
      }
    },
    "1153": {
      "solution": {
        "hash-table": ""
      }
    },
    "1154": {
      "solution": {
        "math": ""
      }
    },
    "1155": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1156": {
      "solution": {
        "sliding-window": "public class Solution {\n    public int maxRepOpt1(String text) {\n        int[] count = new int[26];\n        for (char c : text.toCharArray()) {\n            count[c - 'a']++;\n        }\n        int maxLen = 0;\n        for (int i = 0; i < text.length(); ) {\n            char currentChar = text.charAt(i);\n            int start = i;            \n            while (i < text.length() && text.charAt(i) == currentChar) {\n                i++;\n            }\n            int blockLen = i - start;            \n            int nextBlockStart = i + 1;\n            while (nextBlockStart < text.length() && text.charAt(nextBlockStart) == currentChar) {\n                nextBlockStart++;\n            }\n            int totalLen = blockLen + (nextBlockStart - i - 1);            \n            maxLen = Math.max(maxLen, Math.min(totalLen + 1, count[currentChar - 'a']));            \n            i = start + blockLen;\n        }\n\n        return maxLen;\n    }\n}\n"
      }
    },
    "1157": {
      "solution": {
        "design": ""
      }
    },
    "1158": {
      "solution": {
        "database": ""
      }
    },
    "1159": {
      "solution": {
        "database": ""
      }
    },
    "1160": {
      "solution": {
        "hash-table": ""
      }
    },
    "1161": {
      "solution": {
        "tree": ""
      }
    },
    "1162": {
      "solution": {
        "matrix": ""
      }
    },
    "1163": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1164": {
      "solution": {
        "database": ""
      }
    },
    "1165": {
      "solution": {
        "hash-table": ""
      }
    },
    "1166": {
      "solution": {
        "trie": ""
      }
    },
    "1167": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1168": {
      "solution": {
        "minimum-spanning-tree": "class Solution {\n public:\n  int minCostToSupplyWater(int n, vector<int>& wells,\n                           vector<vector<int>>& pipes) {\n    int ans = 0;\n    using P = pair<int, int>;\n    vector<vector<P>> graph(n + 1);\n    priority_queue<P, vector<P>, greater<>> minHeap;  // (d, u)\n\n    for (const vector<int>& pipe : pipes) {\n      const int u = pipe[0];\n      const int v = pipe[1];\n      const int w = pipe[2];\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n    }\n\n    for (int i = 0; i < n; ++i) {\n      graph[0].emplace_back(i + 1, wells[i]);\n      minHeap.emplace(wells[i], i + 1);\n    }\n\n    unordered_set<int> mst{{0}};\n\n    while (mst.size() < n + 1) {\n      const auto [d, u] = minHeap.top();\n      minHeap.pop();\n      if (mst.contains(u))\n        continue;\n      mst.insert(u);\n      ans += d;\n      for (const auto [v, w] : graph[u])\n        if (!mst.contains(v))\n          minHeap.emplace(w, v);\n    }\n\n    return ans;\n  }\n};"
      }
    },
    "1169": {
      "solution": {
        "sorting": ""
      }
    },
    "1170": {
      "solution": {
        "sorting": ""
      }
    },
    "1171": {
      "solution": {
        "linked-list": ""
      }
    },
    "1172": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1173": {
      "solution": {
        "database": ""
      }
    },
    "1174": {
      "solution": {
        "database": ""
      }
    },
    "1175": {
      "solution": {
        "math": ""
      }
    },
    "1176": {
      "solution": {
        "sliding-window": "class Solution {\n    public int dietPlanPerformance(int[] calories, int k, int lower, int upper) {\n        int n = calories.length;\n        int[] s = new int[n + 1];\n        for (int i = 0; i < n; ++i) {\n            s[i + 1] = s[i] + calories[i];\n        }\n        int ans = 0;\n        for (int i = 0; i < n - k + 1; ++i) {\n            int t = s[i + k] - s[i];\n            if (t < lower) {\n                --ans;\n            } else if (t > upper) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n}"
      }
    },
    "1177": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1178": {
      "solution": {
        "trie": ""
      }
    },
    "1179": {
      "solution": {
        "database": ""
      }
    },
    "1180": {
      "solution": {
        "math": ""
      }
    },
    "1181": {
      "solution": {
        "sorting": ""
      }
    },
    "1182": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1183": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1184": {
      "solution": {
        "array": ""
      }
    },
    "1185": {
      "solution": {
        "math": ""
      }
    },
    "1186": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1187": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1188": {
      "solution": {
        "concurrency": "class BoundedBlockingQueue {\n    private Semaphore s1;\n    private Semaphore s2;\n    private Deque<Integer> q = new ArrayDeque<>();\n\n    public BoundedBlockingQueue(int capacity) {\n        s1 = new Semaphore(capacity);\n        s2 = new Semaphore(0);\n    }\n\n    public void enqueue(int element) throws InterruptedException {\n        s1.acquire();\n        q.offer(element);\n        s2.release();\n    }\n\n    public int dequeue() throws InterruptedException {\n        s2.acquire();\n        int ans = q.poll();\n        s1.release();\n        return ans;\n    }\n\n    public int size() {\n        return q.size();\n    }\n}"
      }
    },
    "1189": {
      "solution": {
        "counting": ""
      }
    },
    "1190": {
      "solution": {
        "stack": "class Solution {\n    public String reverseParentheses(String s) {\n        Stack<Integer> stack = new Stack<>();\n        StringBuilder sb = new StringBuilder();\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '(') {\n                stack.push(sb.length());\n            } else if (c == ')') {\n                int start = stack.pop();\n                int end = sb.length() - 1;\n                reverse(sb, start, end);\n            } else {\n                sb.append(c);\n            }\n        }\n        \n        return sb.toString();\n    }\n    \n    private void reverse(StringBuilder sb, int start, int end) {\n        while (start < end) {\n            char temp = sb.charAt(start);\n            sb.setCharAt(start++, sb.charAt(end));\n            sb.setCharAt(end--, temp);\n        }\n    }\n}\n"
      }
    },
    "1191": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1192": {
      "solution": {
        "biconnected-component": "import java.util.*;\n\nclass Solution {\n    List<List<Integer>> graph;\n    int[] low;\n    int[] disc;\n    int time;\n    List<List<Integer>> result;\n    \n    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {\n        graph = new ArrayList<>();\n        low = new int[n];\n        disc = new int[n];\n        result = new ArrayList<>();\n        time = 0;\n        \n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (List<Integer> conn : connections) {\n            int u = conn.get(0);\n            int v = conn.get(1);\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n        \n        dfs(0, -1);\n        \n        return result;\n    }\n    \n    private void dfs(int u, int parent) {\n        low[u] = disc[u] = ++time;\n        \n        for (int v : graph.get(u)) {\n            if (v == parent) continue;\n            \n            if (disc[v] == 0) { // If v is not visited\n                dfs(v, u);\n                low[u] = Math.min(low[u], low[v]);\n                if (low[v] > disc[u]) {\n                    // (u, v) is a critical connection\n                    result.add(Arrays.asList(u, v));\n                }\n            } else {\n                low[u] = Math.min(low[u], disc[v]);\n            }\n        }\n    }\n}",
        "graph": "import java.util.*;\n\nclass Solution {\n    List<List<Integer>> graph;\n    int[] low;\n    int[] disc;\n    int time;\n    List<List<Integer>> result;\n    \n    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {\n        graph = new ArrayList<>();\n        low = new int[n];\n        disc = new int[n];\n        result = new ArrayList<>();\n        time = 0;\n        \n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (List<Integer> conn : connections) {\n            int u = conn.get(0);\n            int v = conn.get(1);\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n        \n        dfs(0, -1);\n        \n        return result;\n    }\n    \n    private void dfs(int u, int parent) {\n        low[u] = disc[u] = ++time;\n        \n        for (int v : graph.get(u)) {\n            if (v == parent) continue;\n            \n            if (disc[v] == 0) { // If v is not visited\n                dfs(v, u);\n                low[u] = Math.min(low[u], low[v]);\n                if (low[v] > disc[u]) {\n                    // (u, v) is a critical connection\n                    result.add(Arrays.asList(u, v));\n                }\n            } else {\n                low[u] = Math.min(low[u], disc[v]);\n            }\n        }\n    }\n}",
        "depth-first-search": "import java.util.*;\n\nclass Solution {\n    List<List<Integer>> graph;\n    int[] low;\n    int[] disc;\n    int time;\n    List<List<Integer>> result;\n    \n    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {\n        graph = new ArrayList<>();\n        low = new int[n];\n        disc = new int[n];\n        result = new ArrayList<>();\n        time = 0;\n        \n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (List<Integer> conn : connections) {\n            int u = conn.get(0);\n            int v = conn.get(1);\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n        \n        dfs(0, -1);\n        \n        return result;\n    }\n    \n    private void dfs(int u, int parent) {\n        low[u] = disc[u] = ++time;\n        \n        for (int v : graph.get(u)) {\n            if (v == parent) continue;\n            \n            if (disc[v] == 0) { // If v is not visited\n                dfs(v, u);\n                low[u] = Math.min(low[u], low[v]);\n                if (low[v] > disc[u]) {\n                    // (u, v) is a critical connection\n                    result.add(Arrays.asList(u, v));\n                }\n            } else {\n                low[u] = Math.min(low[u], disc[v]);\n            }\n        }\n    }\n}"
      }
    },
    "1193": {
      "solution": {
        "database": ""
      }
    },
    "1194": {
      "solution": {
        "database": ""
      }
    },
    "1195": {
      "solution": {
        "concurrency": "import java.util.function.IntConsumer;\n\npublic class FizzBuzz {\n    private int n;\n    private int current = 1;\n\n    public FizzBuzz(int n) {\n        this.n = n;\n    }\n\n    public synchronized void fizz(Runnable printFizz) throws InterruptedException {\n        while (current <= n) {\n            while (current <= n && (current % 3 != 0 || current % 5 == 0)) {\n                wait();\n            }\n            if (current <= n) {\n                printFizz.run();\n                current++;\n                notifyAll();\n            }\n        }\n    }\n\n    public synchronized void buzz(Runnable printBuzz) throws InterruptedException {\n        while (current <= n) {\n            while (current <= n && (current % 5 != 0 || current % 3 == 0)) {\n                wait();\n            }\n            if (current <= n) {\n                printBuzz.run();\n                current++;\n                notifyAll();\n            }\n        }\n    }\n\n    public synchronized void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException {\n        while (current <= n) {\n            while (current <= n && (current % 3 != 0 || current % 5 != 0)) {\n                wait();\n            }\n            if (current <= n) {\n                printFizzBuzz.run();\n                current++;\n                notifyAll();\n            }\n        }\n    }\n\n    public synchronized void number(IntConsumer printNumber) throws InterruptedException {\n        while (current <= n) {\n            while (current <= n && (current % 3 == 0 || current % 5 == 0)) {\n                wait();\n            }\n            if (current <= n) {\n                printNumber.accept(current);\n                current++;\n                notifyAll();\n            }\n        }\n    }\n}\n"
      }
    },
    "1196": {
      "solution": {
        "sorting": "class Solution {\npublic:\n    int maxNumberOfApples(vector<int>& weight) {\n        sort(weight.begin(), weight.end());\n        int s = 0;\n        for (int i = 0; i < weight.size(); ++i) {\n            s += weight[i];\n            if (s > 5000) {\n                return i;\n            }\n        }\n        return weight.size();\n    }\n};"
      }
    },
    "1197": {
      "solution": {
        "breadth-first-search": ""
      }
    },
    "1198": {
      "solution": {
        "matrix": ""
      }
    },
    "1199": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1200": {
      "solution": {
        "shortest-path": "class Solution {\n public:\n  vector<vector<int>> minimumAbsDifference(vector<int>& arr) {\n    vector<vector<int>> ans;\n    int mn = INT_MAX;\n\n    ranges::sort(arr);\n\n    for (int i = 1; i < arr.size(); ++i) {\n      const int diff = arr[i] - arr[i - 1];\n      if (diff < mn) {\n        mn = diff;\n        ans.clear();\n      }\n      if (diff == mn)\n        ans.push_back({arr[i - 1], arr[i]});\n    }\n\n    return ans;\n  }\n};"
      }
    },
    "1201": {
      "solution": {
        "combinatorics": "",
        "binary-search": "class Solution {\npublic:\n    int nthUglyNumber(int n, int a, int b, int c) {\n        long long ab = lcm(a, b);\n        long long bc = lcm(b, c);\n        long long ac = lcm(a, c);\n        long long abc = lcm(ab, c);\n        long long l = 1, r = 2000000000;\n        while (l < r) {\n            long long mid = (l + r) >> 1;\n            if (mid / a + mid / b + mid / c - mid / ab - mid / bc - mid / ac + mid / abc >= n) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n\n    long long lcm(long long a, long long b) {\n        return a * b / gcd(a, b);\n    }\n\n    long long gcd(long long a, long long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n};"
      }
    },
    "1202": {
      "solution": {
        "union-find": ""
      }
    },
    "1203": {
      "solution": {
        "topological-sort": ""
      }
    },
    "1204": {
      "solution": {
        "database": ""
      }
    },
    "1205": {
      "solution": {
        "database": ""
      }
    },
    "1206": {
      "solution": {
        "linked-list": ""
      }
    },
    "1207": {
      "solution": {
        "hash-table": ""
      }
    },
    "1208": {
      "solution": {
        "sliding-window": "class Solution {\n    public int equalSubstring(String s, String t, int maxCost) {\n        int n = s.length();\n        int[] cost = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            cost[i] = Math.abs(s.charAt(i) - t.charAt(i));\n        }\n        \n        int left = 0, right = 0;\n        int currentCost = 0;\n        int maxLength = 0;\n        \n        while (right < n) {\n            currentCost += cost[right];\n            \n            while (currentCost > maxCost) {\n                currentCost -= cost[left];\n                left++;\n            }\n            \n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        }\n        \n        return maxLength;\n    }\n}\n"
      }
    },
    "1209": {
      "solution": {
        "stack": "class Solution {\n    public String removeDuplicates(String s, int k) {\n        Stack<Pair<Character, Integer>> stack = new Stack<>();\n\n        for (char c : s.toCharArray()) {\n            if (!stack.isEmpty() && stack.peek().getKey() == c) {\n                Pair<Character, Integer> top = stack.pop();\n                if (top.getValue() + 1 < k) {\n                    stack.push(new Pair<>(c, top.getValue() + 1));\n                }\n            } else {\n                stack.push(new Pair<>(c, 1));\n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        while (!stack.isEmpty()) {\n            Pair<Character, Integer> pair = stack.pop();\n            for (int i = 0; i < pair.getValue(); i++) {\n                sb.append(pair.getKey());\n            }\n        }\n\n        return sb.reverse().toString();\n    }\n}\n"
      }
    },
    "1210": {
      "solution": {
        "matrix": ""
      }
    },
    "1211": {
      "solution": {
        "database": ""
      }
    },
    "1212": {
      "solution": {
        "database": ""
      }
    },
    "1213": {
      "solution": {
        "counting": "class Solution {\npublic:\n    vector<int> arraysIntersection(vector<int>& arr1, vector<int>& arr2, vector<int>& arr3) {\n        vector<int> ans;\n        int cnt[2001]{};\n        for (int x : arr1) {\n            ++cnt[x];\n        }\n        for (int x : arr2) {\n            ++cnt[x];\n        }\n        for (int x : arr3) {\n            if (++cnt[x] == 3) {\n                ans.push_back(x);\n            }\n        }\n        return ans;\n    }\n};"
      }
    },
    "1214": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1215": {
      "solution": {
        "backtracking": ""
      }
    },
    "1216": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1217": {
      "solution": {
        "greedy": ""
      }
    },
    "1218": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1219": {
      "solution": {
        "matrix": ""
      }
    },
    "1220": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1221": {
      "solution": {
        "counting": ""
      }
    },
    "1222": {
      "solution": {
        "matrix": ""
      }
    },
    "1223": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1224": {
      "solution": {
        "hash-table": ""
      }
    },
    "1225": {
      "solution": {
        "database": ""
      }
    },
    "1226": {
      "solution": {
        "concurrency": "import java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class DiningPhilosophers {\n\n    private Lock leftForkLock = new ReentrantLock();\n    private Lock rightForkLock = new ReentrantLock();\n\n    public DiningPhilosophers() {\n\n    }\n\n    // call the run() method of any runnable to execute its code\n    public void wantsToEat(int philosopher,\n            Runnable pickLeftFork,\n            Runnable pickRightFork,\n            Runnable eat,\n            Runnable putLeftFork,\n            Runnable putRightFork) throws InterruptedException {\n\n        while (true) {\n            if (leftForkLock.tryLock(100, TimeUnit.MILLISECONDS)) {\n                try {\n                    pickLeftFork.run();\n                    if (rightForkLock.tryLock(100, TimeUnit.MILLISECONDS)) {\n                        try {\n                            pickRightFork.run();\n                            eat.run();\n                            putRightFork.run();\n                            return;\n                        } finally {\n                            rightForkLock.unlock();\n                        }\n                    }\n\n                } finally {\n                    putLeftFork.run();\n                    leftForkLock.unlock();\n                }\n            }\n        }\n    }\n}"
      }
    },
    "1227": {
      "solution": {
        "probability-and-statistics": "class Solution {\n  public double nthPersonGetsNthSeat(int n) {\n    return n == 1 ? 1 : 0.5;\n  }\n}"
      }
    },
    "1228": {
      "solution": {
        "math": ""
      }
    },
    "1229": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1230": {
      "solution": {
        "probability-and-statistics": "class Solution {\n    public double probabilityOfHeads(double[] prob, int target) {\n        int n = prob.length;\n        double[][] dp = new double[n + 1][target + 1];\n        dp[0][0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j <= Math.min(i, target); ++j) {\n                dp[i][j] = (1 - prob[i - 1]) * dp[i - 1][j];\n                if (j > 0) {\n                    dp[i][j] += prob[i - 1] * dp[i - 1][j - 1];\n                }\n            }\n        }\n        return dp[n][target];\n    }\n}"
      }
    },
    "1231": {
      "solution": {
        "array": ""
      }
    },
    "1232": {
      "solution": {
        "geometry": "class Solution {\npublic:\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\n        int n = coordinates.size();\n        if (n < 2)\n            return false; // At least two points are needed\n\n        int x1 = coordinates[0][0], y1 = coordinates[0][1];\n        int x2 = coordinates[1][0], y2 = coordinates[1][1];\n\n        for (int i = 2; i < n; ++i) {\n            int x3 = coordinates[i][0], y3 = coordinates[i][1];\n            // Compare cross product: (y2 - y1) * (x3 - x2) == (y3 - y2) * (x2 -\n            // x1)\n            if ((y2 - y1) * (x3 - x2) != (y3 - y2) * (x2 - x1))\n                return false;\n        }\n\n        return true;\n    }\n};\n"
      }
    },
    "1233": {
      "solution": {
        "trie": ""
      }
    },
    "1234": {
      "solution": {
        "sliding-window": "class Solution {\n  public int balancedString(String s) {\n  int n = s.length();\n  int k = n / 4;\n    int ans = n;\n    int[] count = new int[128];\n\n    for (final char c : s.toCharArray())\n      ++count[c];\n\n    for (int i = 0, j = 0; i < n; ++i) {\n      --count[s.charAt(i)];\n      while (j < n && count['Q'] <= k && count['W'] <= k && count['E'] <= k && count['R'] <= k) {\n        ans = Math.min(ans, i - j + 1);\n        ++count[s.charAt(j)];\n        ++j;\n      }\n    }\n\n    return ans;\n  }\n}"
      }
    },
    "1235": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1236": {
      "solution": {
        "breadth-first-search": "class Solution {\npublic:\n    vector<string> ans;\n    unordered_set<string> vis;\n\n    vector<string> crawl(string startUrl, HtmlParser htmlParser) {\n        dfs(startUrl, htmlParser);\n        return ans;\n    }\n\n    void dfs(string& url, HtmlParser& htmlParser) {\n        if (vis.count(url)) return;\n        vis.insert(url);\n        ans.push_back(url);\n        for (string next : htmlParser.getUrls(url))\n            if (host(url) == host(next))\n                dfs(next, htmlParser);\n    }\n\n    string host(string url) {\n        int i = 7;\n        string res;\n        for (; i < url.size(); ++i) {\n            if (url[i] == '/') break;\n            res += url[i];\n        }\n        return res;\n    }\n};"
      }
    },
    "1237": {
      "solution": {
        "two-pointers": "",
        "interactive": "/*\n * // This is the custom function interface.\n * // You should not implement it, or speculate about its implementation\n * class CustomFunction {\n * public:\n *     // Returns f(x, y) for any given positive integers x and y.\n *     // Note that f(x, y) is increasing with respect to both x and y.\n *     // i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n *     int f(int x, int y);\n * };\n */\n\nclass Solution {\npublic:\n    vector<vector<int>> findSolution(CustomFunction& customfunction, int z) {\n        vector<vector<int>> result;\n        int x = 1, y = 1000; // Start with x=1 and maximum possible y\n\n        while (x <= 1000 && y > 0) {\n            int value = customfunction.f(x, y);\n            if (value == z) {\n                result.push_back({x, y});\n                x++; // Move to the next x\n                y--; // Move to the next y\n            } else if (value < z) {\n                x++; // Increase x to increase f(x, y)\n            } else {\n                y--; // Decrease y to decrease f(x, y)\n            }\n        }\n\n        return result;\n    }\n};\n"
      }
    },
    "1238": {
      "solution": {
        "backtracking": ""
      }
    },
    "1239": {
      "solution": {
        "backtracking": ""
      }
    },
    "1240": {
      "solution": {
        "backtracking": ""
      }
    },
    "1241": {
      "solution": {
        "database": ""
      }
    },
    "1242": {
      "solution": {
        "concurrency": "import java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentSkipListSet;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class Web_Crawler_Multithreaded {\n\n    class Solution_1_synchronizedList {\n        private final Set<String> set = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());\n        private final List<String> result = Collections.synchronizedList(new ArrayList<String>());\n        private String HOSTNAME = null;\n\n        public List<String> crawl(String startUrl, HtmlParser htmlParser) {\n            initHostName(startUrl);\n            set.add(startUrl);\n            getUrlDfs(startUrl, htmlParser);\n            return result;\n        }\n\n        private boolean judgeHostname(String url) {\n            int idx = url.indexOf('/', 7);\n            String hostName = (idx != -1) ? url.substring(0, idx) : url;\n            return hostName.equals(HOSTNAME);\n        }\n\n        private void initHostName(String url) {\n            int idx = url.indexOf('/', 7);\n            HOSTNAME = (idx != -1) ? url.substring(0, idx) : url;\n        }\n\n        private void getUrlDfs(String startUrl, HtmlParser htmlParser) {\n            result.add(startUrl);\n            List<String> res = htmlParser.getUrls(startUrl);\n            List<Thread> threads = new ArrayList<>();\n            for (String url : res) {\n                if (judgeHostname(url) && !set.contains(url)) {\n                    set.add(url);\n                    threads.add(new Thread(() -> {\n                        getUrlDfs(url, htmlParser);\n                    }));\n                }\n            }\n            for (Thread thread : threads) {\n                thread.start();\n            }\n            try {\n                for (Thread thread : threads) {\n                    thread.join(); \n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n    class Solution_2_ConcurrentSkipListSet {\n\n        public List<String> crawl(String startUrl, HtmlParser htmlParser) {\n            Set<String> visited = new ConcurrentSkipListSet<>();\n            String hostname = getHostname(startUrl);\n            visited.add(startUrl);\n\n            return crawlDfs(startUrl, htmlParser, hostname, visited).collect(Collectors.toList());\n        }\n\n        private Stream<String> crawlDfs(String startUrl, HtmlParser htmlParser, String hostname,\n                                     Set<String> visited) {\n            try (Stream<String> stream = htmlParser.getUrls(startUrl)\n                .parallelStream()\n                .filter(url -> isSameHostname(url, hostname))\n                .filter(visited::add)\n                .flatMap(url -> crawlDfs(url, htmlParser, hostname, visited))) {\n\n                return Stream.concat(Stream.of(startUrl), stream);\n            }\n        }\n\n        private String getHostname(String url) {\n            int idx = url.indexOf('/', 7);\n            return (idx != -1) ? url.substring(0, idx) : url;\n        }\n\n        private boolean isSameHostname(String url, String hostname) {\n            return url.startsWith(hostname) && (url.length() == hostname.length()\n                || url.charAt(hostname.length()) == '/');\n        }\n    }\n\n    interface HtmlParser {\n        List<String> getUrls(String str);\n    }\n\n\n    class Solution_CrawlerClass {\n        public List<String> crawl(String startUrl, HtmlParser htmlParser) {\n            String host = URI.create(startUrl).getHost();\n            Crawler crawler = new Crawler(startUrl, host, htmlParser);\n            crawler.res = new ArrayList<>();\n            crawler.start();\n            Crawler.joinThread(crawler);\n            return crawler.res;\n        }\n    }\n\n    static class Crawler extends Thread {\n        String startUrl;\n        String hostname;\n        HtmlParser htmlParser;\n        public volatile List<String> res = new ArrayList<>();\n\n        public Crawler(String startUrl, String hostname, HtmlParser htmlParser) {\n            this.startUrl = startUrl;\n            this.hostname = hostname;\n            this.htmlParser = htmlParser;\n        }\n\n        @Override\n        public void run() {\n            String host = URI.create(startUrl).getHost();\n            if (!host.equals(hostname) || res.contains(startUrl)) {\n                return;\n            }\n            res.add(startUrl);\n            List<Thread> threads = new ArrayList<>();\n            for (String s : htmlParser.getUrls(startUrl)) {\n                Crawler crawler = new Crawler(s, hostname, htmlParser);\n                crawler.start();\n                threads.add(crawler);\n            }\n            for (Thread t : threads) {\n                joinThread(t);\n            }\n        }\n\n        public static void joinThread(Thread thread) {\n            try {\n                thread.join();\n            } catch (InterruptedException e) {\n            }\n        }\n\n    }\n}"
      }
    },
    "1243": {
      "solution": {
        "array": ""
      }
    },
    "1244": {
      "solution": {
        "design": ""
      }
    },
    "1245": {
      "solution": {
        "tree": "class Solution {\npublic:\n    unordered_map<int, unordered_set<int>> g;\n    vector<bool> vis;\n    int ans;\n    int next;\n\n    int treeDiameter(vector<vector<int>>& edges) {\n        for (auto& e : edges) {\n            g[e[0]].insert(e[1]);\n            g[e[1]].insert(e[0]);\n        }\n        int n = edges.size();\n        ans = 0;\n        vis.resize(n + 1);\n        next = edges[0][0];\n        dfs(next, 0);\n        vis.assign(vis.size(), false);\n        dfs(next, 0);\n        return ans;\n    }\n\n    void dfs(int u, int t) {\n        if (vis[u]) return;\n        vis[u] = true;\n        if (ans < t) {\n            ans = t;\n            next = u;\n        }\n        for (int v : g[u]) dfs(v, t + 1);\n    }\n};"
      }
    },
    "1246": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1247": {
      "solution": {
        "greedy": ""
      }
    },
    "1248": {
      "solution": {
        "sliding-window": "class Solution {\n    public int numberOfSubarrays(int[] nums, int k) {\n        return atMost(nums, k) - atMost(nums, k - 1);\n    }\n    \n    private int atMost(int[] nums, int k) {\n        int res = 0;\n        int left = 0;\n        int count = 0;\n        \n        for (int right = 0; right < nums.length; ++right) {\n            if (nums[right] % 2 == 1) {\n                --k;\n            }\n            \n            while (k < 0) {\n                if (nums[left] % 2 == 1) {\n                    ++k;\n                }\n                ++left;\n            }\n            \n            res += right - left + 1;\n        }\n        \n        return res;\n    }\n}"
      }
    },
    "1249": {
      "solution": {
        "stack": "class Solution {\n    public String minRemoveToMakeValid(String s) {\n        Stack<Integer> stack = new Stack<>();\n        char[] chars = s.toCharArray();\n        \n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == '(') {\n                stack.push(i); \n            } else if (chars[i] == ')') {\n                if (!stack.isEmpty()) {\n                    stack.pop();\n                } else {\n                    chars[i] = '*'; \n                }\n            }\n        }\n        \n        while (!stack.isEmpty()) {\n            chars[stack.pop()] = '*';\n        }\n        \n        StringBuilder result = new StringBuilder();\n        for (char c : chars) {\n            if (c != '*') {\n                result.append(c);\n            }\n        }\n        \n        return result.toString();\n    }\n}\n"
      }
    },
    "1250": {
      "solution": {
        "number-theory": "#include <vector>\n#include <numeric> \nusing namespace std;\n\nclass Solution {\npublic:\n    bool isGoodArray(vector<int>& nums) {\n        int result = nums[0];\n        \n        for (int i = 1; i < nums.size(); ++i) {\n            result = gcd(result, nums[i]);\n            if (result == 1) {\n                return true;  \n            }\n        }\n        \n        return result == 1;\n    }\n};\n"
      }
    },
    "1251": {
      "solution": {
        "database": ""
      }
    },
    "1252": {
      "solution": {
        "math": ""
      }
    },
    "1253": {
      "solution": {
        "matrix": ""
      }
    },
    "1254": {
      "solution": {
        "union-find": "",
        "matrix": "class Solution {\n    public int closedIsland(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int closedIslands = 0;\n\n        // Mark all `0`s connected to the boundary as `1`s\n        for (int i = 0; i < m; i++) {\n            if (grid[i][0] == 0) dfs(grid, i, 0);\n            if (grid[i][n - 1] == 0) dfs(grid, i, n - 1);\n        }\n        for (int j = 0; j < n; j++) {\n            if (grid[0][j] == 0) dfs(grid, 0, j);\n            if (grid[m - 1][j] == 0) dfs(grid, m - 1, j);\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) {\n                    dfs(grid, i, j);\n                    closedIslands++;\n                }\n            }\n        }\n\n        return closedIslands;\n    }\n\n    private void dfs(int[][] grid, int i, int j) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 1) {\n            return;\n        }\n\n        grid[i][j] = 1; \n        dfs(grid, i + 1, j);\n        dfs(grid, i - 1, j);\n        dfs(grid, i, j + 1);\n        dfs(grid, i, j - 1);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] grid = {\n            {1, 1, 1, 1, 0, 1},\n            {1, 0, 1, 0, 1, 1},\n            {1, 0, 1, 0, 0, 1},\n            {1, 1, 1, 1, 1, 1}\n        };\n\n        int result = solution.closedIsland(grid);\n        System.out.println(\"Number of Closed Islands: \" + result); // Output: 1\n    }\n}\n"
      }
    },
    "1255": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1256": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "1257": {
      "solution": {
        "tree": ""
      }
    },
    "1258": {
      "solution": {
        "union-find": ""
      }
    },
    "1259": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1260": {
      "solution": {
        "matrix": ""
      }
    },
    "1261": {
      "solution": {
        "tree": ""
      }
    },
    "1262": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1263": {
      "solution": {
        "matrix": ""
      }
    },
    "1264": {
      "solution": {
        "database": ""
      }
    },
    "1265": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1266": {
      "solution": {
        "geometry": "class Solution {\npublic:\n    int minTimeToVisitAllPoints(vector<vector<int>>& points) {\n        int ans = 0;\n\n        for (int i = 1; i < points.size(); ++i)\n            ans += max(abs(points[i][0] - points[i - 1][0]),\n                       abs(points[i][1] - points[i - 1][1]));\n\n        return ans;\n    }\n};"
      }
    },
    "1267": {
      "solution": {
        "union-find": ""
      }
    },
    "1268": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1269": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1270": {
      "solution": {
        "database": ""
      }
    },
    "1271": {
      "solution": {
        "math": ""
      }
    },
    "1272": {
      "solution": {
        "array": ""
      }
    },
    "1273": {
      "solution": {
        "tree": ""
      }
    },
    "1274": {
      "solution": {
        "interactive": ""
      }
    },
    "1275": {
      "solution": {
        "matrix": "class Solution {\n    public String tictactoe(int[][] moves) {\n        int[][] board = new int[3][3];\n\n        for (int i = 0; i < moves.length; i++) {\n            int player = (i % 2 == 0) ? 1 : -1;\n            int row = moves[i][0];\n            int col = moves[i][1];\n            board[row][col] = player;\n        }\n\n        if (checkForWin(board, 1)) {\n            return \"A\";\n        } else if (checkForWin(board, -1)) {\n            return \"B\";\n        } else if (moves.length == 9) {\n            return \"Draw\";\n        } else {\n            return \"Pending\";\n        }\n    }\n\n    private boolean checkForWin(int[][] board, int player) {\n        for (int i = 0; i < 3; i++) {\n            if (board[i][0] == player && board[i][1] == player && board[i][2] == player) {\n                return true;\n            }\n            if (board[0][i] == player && board[1][i] == player && board[2][i] == player) {\n                return true;\n            }\n        }\n\n        if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n            return true;\n        }\n        if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n            return true;\n        }\n\n        return false;\n    }\n\n}"
      }
    },
    "1276": {
      "solution": {
        "math": ""
      }
    },
    "1277": {
      "solution": {
        "matrix": "class Solution {\n  public int countSquares(int[][] matrix) {\n    for (int i = 0; i < matrix.length; ++i)\n      for (int j = 0; j < matrix[0].length; ++j)\n        if (matrix[i][j] == 1 && i > 0 && j > 0)\n          matrix[i][j] +=\n              Math.min(matrix[i - 1][j - 1], Math.min(matrix[i - 1][j], matrix[i][j - 1]));\n    return Arrays.stream(matrix).flatMapToInt(Arrays::stream).sum();\n  }\n}"
      }
    },
    "1278": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1279": {
      "solution": {
        "concurrency": "class TrafficLight {\n  private int road = 1;\n\n  public TrafficLight() {\n  }\n\n  public synchronized void carArrived(\n      int carId, \n      int roadId,\n      int direction, \n      Runnable turnGreen, \n      Runnable crossCar \n  ) {\n      if (roadId != road) {\n          turnGreen.run();\n          road = roadId;\n      }\n      crossCar.run();\n  }\n}"
      }
    },
    "1280": {
      "solution": {
        "database": ""
      }
    },
    "1281": {
      "solution": {
        "math": ""
      }
    },
    "1282": {
      "solution": {
        "hash-table": ""
      }
    },
    "1283": {
      "solution": {
        "array": ""
      }
    },
    "1284": {
      "solution": {
        "matrix": ""
      }
    },
    "1285": {
      "solution": {
        "database": ""
      }
    },
    "1286": {
      "solution": {
        "iterator": "class CombinationIterator {\n    private List<String> combinations;\n    private int currentIndex;\n\n    public CombinationIterator(String characters, int combinationLength) {\n        combinations = new ArrayList<>();\n        generateCombinations(characters, combinationLength, 0, new StringBuilder());\n        currentIndex = 0;\n    }\n\n    private void generateCombinations(String characters, int length, int start, StringBuilder sb) {\n        if (sb.length() == length) {\n            combinations.add(sb.toString());\n            return;\n        }\n\n        for (int i = start; i < characters.length(); i++) {\n            sb.append(characters.charAt(i));\n            generateCombinations(characters, length, i + 1, sb);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n\n    public String next() {\n        return combinations.get(currentIndex++);\n    }\n\n    public boolean hasNext() {\n        return currentIndex < combinations.size();\n    }\n}\n\n/**\n * Your CombinationIterator object will be instantiated and called as such:\n * CombinationIterator obj = new CombinationIterator(characters,\n * combinationLength);\n * String param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */"
      }
    },
    "1287": {
      "solution": {
        "array": ""
      }
    },
    "1288": {
      "solution": {
        "sorting": ""
      }
    },
    "1289": {
      "solution": {
        "matrix": ""
      }
    },
    "1290": {
      "solution": {
        "linked-list": ""
      }
    },
    "1291": {
      "solution": {
        "enumeration": ""
      }
    },
    "1292": {
      "solution": {
        "matrix": "public class Solution {\n    public int maxSideLength(int[][] grid, int threshold) {\n        int rows = grid.length, cols = grid[0].length;\n        int[][] prefix = new int[rows + 1][cols + 1];\n\n        for (int i = 1; i <= rows; i++) {\n            for (int j = 1; j <= cols; j++) {\n                prefix[i][j] = grid[i - 1][j - 1] \n                    + prefix[i - 1][j] \n                    + prefix[i][j - 1] \n                    - prefix[i - 1][j - 1];\n            }\n        }\n\n        int left = 0, right = Math.min(rows, cols);\n        int maxLen = 0;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (canFindSquareOfSize(prefix, mid, threshold)) {\n                maxLen = mid;  // mid is a valid side length\n                left = mid + 1;  // try to find a larger square\n            } else {\n                right = mid - 1;  // try to find a smaller square\n            }\n        }\n\n        return maxLen;\n    }\n\n    private boolean canFindSquareOfSize(int[][] prefix, int size, int threshold) {\n        for (int i = size; i < prefix.length; i++) {\n            for (int j = size; j < prefix[0].length; j++) {\n                int sum = prefix[i][j] \n                        - prefix[i - size][j] \n                        - prefix[i][j - size] \n                        + prefix[i - size][j - size];\n                if (sum <= threshold) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n"
      }
    },
    "1293": {
      "solution": {
        "matrix": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public int shortestPath(int[][] grid, int k) {\n        int rows = grid.length, cols = grid[0].length;\n        \n        if (rows == 1 && cols == 1) return 0;\n\n        // 3D visited array to track states with remaining eliminations\n        boolean[][][] visited = new boolean[rows][cols][k + 1];\n        \n        // Queue elements as {x, y, current_distance, remaining_k}\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{0, 0, 0, k});\n        visited[0][0][k] = true;\n\n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int x = curr[0], y = curr[1], dist = curr[2], remainingK = curr[3];\n\n            for (int[] dir : DIRECTIONS) {\n                int newX = x + dir[0];\n                int newY = y + dir[1];\n\n                if (newX >= 0 && newY >= 0 && newX < rows && newY < cols) {\n                    // If we reached the destination\n                    if (newX == rows - 1 && newY == cols - 1) {\n                        return dist + 1;\n                    }\n\n                    int newK = remainingK - grid[newX][newY];\n\n                    // If this state has not been visited and the newK is valid\n                    if (newK >= 0 && !visited[newX][newY][newK]) {\n                        visited[newX][newY][newK] = true;\n                        queue.offer(new int[]{newX, newY, dist + 1, newK});\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n}\n"
      }
    },
    "1294": {
      "solution": {
        "database": ""
      }
    },
    "1295": {
      "solution": {
        "array": ""
      }
    },
    "1296": {
      "solution": {
        "greedy": ""
      }
    },
    "1297": {
      "solution": {
        "sliding-window": "import java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    public int maxFreq(String s, int maxLetters, int minSize, int maxSize) {\n        int n = s.length();\n        int maxCount = 0;\n        Map<String, Integer> substringCount = new HashMap<>();\n        \n        for (int i = 0; i <= n - minSize; ++i) {\n            String sub = s.substring(i, i + minSize);\n            if (isValid(sub, maxLetters)) {\n                substringCount.put(sub, substringCount.getOrDefault(sub, 0) + 1);\n                maxCount = Math.max(maxCount, substringCount.get(sub));\n            }\n        }\n        \n        return maxCount;\n    }\n    \n    private boolean isValid(String sub, int maxLetters) {\n        int[] count = new int[26];\n        int uniqueLetters = 0;\n        for (char c : sub.toCharArray()) {\n            if (count[c - 'a'] == 0) {\n                uniqueLetters++;\n            }\n            count[c - 'a']++;\n        }\n        return uniqueLetters <= maxLetters;\n    }\n}\n"
      }
    },
    "1298": {
      "solution": {
        "graph": ""
      }
    },
    "1299": {
      "solution": {
        "array": ""
      }
    },
    "1300": {
      "solution": {
        "sorting": ""
      }
    },
    "1301": {
      "solution": {
        "matrix": "import java.util.Arrays;\n\npublic class Solution {\n    public int[] pathsWithMaxScore(List<String> board) {\n        int n = board.size();\n        int MOD = 1_000_000_007;\n\n        /*\n          int MOD = 1_000_000_007; defines a modulus value commonly used in algorithmic problems to prevent overflow and keep numbers manageable while working with large values.\n          \n          Why 1_000_000_007? It's a large prime number commonly used in competitive programming to maintain modular arithmetic properties and avoid overflow.\n        */\n\n        int[][] dpScore = new int[n][n];\n        int[][] dpPaths = new int[n][n];\n\n        // Starting point 'E'\n        dpPaths[n - 1][n - 1] = 1;\n\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                char cell = board.get(i).charAt(j);\n\n                if (cell == 'X') continue;\n\n                // Extract numeric value if the cell is not 'S' or 'E'\n                int cellValue = (cell == 'E' || cell == 'S') ? 0 : cell - '0';\n\n                // Look at cells from which we can move to (i, j): right, down, diagonal\n                for (int[] direction : new int[][] {{1, 0}, {0, 1}, {1, 1}}) {\n                    int prevRow = i + direction[0];\n                    int prevCol = j + direction[1];\n\n                    if (prevRow < n && prevCol < n && dpPaths[prevRow][prevCol] > 0) {\n                        int scoreFromPrev = dpScore[prevRow][prevCol] + cellValue;\n\n                        if (scoreFromPrev > dpScore[i][j]) {\n                            dpScore[i][j] = scoreFromPrev;\n                            dpPaths[i][j] = dpPaths[prevRow][prevCol];\n                        } else if (scoreFromPrev == dpScore[i][j]) {\n                            dpPaths[i][j] = (dpPaths[i][j] + dpPaths[prevRow][prevCol]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n\n        // If no path exists to reach 'S', dpPaths[0][0] would be 0\n        return dpPaths[0][0] == 0 ? new int[] {0, 0} : new int[] {dpScore[0][0], dpPaths[0][0]};\n    }\n}\n"
      }
    },
    "1302": {
      "solution": {
        "tree": ""
      }
    },
    "1303": {
      "solution": {
        "database": ""
      }
    },
    "1304": {
      "solution": {
        "math": ""
      }
    },
    "1305": {
      "solution": {
        "binary-search-tree": ""
      }
    },
    "1306": {
      "solution": {
        "breadth-first-search": ""
      }
    },
    "1307": {
      "solution": {
        "backtracking": ""
      }
    },
    "1308": {
      "solution": {
        "database": ""
      }
    },
    "1309": {
      "solution": {
        "string": ""
      }
    },
    "1310": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1311": {
      "solution": {
        "graph": ""
      }
    },
    "1312": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1313": {
      "solution": {
        "array": ""
      }
    },
    "1314": {
      "solution": {
        "matrix": "public class Solution {\n    public int[][] matrixBlockSum(int[][] mat, int K) {\n        int m = mat.length;\n        int n = mat[0].length;\n\n        int[][] prefixSum = new int[m + 1][n + 1];\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                prefixSum[i][j] = mat[i - 1][j - 1]\n                        + prefixSum[i - 1][j]\n                        + prefixSum[i][j - 1]\n                        - prefixSum[i - 1][j - 1];\n            }\n        }\n\n        int[][] result = new int[m][n];\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int r1 = Math.max(0, i - K);\n                int c1 = Math.max(0, j - K);\n                int r2 = Math.min(m - 1, i + K);\n                int c2 = Math.min(n - 1, j + K);\n                \n                result[i][j] = prefixSum[r2 + 1][c2 + 1]\n                             - prefixSum[r1][c2 + 1]\n                             - prefixSum[r2 + 1][c1]\n                             + prefixSum[r1][c1];\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] mat = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        };\n        int K = 1;\n        int[][] result = solution.matrixBlockSum(mat, K);\n        \n        // Print the result\n        for (int[] row : result) {\n            for (int num : row) {\n                System.out.print(num + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n"
      }
    },
    "1315": {
      "solution": {
        "tree": ""
      }
    },
    "1316": {
      "solution": {
        "rolling-hash": ""
      }
    },
    "1317": {
      "solution": {
        "math": ""
      }
    },
    "1318": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "1319": {
      "solution": {
        "union-find": ""
      }
    },
    "1320": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1321": {
      "solution": {
        "database": ""
      }
    },
    "1322": {
      "solution": {
        "database": ""
      }
    },
    "1323": {
      "solution": {
        "greedy": ""
      }
    },
    "1324": {
      "solution": {
        "string": ""
      }
    },
    "1325": {
      "solution": {
        "tree": ""
      }
    },
    "1326": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1327": {
      "solution": {
        "database": ""
      },
    "1328": {
      "solution": {
        "greedy": ""
      }
    },
    "1329": {
      "solution": {
        "sorting": "class Solution {\n public:\n  vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\n    const int m = mat.size();\n    const int n = mat[0].size();\n\n    unordered_map<int, priority_queue<int>> count;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        count[i - j].push(mat[i][j]);\n\n    for (int i = m - 1; i >= 0; --i)\n      for (int j = n - 1; j >= 0; --j)\n        mat[i][j] = count[i - j].top(), count[i - j].pop();\n\n    return mat;\n  }\n};"
      }
    },
    "1330": {
      "solution": {
        "greedy": ""
      }
    },
    "1331": {
      "solution": {
        "sorting": ""
      }
    },
    "1332": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1333": {
      "solution": {
        "sorting": ""
      }
    },
    "1334": {
      "solution": {
        "shortest-path": "class Solution {\npublic:\n    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {\n        vector<vector<int>> dist(n, vector<int>(n, INT_MAX));\n        \n        for (int i = 0; i < n; ++i) {\n            dist[i][i] = 0; // Distance to itself is 0\n        }\n        \n        for (auto& edge : edges) {\n            int u = edge[0], v = edge[1], weight = edge[2];\n            dist[u][v] = weight;\n            dist[v][u] = weight;\n        }\n        \n        for (int k = 0; k < n; ++k) {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX) {\n                        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                    }\n                }\n            }\n        }\n        \n        int minNeighborCount = INT_MAX, resultCity = -1;\n        \n        for (int i = 0; i < n; ++i) {\n            int neighborCount = 0;\n            for (int j = 0; j < n; ++j) {\n                if (i != j && dist[i][j] <= distanceThreshold) {\n                    ++neighborCount;\n                }\n            }\n            \n            if (neighborCount < minNeighborCount || \n               (neighborCount == minNeighborCount && i > resultCity)) {\n                minNeighborCount = neighborCount;\n                resultCity = i;\n            }\n        }\n        \n        return resultCity;\n    }\n};\n"
      }
    },
    "1335": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1336": {
      "solution": {
        "database": ""
      }
    },
    "1337": {
      "solution": {
        "matrix": "import java.util.*;\n\nclass Solution {\n    public int[] kWeakestRows(int[][] mat, int k) {\n        int m = mat.length;\n        int n = mat[0].length;\n        \n        PriorityQueue<int[]> pq = new PriorityQueue<>(\n            (a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]\n        );\n        \n        for (int i = 0; i < m; i++) {\n            int soldiers = countSoldiers(mat[i]);\n            pq.offer(new int[]{i, soldiers});\n        }\n        \n        int[] result = new int[k];\n        for (int i = 0; i < k; i++) {\n            result[i] = pq.poll()[0];\n        }\n        \n        return result;\n    }\n    \n    private int countSoldiers(int[] row) {\n        int count = 0;\n        for (int num : row) {\n            if (num == 1) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n"
      }
    },
    "1338": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1339": {
      "solution": {
        "tree": ""
      }
    },
    "1340": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1341": {
      "solution": {
        "database": ""
      }
    },
    "1342": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "1343": {
      "solution": {
        "sliding-window": "class Solution {\n    public int numOfSubarrays(int[] arr, int k, int threshold) {\n        int count = 0;\n        int windowSum = 0;\n        int n = arr.length;\n        int targetSum = k * threshold;\n\n        for (int i = 0; i < k; i++) {\n            windowSum += arr[i];\n        }\n\n        if (windowSum >= targetSum) {\n            count++;\n        }\n\n        for (int i = k; i < n; i++) {\n            windowSum += arr[i] - arr[i - k];\n            if (windowSum >= targetSum) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n}\n"
      }
    },
    "1344": {
      "solution": {
        "math": ""
      }
    },
    "1345": {
      "solution": {
        "breadth-first-search": ""
      }
    },
    "1346": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1347": {
      "solution": {
        "counting": ""
      }
    },
    "1348": {
      "solution": {
        "ordered-set": ""
      }
    },
    "1349": {
      "solution": {
        "matrix": ""
      }
    },
    "1350": {
      "solution": {
        "database": ""
      }
    },
    "1351": {
      "solution": {
        "matrix": "class Solution {\n    public int countNegatives(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int ans = 0;\n        for (int i = m - 1, j = 0; i >= 0 && j < n;) {\n            if (grid[i][j] < 0) {\n                ans += n - j;\n                --i;\n            } else {\n                ++j;\n            }\n        }\n        return ans;\n    }\n}"
      }
    },
    "1352": {
      "solution": {
        "queue": "class ProductOfNumbers {\n    public ProductOfNumbers() {\n        prefix = new ArrayList<>(Arrays.asList(1));\n    }\n\n    public void add(int num) {\n        if (num == 0)\n            prefix = new ArrayList<>(Arrays.asList(1));\n        else\n            prefix.add(prefix.get(prefix.size() - 1) * num);\n    }\n\n    public int getProduct(int k) {\n        return k >= prefix.size() ? 0\n                : prefix.get(prefix.size() - 1) / prefix.get(prefix.size() - k - 1);\n    }\n\n    private List<Integer> prefix = new ArrayList<>();\n}\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * ProductOfNumbers obj = new ProductOfNumbers();\n * obj.add(num);\n * int param_2 = obj.getProduct(k);\n */"
      }
    },
    "1353": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1354": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1355": {
      "solution": {
        "database": ""
      }
    },
    "1356": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "1357": {
      "solution": {
        "design": ""
      }
    },
    "1358": {
      "solution": {
        "sliding-window": "class Solution {\n    public int numberOfSubstrings(String s) {\n        int[] count = new int[3]; \n        int left = 0;\n        int result = 0;\n        \n        for (int right = 0; right < s.length(); right++) {\n            count[s.charAt(right) - 'a']++;\n            \n            while (count[0] > 0 && count[1] > 0 && count[2] > 0) {\n                result += s.length() - right; \n                count[s.charAt(left) - 'a']--;\n                left++;\n            }\n        }\n        \n        return result;\n    }\n}\n"
      }
    },
    "1359": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1360": {
      "solution": {
        "math": ""
      }
    },
    "1361": {
      "solution": {
        "union-find": ""
      }
    },
    "1362": {
      "solution": {
        "math": ""
      }
    },
    "1363": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1364": {
      "solution": {
        "database": ""
      }
    },
    "1365": {
      "solution": {
        "counting": ""
      }
    },
    "1366": {
      "solution": {
        "counting": ""
      }
    },
    "1367": {
      "solution": {
        "tree": ""
      }
    },
    "1368": {
      "solution": {
        "matrix": "import java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Solution {\n    public int minCost(int[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        boolean[][] visited = new boolean[rows][cols];\n        Deque<int[]> queue = new ArrayDeque<>();\n        queue.offer(new int[] {0, 0, 0});\n        \n        int[][] directions = { \n            {0, 0},   // Stay (no direction change)\n            {0, 1},   // Right\n            {0, -1},  // Left\n            {1, 0},   // Down\n            {-1, 0}   // Up\n        };\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int row = current[0], col = current[1], cost = current[2];\n            \n            if (row == rows - 1 && col == cols - 1) {\n                return cost;\n            }\n            \n            if (visited[row][col]) {\n                continue;\n            }\n            visited[row][col] = true;\n            \n            for (int direction = 1; direction <= 4; ++direction) {\n                int newRow = row + directions[direction][0];\n                int newCol = col + directions[direction][1];\n                \n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {\n                    if (grid[row][col] == direction) {\n                        queue.offerFirst(new int[] {newRow, newCol, cost});\n                    } else {\n                        queue.offer(new int[] {newRow, newCol, cost + 1});\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}\n"
      }
    },
    "1369": {
      "solution": {
        "database": ""
      }
    },
    "1370": {
      "solution": {
        "counting": ""
      }
    },
    "1371": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1372": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1373": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode() {}\n * TreeNode(int val) { this.val = val; }\n * TreeNode(int val, TreeNode left, TreeNode right) {\n * this.val = val;\n * this.left = left;\n * this.right = right;\n * }\n * }\n */\nclass Solution {\n    private int maxSum = 0;\n\n    public int maxSumBST(TreeNode root) {\n        dfs(root);\n        return maxSum;\n    }\n\n    private int[] dfs(TreeNode node) {\n        if (node == null) {\n            return new int[] { 1, Integer.MAX_VALUE, Integer.MIN_VALUE, 0 }; // isBST, min, max, sum\n        }\n\n        int[] left = dfs(node.left);\n        int[] right = dfs(node.right);\n\n        if (left[0] == 1 && right[0] == 1 && node.val > left[2] && node.val < right[1]) {\n            int sum = left[3] + right[3] + node.val;\n            maxSum = Math.max(maxSum, sum);\n            int min = Math.min(left[1], node.val);\n            int max = Math.max(right[2], node.val);\n            return new int[] { 1, min, max, sum };\n        } else {\n            return new int[] { 0, 0, 0, 0 }; // not a BST\n        }\n    }\n}\n"
      }
    },
    "1374": {
      "solution": {
        "string": ""
      }
    },
    "1375": {
      "solution": {
        "array": ""
      }
    },
    "1376": {
      "solution": {
        "tree": ""
      }
    },
    "1377": {
      "solution": {
        "tree": ""
      }
    },
    "1378": {
      "solution": {
        "database": ""
      }
    },
    "1379": {
      "solution": {
        "tree": ""
      }
    },
    "1380": {
      "solution": {
        "matrix": ""
      }
    },
    "1381": {
      "solution": {
        "stack": ""
      }
    },
    "1382": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode balanceBST(TreeNode root) {\n        List<TreeNode> nodes = new ArrayList<>();\n        inorderTraversal(root, nodes);\n        return buildBalancedBST(nodes, 0, nodes.size() - 1);\n    }\n    \n    private void inorderTraversal(TreeNode root, List<TreeNode> nodes) {\n        if (root == null) {\n            return;\n        }\n        inorderTraversal(root.left, nodes);\n        nodes.add(root);\n        inorderTraversal(root.right, nodes);\n    }\n    \n    private TreeNode buildBalancedBST(List<TreeNode> nodes, int start, int end) {\n        if (start > end) {\n            return null;\n        }\n        int mid = (start + end) / 2;\n        TreeNode node = nodes.get(mid);\n        node.left = buildBalancedBST(nodes, start, mid - 1);\n        node.right = buildBalancedBST(nodes, mid + 1, end);\n        return node;\n    }\n}\n"
      }
    },
    "1383": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1384": {
      "solution": {
        "database": ""
      }
    },
    "1385": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1386": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "1387": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1388": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1389": {
      "solution": {
        "array": ""
      }
    },
    "1390": {
      "solution": {
        "math": ""
      }
    },
    "1391": {
      "solution": {
        "matrix": "import java.util.*;\n\nclass Solution {\n    private static final int[][][] DIRECTIONS = {\n        {}, // Empty for 0-index placeholder\n        {{0, -1}, {0, 1}},      // Type 1: left <-> right\n        {{-1, 0}, {1, 0}},      // Type 2: up <-> down\n        {{0, -1}, {1, 0}},      // Type 3: left <-> down\n        {{0, 1}, {1, 0}},       // Type 4: right <-> down\n        {{0, -1}, {-1, 0}},     // Type 5: left <-> up\n        {{0, 1}, {-1, 0}}       // Type 6: right <-> up\n    };\n\n    public boolean hasValidPath(int[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        boolean[][] visited = new boolean[rows][cols];\n        \n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[] {0, 0});\n        visited[0][0] = true;\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int row = current[0], col = current[1];\n            \n            // If reached the bottom-right cell, return true\n            if (row == rows - 1 && col == cols - 1) {\n                return true;\n            }\n            \n            int streetType = grid[row][col];\n            \n            // Explore each possible direction from the current cell\n            for (int[] direction : DIRECTIONS[streetType]) {\n                int newRow = row + direction[0];\n                int newCol = col + direction[1];\n                \n                // Check if new cell is within bounds and not visited\n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && !visited[newRow][newCol]) {\n                    int nextStreetType = grid[newRow][newCol];\n                    \n                    // Check if the new cell's type allows connecting back to the current cell\n                    if (canConnect(newRow, newCol, row, col, nextStreetType)) {\n                        visited[newRow][newCol] = true;\n                        queue.offer(new int[] {newRow, newCol});\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    // Check if the new cell's street type can connect back to the current cell\n    private boolean canConnect(int newRow, int newCol, int prevRow, int prevCol, int nextStreetType) {\n        for (int[] direction : DIRECTIONS[nextStreetType]) {\n            int expectedRow = newRow + direction[0];\n            int expectedCol = newCol + direction[1];\n            if (expectedRow == prevRow && expectedCol == prevCol) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
      }
    },
    "1392": {
      "solution": {
        "rolling-hash": "class Solution {\npublic:\n    string longestPrefix(string s) {\n        int n = s.length();\n        vector<int> lps(n, 0); \n        \n        int len = 0;\n        for (int i = 1; i < n; ++i) {\n            while (len > 0 && s[i] != s[len]) {\n                len = lps[len - 1];\n            }\n            \n            if (s[i] == s[len]) {\n                ++len; \n            }\n            \n            lps[i] = len; \n        }\n        \n        // The value at lps[n - 1] gives the length of the longest happy prefix\n        return s.substr(0, lps[n - 1]);\n    }\n};\n"
      }
    },
    "1393": {
      "solution": {
        "database": ""
      }
    },
    "1394": {
      "solution": {
        "counting": ""
      }
    },
    "1395": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1396": {
      "solution": {
        "design": ""
      }
    },
    "1397": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1398": {
      "solution": {
        "database": ""
      }
    },
    "1399": {
      "solution": {
        "math": ""
      }
    },
    "1400": {
      "solution": {
        "counting": ""
      }
    },
    "1401": {
      "solution": {
        "geometry": "class Solution {\npublic:\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1,\n                      int x2, int y2) {\n        int nearestX = clamp(xCenter, x1, x2);\n        int nearestY = clamp(yCenter, y1, y2);\n\n        int dx = nearestX - xCenter;\n        int dy = nearestY - yCenter;\n        int distanceSquared = dx * dx + dy * dy;\n\n        return distanceSquared <= radius * radius;\n    }\n\nprivate:\n    int clamp(int value, int minVal, int maxVal) {\n        if (value < minVal)\n            return minVal;\n        if (value > maxVal)\n            return maxVal;\n        return value;\n    }\n};\n"
      }
    },
    "1402": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1403": {
      "solution": {
        "greedy": ""
      }
    },
    "1404": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "1405": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1406": {
      "solution": {
        "game-theory": "class Solution {\npublic:\n    string stoneGameIII(vector<int>& stoneValue) {\n        int n = stoneValue.size();\n        vector<int> dp(n + 1, 0); // dp[i] stores the maximum score difference\n                                  // Alice can achieve starting from i\n        vector<int> suffixSum(n + 1, 0);\n\n        for (int i = n - 1; i >= 0; --i) {\n            suffixSum[i] = suffixSum[i + 1] + stoneValue[i];\n        }\n\n        for (int i = n - 1; i >= 0; --i) {\n            dp[i] = INT_MIN;\n            for (int k = 1; k <= 3 && i + k <= n; ++k) {\n                int currentSum = suffixSum[i] - suffixSum[i + k];\n                dp[i] = max(dp[i], currentSum - dp[i + k]);\n            }\n        }\n\n        if (dp[0] > 0)\n            return \"Alice\";\n        else if (dp[0] < 0)\n            return \"Bob\";\n        else\n            return \"Tie\";\n    }\n};\n"
      }
    },
    "1407": {
      "solution": {
        "database": ""
      }
    },
    "1408": {
      "solution": {
        "string-matching": ""
      }
    },
    "1409": {
      "solution": {
        "binary-indexed-tree": "class FenwickTree {\n    public FenwickTree(int n) {\n        sums = new int[n + 1];\n    }\n\n    public void add(int i, int delta) {\n        while (i < sums.length) {\n            sums[i] += delta;\n            i += lowbit(i);\n        }\n    }\n\n    public int get(int i) {\n        int sum = 0;\n        while (i > 0) {\n            sum += sums[i];\n            i -= lowbit(i);\n        }\n        return sum;\n    }\n\n    private int[] sums;\n\n    private static int lowbit(int i) {\n        return i & -i;\n    }\n}\n\nclass Solution {\n    public int[] processQueries(int[] queries, int m) {\n        int[] ans = new int[queries.length];\n        FenwickTree tree = new FenwickTree(2 * m + 1);\n        Map<Integer, Integer> numToIndex = new HashMap<>();\n\n        for (int num = 1; num <= m; ++num) {\n            numToIndex.put(num, num + m);\n            tree.add(num + m, 1);\n        }\n\n        int nextEmptyIndex = m; // Map 0 to m.\n\n        for (int i = 0; i < queries.length; ++i) {\n            int query = queries[i];\n            int index = numToIndex.get(query);\n            ans[i] = tree.get(index - 1);\n            tree.add(index, -1);\n            tree.add(nextEmptyIndex, 1);\n            numToIndex.put(query, nextEmptyIndex--);\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "1410": {
      "solution": {
        "hash-table": ""
      }
    },
    "1411": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1412": {
      "solution": {
        "database": ""
      }
    },
    "1413": {
      "solution": {
        "prefix-sum": "public class Solution {\n    public int minStartValue(int[] nums) {\n        int runningSum = 0;\n        int minPrefixSum = Integer.MAX_VALUE;\n        \n        for (int num : nums) {\n            runningSum += num;\n            minPrefixSum = Math.min(minPrefixSum, runningSum);\n        }\n        \n        return (minPrefixSum < 0) ? 1 - minPrefixSum : 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[] nums = {-3, 2, -3, 4, 2};\n        System.out.println(solution.minStartValue(nums)); // Output: 5\n    }\n}\n"
      }
    },
    "1414": {
      "solution": {
        "greedy": ""
      }
    },
    "1415": {
      "solution": {
        "backtracking": ""
      }
    },
    "1416": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1417": {
      "solution": {
        "string": ""
      }
    },
    "1418": {
      "solution": {
        "ordered-set": ""
      }
    },
    "1419": {
      "solution": {
        "counting": ""
      }
    },
    "1420": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1421": {
      "solution": {
        "database": ""
      }
    },
    "1422": {
      "solution": {
        "prefix-sum": "public class Solution {\n    public int maxScore(String s) {\n        int totalOnes = 0;\n\n        // Count total number of '1's in the string\n        for (char c : s.toCharArray()) {\n            if (c == '1') {\n                totalOnes++;\n            }\n        }\n\n        int maxScore = 0;\n        int leftZeros = 0; // Count of '0's in the left part\n        int onesSeen = 0;  // Count of '1's seen so far\n\n        for (int i = 0; i < s.length() - 1; i++) { // Exclude the last character\n            if (s.charAt(i) == '0') {\n                leftZeros++;\n            } else {\n                onesSeen++;\n            }\n\n            int rightOnes = totalOnes - onesSeen; // Remaining '1's in the right part\n            int score = leftZeros + rightOnes;\n\n            maxScore = Math.max(maxScore, score);\n        }\n\n        return maxScore;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.maxScore(\"011101\")); // Output: 5\n    }\n}\n"
      }
    },
    "1423": {
      "solution": {
        "sliding-window": "class Solution {\n    public int maxScore(int[] cardPoints, int k) {\n        int n = cardPoints.length;\n        int totalPoints = 0;\n        for (int i = 0; i < k; i++) {\n            totalPoints += cardPoints[i];\n        }\n\n        int maxPoints = totalPoints;\n\n        for (int i = 0; i < k; i++) {\n            totalPoints = totalPoints - cardPoints[k - 1 - i] + cardPoints[n - 1 - i];\n            maxPoints = Math.max(maxPoints, totalPoints);\n        }\n\n        return maxPoints;\n    }\n}"
      }
    },
    "1424": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1425": {
      "solution": {
        "monotonic-queue": "import java.util.Deque;\nimport java.util.LinkedList;\n\npublic class Solution {\n    public int constrainedSubsetSum(int[] nums, int k) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        Deque<Integer> deque = new LinkedList<>();\n        int maxSum = nums[0];\n\n        for (int i = 0; i < n; i++) {\n            dp[i] = nums[i];\n            if (!deque.isEmpty()) {\n                dp[i] = Math.max(dp[i], nums[i] + dp[deque.peekFirst()]);\n            }\n            maxSum = Math.max(maxSum, dp[i]);\n\n            while (!deque.isEmpty() && dp[i] >= dp[deque.peekLast()]) {\n                deque.pollLast();\n            }\n\n            deque.addLast(i);\n            \n            if (i - deque.peekFirst() >= k) {\n                deque.pollFirst();\n            }\n        }\n\n        return maxSum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {10, 2, -10, 5, 20};\n        int k = 2;\n        System.out.println(solution.constrainedSubsetSum(nums, k));  // Output: 37\n    }\n}\n"
      }
    },
    "1426": {
      "solution": {
        "hash-table": ""
      }
    },
    "1427": {
      "solution": {
        "math": ""
      }
    },
    "1428": {
      "solution": {
        "matrix": "class Solution {\n  public int leftMostColumnWithOne(BinaryMatrix binaryMatrix) {\n    List<Integer> dimensions = binaryMatrix.dimensions();\n    int m = dimensions.get(0);\n    int n = dimensions.get(1);\n    int ans = -1;\n    int l = 0;\n    int r = n - 1;\n\n    while (l <= r) {\n      int mid = (l + r) / 2;\n      if (existOne(binaryMatrix, m, mid)) {\n        ans = mid;\n        r = mid - 1;\n      } else {\n        l = mid + 1;\n      }\n    }\n\n    return ans;\n  }\n\n  private boolean existOne(BinaryMatrix binaryMatrix, int m, int col) {\n    for (int i = 0; i < m; ++i)\n      if (binaryMatrix.get(i, col) == 1)\n        return true;\n    return false;\n  }\n}"
      }
    },
    "1429": {
      "solution": {
        "queue": "class FirstUnique {\n    private Map<Integer, Integer> count = new HashMap<>();\n    private Set<Integer> unique = new LinkedHashSet<>();\n\n    public FirstUnique(int[] nums) {\n        for (int v : nums) {\n            count.put(v, count.getOrDefault(v, 0) + 1);\n        }\n        for (int v : nums) {\n            if (count.get(v) == 1) {\n                unique.add(v);\n            }\n        }\n    }\n\n    public int showFirstUnique() {\n        return unique.isEmpty() ? -1 : unique.iterator().next();\n    }\n\n    public void add(int value) {\n        count.put(value, count.getOrDefault(value, 0) + 1);\n        if (count.get(value) == 1) {\n            unique.add(value);\n        } else {\n            unique.remove(value);\n        }\n    }\n}\n\n/**\n * Your FirstUnique object will be instantiated and called as such:\n * FirstUnique obj = new FirstUnique(nums);\n * int param_1 = obj.showFirstUnique();\n * obj.add(value);\n */"
      }
    },
    "1430": {
      "solution": {
        "tree": ""
      }
    },
    "1431": {
      "solution": {
        "array": ""
      }
    },
    "1432": {
      "solution": {
        "greedy": ""
      }
    },
    "1433": {
      "solution": {
        "greedy": ""
      }
    },
    "1434": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1435": {
      "solution": {
        "database": ""
      }
    },
    "1436": {
      "solution": {
        "hash-table": ""
      }
    },
    "1437": {
      "solution": {
        "array": ""
      }
    },
    "1438": {
      "solution": {
        "monotonic-queue": "import java.util.Deque;\nimport java.util.LinkedList;\n\npublic class Solution {\n    public int longestSubarray(int[] nums, int limit) {\n        int left = 0, right = 0;\n        int maxLength = 0;\n        Deque<Integer> maxDeque = new LinkedList<>();\n        Deque<Integer> minDeque = new LinkedList<>();\n\n        while (right < nums.length) {\n            while (!maxDeque.isEmpty() && maxDeque.peekLast() < nums[right]) {\n                maxDeque.pollLast();\n            }\n            maxDeque.addLast(nums[right]);\n\n            while (!minDeque.isEmpty() && minDeque.peekLast() > nums[right]) {\n                minDeque.pollLast();\n            }\n            minDeque.addLast(nums[right]);\n\n            while (maxDeque.peekFirst() - minDeque.peekFirst() > limit) {\n                if (maxDeque.peekFirst() == nums[left]) {\n                    maxDeque.pollFirst();\n                }\n                if (minDeque.peekFirst() == nums[left]) {\n                    minDeque.pollFirst();\n                }\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        }\n\n        return maxLength;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {8, 2, 4, 7};\n        int limit = 4;\n        System.out.println(solution.longestSubarray(nums, limit));  // Output: 2\n    }\n}\n"
      }
    },
    "1439": {
      "solution": {
        "matrix": "class T {\n    public int i;\n    public int j;\n    public int sum; // nums1[i] + nums2[j]\n\n    public T(int i, int j, int sum) {\n        this.i = i;\n        this.j = j;\n        this.sum = sum;\n    }\n}\n\nclass Solution {\n    public int kthSmallest(int[][] mat, int k) {\n        int[] row = mat[0];\n\n        for (int i = 1; i < mat.length; ++i)\n            row = kSmallestPairSums(row, mat[i], k);\n\n        return row[k - 1];\n    }\n\n    private int[] kSmallestPairSums(int[] nums1, int[] nums2, int k) {\n        List<Integer> ans = new ArrayList<>();\n        Queue<T> minHeap = new PriorityQueue<>((a, b) -> a.sum - b.sum);\n\n        for (int i = 0; i < k && i < nums1.length; ++i)\n            minHeap.offer(new T(i, 0, nums1[i] + nums2[0]));\n\n        while (!minHeap.isEmpty() && ans.size() < k) {\n            int i = minHeap.peek().i;\n            int j = minHeap.poll().j;\n            ans.add(nums1[i] + nums2[j]);\n            if (j + 1 < nums2.length)\n                minHeap.offer(new T(i, j + 1, nums1[i] + nums2[j + 1]));\n        }\n\n        return ans.stream().mapToInt(Integer::intValue).toArray();\n    }\n}"
      }
    },
    "1440": {
      "solution": {
        "database": ""
      }
    },
    "1441": {
      "solution": {
        "stack": ""
      }
    },
    "1442": {
      "solution": {
        "prefix-sum": "class Solution {\n    public int countTriplets(int[] arr) {\n        int ans = 0;\n        int n = arr.length;\n        \n        // Create a prefix XOR array\n        int[] xors = new int[n + 1];\n        xors[0] = 0;\n        \n        for (int i = 0; i < n; i++) {\n            xors[i + 1] = xors[i] ^ arr[i];\n        }\n        \n        // Iterate over all possible triplets\n        for (int j = 1; j < n; j++) {\n            for (int i = 0; i < j; i++) {\n                int xors_i = xors[j] ^ xors[i];\n                for (int k = j; k < n; k++) {\n                    int xors_k = xors[k + 1] ^ xors[j];\n                    if (xors_i == xors_k) {\n                        ans++;\n                    }\n                }\n            }\n        }\n        \n        return ans;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.countTriplets(new int[]{2, 3, 1, 6, 7})); // Output: 4\n        System.out.println(solution.countTriplets(new int[]{1, 1, 1, 1, 1})); // Output: 10\n        System.out.println(solution.countTriplets(new int[]{2, 3}));          // Output: 0\n    }\n}\n"
      }
    },
    "1443": {
      "solution": {
        "tree": ""
      }
    },
    "1444": {
      "solution": {
        "matrix": ""
      }
    },
    "1445": {
      "solution": {
        "database": ""
      }
    },
    "1446": {
      "solution": {
        "string": ""
      }
    },
    "1447": {
      "solution": {
        "number-theory": ""
      }
    },
    "1448": {
      "solution": {
        "tree": ""
      }
    },
    "1449": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1450": {
      "solution": {
        "array": ""
      }
    },
    "1451": {
      "solution": {
        "sorting": ""
      }
    },
    "1452": {
      "solution": {
        "hash-table": ""
      }
    },
    "1453": {
      "solution": {
        "geometry": ""
      }
    },
    "1454": {
      "solution": {
        "database": ""
      }
    },
    "1455": {
      "solution": {
        "string-matching": "class Solution {\npublic:\n    int isPrefixOfWord(string sentence, string searchWord) {\n        stringstream ss(sentence);\n        string word;\n        int index = 1; // Start with 1-based index\n\n        while (ss >> word) {\n            if (word.find(searchWord) == 0) {\n                return index; // Found the prefix match, return 1-based index\n            }\n            index++;\n        }\n\n        return -1; // No word starts with searchWord\n    }\n};\n"
      }
    },
    "1456": {
      "solution": {
        "sliding-window": "class Solution {\n    public int maxVowels(String s, int k) {\n        int maxVowels = 0;\n        int currentVowels = 0;\n        int n = s.length();\n\n        for (int i = 0; i < k; i++) {\n            if (isVowel(s.charAt(i))) {\n                currentVowels++;\n            }\n        }\n\n        maxVowels = currentVowels;\n\n        for (int i = k; i < n; i++) {\n            if (isVowel(s.charAt(i))) {\n                currentVowels++;\n            }\n            if (isVowel(s.charAt(i - k))) {\n                currentVowels--;\n            }\n            maxVowels = Math.max(maxVowels, currentVowels);\n        }\n\n        return maxVowels;\n    }\n\n    private boolean isVowel(char c) {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n               c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n    }\n}\n"
      }
    },
    "1457": {
      "solution": {
        "tree": ""
      }
    },
    "1458": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1459": {
      "solution": {
        "database": ""
      }
    },
    "1460": {
      "solution": {
        "sorting": ""
      }
    },
    "1461": {
      "solution": {
        "rolling-hash": ""
      }
    },
    "1462": {
      "solution": {
        "topological-sort": "import java.util.*;\n\nclass Solution {\n    public List<Boolean> checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < numCourses; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        int[] inDegree = new int[numCourses];\n        boolean[][] prerequisite = new boolean[numCourses][numCourses];\n\n        for (int[] edge : prerequisites) {\n            graph.get(edge[0]).add(edge[1]);\n            inDegree[edge[1]]++;\n        }\n\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < numCourses; i++) {\n            if (inDegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            for (int neighbor : graph.get(current)) {\n                prerequisite[current][neighbor] = true;\n                \n                for (int i = 0; i < numCourses; i++) {\n                    if (prerequisite[i][current]) {\n                        prerequisite[i][neighbor] = true;\n                    }\n                }\n                \n                inDegree[neighbor]--;\n                if (inDegree[neighbor] == 0) {\n                    queue.offer(neighbor);\n                }\n            }\n        }\n\n        List<Boolean> result = new ArrayList<>();\n        for (int[] query : queries) {\n            result.add(prerequisite[query[0]][query[1]]);\n        }\n\n        return result;\n    }\n}\n"
      }
    },
    "1463": {
      "solution": {
        "matrix": "class Solution {\n    public int cherryPickup(int[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        Integer[][][] memo = new Integer[rows][cols][cols];\n        \n        return dfs(grid, 0, 0, cols - 1, memo);\n    }\n    \n    private int dfs(int[][] grid, int row, int col1, int col2, Integer[][][] memo) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        \n        if (col1 < 0 || col1 >= cols || col2 < 0 || col2 >= cols) {\n            return 0;\n        }\n        \n        if (memo[row][col1][col2] != null) {\n            return memo[row][col1][col2];\n        }\n        \n        int result = grid[row][col1];\n        if (col1 != col2) {\n            result += grid[row][col2];\n        }\n        \n        if (row < rows - 1) {\n            int maxCherries = 0;\n            for (int newCol1 = col1 - 1; newCol1 <= col1 + 1; newCol1++) {\n                for (int newCol2 = col2 - 1; newCol2 <= col2 + 1; newCol2++) {\n                    maxCherries = Math.max(maxCherries, dfs(grid, row + 1, newCol1, newCol2, memo));\n                }\n            }\n            result += maxCherries;\n        }\n        \n        memo[row][col1][col2] = result;\n        return result;\n    }\n}\n"
      }
    },
    "1464": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1465": {
      "solution": {
        "greedy": ""
      }
    },
    "1466": {
      "solution": {
        "graph": ""
      }
    },
    "1467": {
      "solution": {
        "probability-and-statistics": "enum BoxCase {\n    kEqualBalls, kEqualDistantBalls\n}\n\nclass Solution {\n    public double getProbability(int[] balls) {\n      int n = Arrays.stream(balls).sum() / 2;\n        return cases(balls, 0, 0, 0, 0, 0, n, BoxCase.kEqualDistantBalls) /\n                cases(balls, 0, 0, 0, 0, 0, n, BoxCase.kEqualBalls);\n    }\n\n    private int[] fact = { 1, 1, 2, 6, 24, 120, 720 };\n\n    double cases(int[] balls, int i, int ballsCountA, int ballsCountB, int colorsCountA,\n            int colorsCountB, int n, BoxCase boxCase) {\n        if (ballsCountA > n || ballsCountB > n)\n            return 0;\n        if (i == balls.length)\n            return boxCase == BoxCase.kEqualBalls ? 1 : (colorsCountA == colorsCountB ? 1 : 0);\n\n        double ans = 0;\n\n        for (int ballsTakenA = 0; ballsTakenA <= balls[i]; ++ballsTakenA) {\n          int ballsTakenB = balls[i] - ballsTakenA;\n          int newcolorsCountA = colorsCountA + (ballsTakenA > 0 ? 1 : 0);\n          int newcolorsCountB = colorsCountB + (ballsTakenB > 0 ? 1 : 0);\n            ans += cases(balls, i + 1, ballsCountA + ballsTakenA, ballsCountB + ballsTakenB,\n                    newcolorsCountA, newcolorsCountB, n, boxCase) /\n                    (fact[ballsTakenA] * fact[ballsTakenB]);\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "1468": {
      "solution": {
        "database": ""
      }
    },
    "1469": {
      "solution": {
        "tree": ""
      }
    },
    "1470": {
      "solution": {
        "array": ""
      }
    },
    "1471": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1472": {
      "solution": {
        "doubly-linked-list": "class BrowserHistory {\n    class Node {\n        String url;\n        Node prev, next;\n        \n        Node(String url) {\n            this.url = url;\n        }\n      }\n    \n    private Node current;\n\n    public BrowserHistory(String homepage) {\n        current = new Node(homepage);\n      }\n\n    public void visit(String url) {\n        Node newNode = new Node(url);\n        current.next = newNode;\n        newNode.prev = current;\n        current = newNode;\n      }\n\n    public String back(int steps) {\n        while (steps > 0 && current.prev != null) {\n            current = current.prev;\n            steps--;\n        }\n        return current.url;\n      }\n\n    public String forward(int steps) {\n        while (steps > 0 && current.next != null) {\n            current = current.next;\n            steps--;\n        }\n        return current.url;\n      }\n    }\n    /**\n * Your BrowserHistory object will be instantiated and called as such:\n * BrowserHistory obj = new BrowserHistory(homepage);\n * obj.visit(url);\n * String param_2 = obj.back(steps);\n * String param_3 = obj.forward(steps);\n */"
      }
    },
    "1473": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1474": {
      "solution": {
        "linked-list": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode deleteNodes(ListNode head, int m, int n) {\n        ListNode pre = head;\n        while (pre != null) {\n            for (int i = 0; i < m - 1 && pre != null; ++i) {\n                pre = pre.next;\n            }\n            if (pre == null) {\n                return head;\n            }\n            ListNode cur = pre;\n            for (int i = 0; i < n && cur != null; ++i) {\n                cur = cur.next;\n            }\n            pre.next = cur == null ? null : cur.next;\n            pre = pre.next;\n        }\n        return head;\n    }\n}"
      }
    },
    "1475": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "1476": {
      "solution": {
        "matrix": ""
      }
    },
    "1477": {
      "solution": {
        "sliding-window": "class Solution {\n    public int minSumOfLengths(int[] arr, int target) {\n        int n = arr.length;\n        int[] minLength = new int[n];\n        Arrays.fill(minLength, Integer.MAX_VALUE);\n        \n        int left = 0, currSum = 0, minLen = Integer.MAX_VALUE, result = Integer.MAX_VALUE;\n\n        for (int right = 0; right < n; ++right) {\n            currSum += arr[right];\n\n            while (currSum > target) {\n                currSum -= arr[left++];\n            }\n\n            if (currSum == target) {\n                int currLen = right - left + 1;\n                if (left > 0 && minLength[left - 1] != Integer.MAX_VALUE) {\n                    result = Math.min(result, currLen + minLength[left - 1]);\n                }\n                minLen = Math.min(minLen, currLen);\n            }\n\n            minLength[right] = minLen;\n        }\n\n        return result == Integer.MAX_VALUE ? -1 : result;\n    }\n}\n"
      }
    },
    "1478": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1479": {
      "solution": {
        "database": ""
      }
    },
    "1480": {
      "solution": {
        "prefix-sum": "class Solution {\n    public int[] runningSum(int[] nums) {\n        int n = nums.length;\n        int[] runningSum = new int[n];\n        runningSum[0] = nums[0]; \n        \n        for (int i = 1; i < n; i++) {\n            runningSum[i] = runningSum[i - 1] + nums[i];\n        }\n        \n        return runningSum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[] result1 = solution.runningSum(new int[]{1, 2, 3, 4});\n        System.out.println(java.util.Arrays.toString(result1)); // Output: [1, 3, 6, 10]\n\n        int[] result2 = solution.runningSum(new int[]{1, 1, 1, 1, 1});\n        System.out.println(java.util.Arrays.toString(result2)); // Output: [1, 2, 3, 4, 5]\n\n        int[] result3 = solution.runningSum(new int[]{3, 1, 2, 10, 1});\n        System.out.println(java.util.Arrays.toString(result3)); // Output: [3, 4, 6, 16, 17]\n    }\n}\n"
      }
    },
    "1481": {
      "solution": {
        "counting": ""
      }
    },
    "1482": {
      "solution": {
        "array": ""
      }
    },
    "1483": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1484": {
      "solution": {
        "database": ""
      }
    },
    "1485": {
      "solution": {
        "tree": ""
      }
    },
    "1486": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "1487": {
      "solution": {
        "hash-table": ""
      }
    },
    "1488": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1489": {
      "solution": {
        "minimum-spanning-tree": "import java.util.*;\n\nclass UnionFind {\n    private int[] parent;\n    private int[] rank;\n\n    public UnionFind(int n) {\n        parent = new int[n];\n        rank = new int[n];\n        for (int i = 0; i < n; ++i)\n            parent[i] = i;\n    }\n\n    public void unionByRank(int u, int v) {\n        int i = find(u);\n        int j = find(v);\n        if (i == j)\n            return;\n        if (rank[i] < rank[j]) {\n            parent[i] = j;\n        } else if (rank[i] > rank[j]) {\n            parent[j] = i;\n        } else {\n            parent[i] = j;\n            ++rank[j];\n        }\n    }\n\n    public int find(int u) {\n        return parent[u] == u ? u : (parent[u] = find(parent[u]));\n    }\n}\n\nclass Solution {\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\n        List<Integer> criticalEdges = new ArrayList<>();\n        List<Integer> pseudoCriticalEdges = new ArrayList<>();\n\n        for (int i = 0; i < edges.length; ++i)\n            edges[i] = new int[] {edges[i][0], edges[i][1], edges[i][2], i};\n\n        Arrays.sort(edges, (a, b) -> a[2] - b[2]);\n\n        final int mstWeight = getMSTWeight(n, edges, new int[] {}, -1);\n\n        for (int[] edge : edges) {\n            final int index = edge[3];\n            // Deleting the `edge` increases the MST's weight or makes the MST invalid.\n            if (getMSTWeight(n, edges, new int[] {}, index) > mstWeight)\n                criticalEdges.add(index);\n            // If an edge can be in any MST, we can always add `edge` to the edge set.\n            else if (getMSTWeight(n, edges, edge, -1) == mstWeight)\n                pseudoCriticalEdges.add(index);\n        }\n\n        return new ArrayList<>(Arrays.asList(criticalEdges, pseudoCriticalEdges));\n    }\n\n    private int getMSTWeight(int n, int[][] edges, int[] firstEdge, int deletedEdgeIndex) {\n        int mstWeight = 0;\n        UnionFind uf = new UnionFind(n);\n\n        if (firstEdge.length == 4) {\n            uf.unionByRank(firstEdge[0], firstEdge[1]);\n            mstWeight += firstEdge[2];\n        }\n\n        for (int[] edge : edges) {\n            final int u = edge[0];\n            final int v = edge[1];\n            final int weight = edge[2];\n            final int index = edge[3];\n            if (index == deletedEdgeIndex)\n                continue;\n            if (uf.find(u) == uf.find(v))\n                continue;\n            uf.unionByRank(u, v);\n            mstWeight += weight;\n        }\n\n        final int root = uf.find(0);\n        for (int i = 0; i < n; ++i)\n            if (uf.find(i) != root)\n                return Integer.MAX_VALUE;\n\n        return mstWeight;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        int n = 14;\n        int[][] edges = {\n            {0, 1, 13}, {0, 2, 6}, {2, 3, 13}, {3, 4, 4}, {0, 5, 11}, {4, 6, 14}, {4, 7, 8}, \n            {2, 8, 6}, {4, 9, 6}, {7, 10, 4}, {5, 11, 3}, {6, 12, 7}, {12, 13, 9}, {7, 13, 2}, \n            {5, 13, 10}, {0, 6, 4}, {2, 7, 3}, {0, 7, 8}, {1, 12, 9}, {10, 12, 11}, {1, 2, 7}, \n            {1, 3, 10}, {3, 10, 6}, {6, 10, 4}, {4, 8, 5}, {1, 13, 4}, {11, 13, 8}, {2, 12, 10}, \n            {5, 8, 1}, {3, 7, 6}, {7, 12, 12}, {1, 7, 9}, {5, 9, 1}, {2, 13, 10}, {10, 11, 4}, \n            {3, 5, 10}, {6, 11, 14}, {5, 12, 3}, {0, 8, 13}, {8, 9, 1}, {3, 6, 8}, {0, 3, 4}, \n            {2, 9, 6}, {0, 11, 4}, {2, 5, 14}, {4, 11, 2}, {7, 11, 11}, {1, 11, 6}, {2, 10, 12}, \n            {0, 13, 4}, {3, 9, 9}, {4, 12, 3}, {6, 7, 10}, {6, 8, 13}, {9, 11, 3}, {1, 6, 2}, \n            {2, 4, 12}, {0, 10, 3}, {3, 12, 1}, {3, 8, 12}, {1, 8, 6}, {8, 13, 2}, {10, 13, 12}, \n            {9, 13, 11}, {2, 11, 14}, {5, 10, 9}, {5, 6, 10}, {2, 6, 9}, {8, 11, 3}\n        };\n        List<List<Integer>> result = sol.findCriticalAndPseudoCriticalEdges(n, edges);\n        System.out.println(result); \n    }\n}\n"
      }
    },
    "1490": {
      "solution": {
        "tree": ""
      }
    },
    "1491": {
      "solution": {
        "sorting": ""
      }
    },
    "1492": {
      "solution": {
        "number-theory": "#include <vector>\n#include <cmath>\nusing namespace std;\n\nclass Solution {\npublic:\n    int kthFactor(int n, int k) {\n        vector<int> factors;\n        \n        for (int i = 1; i <= sqrt(n); ++i) {\n            if (n % i == 0) {\n                factors.push_back(i); \n                if (i != n / i) {  \n                    factors.push_back(n / i);  // n/i is also a factor\n                }\n            }\n        }\n        \n        sort(factors.begin(), factors.end());\n        \n        if (k > factors.size()) {\n            return -1;\n        }\n        \n        return factors[k - 1];\n    }\n};\n"
      }
    },
    "1493": {
      "solution": {
        "sliding-window": "class Solution {\n    public int longestSubarray(int[] nums) {\n        int left = 0;\n        int zeroCount = 0;\n        int maxLength = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            if (nums[right] == 0) {\n                zeroCount++;\n            }\n\n            while (zeroCount > 1) {\n                if (nums[left] == 0) {\n                    zeroCount--;\n                }\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left);\n        }\n\n        return maxLength;\n    }\n}\n"
      }
    },
    "1494": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1495": {
      "solution": {
        "database": ""
      }
    },
    "1496": {
      "solution": {
        "hash-table": ""
      }
    },
    "1497": {
      "solution": {
        "counting": ""
      }
    },
    "1498": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1499": {
      "solution": {
        "monotonic-queue": "import java.util.Deque;\nimport java.util.LinkedList;\n\npublic class Solution {\n    public int findMaxValueOfEquation(int[][] points, int k) {\n        Deque<int[]> deque = new LinkedList<>();\n        int maxValue = Integer.MIN_VALUE;\n\n        for (int[] point : points) {\n            int xj = point[0];\n            int yj = point[1];\n\n            while (!deque.isEmpty() && xj - deque.peekFirst()[0] > k) {\n                deque.pollFirst();\n            }\n\n            if (!deque.isEmpty()) {\n                maxValue = Math.max(maxValue, yj + xj + deque.peekFirst()[1]);\n            }\n\n            while (!deque.isEmpty() && yj - xj >= deque.peekLast()[1]) {\n                deque.pollLast();\n            }\n\n            deque.offerLast(new int[]{xj, yj - xj});\n        }\n\n        return maxValue;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] points = {{1, 3}, {2, 0}, {3, 10}, {4, 10}, {5, 1}};\n        int k = 1;\n        System.out.println(solution.findMaxValueOfEquation(points, k));  // Output: 14\n    }\n}\n"
      }
    },
    "1500": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1501": {
      "solution": {
        "database": ""
      }
    },
    "1502": {
      "solution": {
        "sorting": ""
      }
    },
    "1503": {
      "solution": {
        "brainteaser": ""
      }
    },
    "1504": {
      "solution": {
        "matrix": "class Solution {\n    public int numSubmat(int[][] mat) {\n        int m = mat.length;\n        int n = mat[0].length;\n        int ans = 0;\n        int[] hist = new int[n];\n\n        for (int[] row : mat) {\n            for (int i = 0; i < row.length; ++i)\n                hist[i] = row[i] == 0 ? 0 : hist[i] + 1;\n            ans += count(hist);\n        }\n\n        return ans;\n    }\n\n    private int count(int[] nums) {\n        int[] submatrices = new int[nums.length];\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        for (int i = 0; i < nums.length; ++i) {\n            while (!stack.isEmpty() && nums[stack.peek()] >= nums[i])\n                stack.pop();\n            if (!stack.isEmpty()) {\n                int prevIndex = stack.peek();\n                submatrices[i] = submatrices[prevIndex] + nums[i] * (i - prevIndex);\n            } else {\n                submatrices[i] = nums[i] * (i + 1);\n            }\n            stack.push(i);\n        }\n\n        return Arrays.stream(submatrices).sum();\n    }\n}"
      }
    },
    "1505": {
      "solution": {
        "greedy": ""
      }
    },
    "1506": {
      "solution": {
        "tree": "*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    Node* findRoot(vector<Node*> tree) {\n        int x = 0;\n        for (Node* node : tree) {\n            x ^= node->val;\n            for (Node* child : node->children) {\n                x ^= child->val;\n            }\n        }\n        for (int i = 0;; ++i) {\n            if (tree[i]->val == x) {\n                return tree[i];\n            }\n        }\n    }\n};"
      }
    },
    "1507": {
      "solution": {
        "string": ""
      }
    },
    "1508": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1509": {
      "solution": {
        "greedy": ""
      }
    },
    "1510": {
      "solution": {
        "game-theory": "class Solution {\npublic:\n    bool winnerSquareGame(int n) {\n        vector<bool> dp(n + 1, false); // dp[i] represents if Alice can win with i stones\n        \n        for (int i = 1; i <= n; ++i) {\n            for (int k = 1; k * k <= i; ++k) {\n                if (!dp[i - k * k]) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        \n        return dp[n];\n    }\n};\n"
      }
    },
    "1511": {
      "solution": {
        "database": ""
      }
    },
    "1512": {
      "solution": {
        "counting": "class Solution {\npublic:\n    int numIdenticalPairs(vector<int>& nums) {\n        unordered_map<int, int> freq; \n        int count = 0;\n\n        for (int num : nums) {\n            count += freq[num];\n            ++freq[num];     \n        }\n\n        return count;\n    }\n};\n"
      }
    },
    "1513": {
      "solution": {
        "math": ""
      }
    },
    "1514": {
      "solution": {
        "shortest-path": "#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <utility>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start_node, int end_node) {\n        vector<vector<pair<int, double>>> graph(n);\n        for (int i = 0; i < edges.size(); ++i) {\n            int u = edges[i][0];\n            int v = edges[i][1];\n            double prob = succProb[i];\n            graph[u].emplace_back(v, prob);\n            graph[v].emplace_back(u, prob);\n        }\n\n        priority_queue<pair<double, int>> pq;\n        pq.push({1.0, start_node}); // Start with a probability of 1 at the start_node\n\n        vector<double> probabilities(n, 0.0);\n        probabilities[start_node] = 1.0;\n\n        while (!pq.empty()) {\n            auto [curr_prob, curr_node] = pq.top();\n            pq.pop();\n\n            // If we reach the end_node, return the probability\n            if (curr_node == end_node) {\n                return curr_prob;\n            }\n\n            // If the current probability is less than the recorded probability, skip processing\n            if (curr_prob < probabilities[curr_node]) {\n                continue;\n            }\n\n            // Explore neighbors\n            for (auto& [neighbor, edge_prob] : graph[curr_node]) {\n                double new_prob = curr_prob * edge_prob;\n                if (new_prob > probabilities[neighbor]) {\n                    probabilities[neighbor] = new_prob;\n                    pq.push({new_prob, neighbor});\n                }\n            }\n        }\n\n        // If the end_node is not reachable, return 0\n        return 0.0;\n    }\n};\n"
      }
    },
    "1515": {
      "solution": {
        "randomized": "class Solution {\n    public double getMinDistSum(int[][] positions) {\n        int n = positions.length;\n        double x = 0, y = 0;\n        for (int[] p : positions) {\n            x += p[0];\n            y += p[1];\n        }\n        x /= n;\n        y /= n;\n        double decay = 0.999;\n        double eps = 1e-6;\n        double alpha = 0.5;\n        while (true) {\n            double gradX = 0, gradY = 0;\n            double dist = 0;\n            for (int[] p : positions) {\n                double a = x - p[0], b = y - p[1];\n                double c = Math.sqrt(a * a + b * b);\n                gradX += a / (c + 1e-8);\n                gradY += b / (c + 1e-8);\n                dist += c;\n            }\n            double dx = gradX * alpha, dy = gradY * alpha;\n            if (Math.abs(dx) <= eps && Math.abs(dy) <= eps) {\n                return dist;\n            }\n            x -= dx;\n            y -= dy;\n            alpha *= decay;\n        }\n    }\n}"
      }
    },
    "1516": {
      "solution": {
        "tree": ""
      }
    },
    "1517": {
      "solution": {
        "database": ""
      }
    },
    "1518": {
      "solution": {
        "math": ""
      }
    },
    "1519": {
      "solution": {
        "tree": ""
      }
    },
    "1520": {
      "solution": {
        "greedy": ""
      }
    },
    "1521": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "1522": {
      "solution": {
        "tree": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    int ans;\n\n    int diameter(Node* root) {\n        ans = 0;\n        dfs(root);\n        return ans;\n    }\n\n    int dfs(Node* root) {\n        if (!root) return 0;\n        int m1 = 0, m2 = 0;\n        for (Node* child : root->children) {\n            int t = dfs(child);\n            if (t > m1) {\n                m2 = m1;\n                m1 = t;\n            } else if (t > m2)\n                m2 = t;\n        }\n        ans = max(ans, m1 + m2);\n        return 1 + m1;\n    }\n};"
      }
    },
    "1523": {
      "solution": {
        "math": ""
      }
    },
    "1524": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1525": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1526": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "1527": {
      "solution": {
        "database": ""
      }
    },
    "1528": {
      "solution": {
        "string": ""
      }
    },
    "1529": {
      "solution": {
        "greedy": ""
      }
    },
    "1530": {
      "solution": {
        "tree": ""
      }
    },
    "1531": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1532": {
      "solution": {
        "database": ""
      }
    },
    "1533": {
      "solution": {
        "interactive": "/**\n * // This is the ArrayReader's API interface.\n * // You should not implement it, or speculate about its implementation\n * class ArrayReader {\n *   public:\n *     // Compares the sum of arr[l..r] with the sum of arr[x..y]\n *     // return 1 if sum(arr[l..r]) > sum(arr[x..y])\n *     // return 0 if sum(arr[l..r]) == sum(arr[x..y])\n *     // return -1 if sum(arr[l..r]) < sum(arr[x..y])\n *     int compareSub(int l, int r, int x, int y);\n *\n *     // Returns the length of the array\n *     int length();\n * };\n */\n\nclass Solution {\npublic:\n    int getIndex(ArrayReader& reader) {\n        int left = 0, right = reader.length() - 1;\n        while (left < right) {\n            int t1 = left, t2 = left + (right - left) / 3, t3 = left + (right - left) / 3 * 2 + 1;\n            int cmp = reader.compareSub(t1, t2, t2 + 1, t3);\n            if (cmp == 0) {\n                left = t3 + 1;\n            } else if (cmp == 1) {\n                right = t2;\n            } else {\n                left = t2 + 1;\n                right = t3;\n            }\n        }\n        return left;\n    }\n};"
      }
    },
    "1534": {
      "solution": {
        "enumeration": ""
      }
    },
    "1535": {
      "solution": {
        "array": ""
      }
    },
    "1536": {
      "solution": {
        "matrix": ""
      }
    },
    "1537": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1538": {
      "solution": {
        "interactive": ""
      }
    },
    "1539": {
      "solution": {
        "array": "",
        "binary-search": "class Solution {\npublic:\n  int findKthPositive(vector<int>& nums, int k) {\n    int left = 0;\n    int right = nums.size();\n\n    while (left < right) {\n      const int mid = (left + right) / 2;\n      if (nums[mid] - mid - 1 >= k)\n        right = mid;\n      else\n        left = mid + 1;\n    }\n\n    // The k-th missing positive number\n    // = nums[left - 1] + k - nMissing(left - 1)\n    // = nums[left - 1] + k - (nums[left - 1] - (left - 1) - 1)\n    // = nums[left - 1] + k - (nums[left - 1] - left)\n    // = left + k\n    return left + k;\n  }\n};\n"
      }
    },
    "1540": {
      "solution": {
        "hash-table": ""
      }
    },
    "1541": {
      "solution": {
        "stack": ""
      }
    },
    "1542": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "1543": {
      "solution": {
        "database": ""
      }
    },
    "1544": {
      "solution": {
        "stack": ""
      }
    },
    "1545": {
      "solution": {
        "recursion": ""
      }
    },
    "1546": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1547": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1548": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1549": {
      "solution": {
        "database": ""
      }
    },
    "1550": {
      "solution": {
        "array": ""
      }
    },
    "1551": {
      "solution": {
        "math": ""
      }
    },
    "1552": {
      "solution": {
        "sorting": ""
      }
    },
    "1553": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1554": {
      "solution": {
        "rolling-hash": ""
      }
    },
    "1555": {
      "solution": {
        "database": ""
      }
    },
    "1556": {
      "solution": {
        "string": ""
      }
    },
    "1557": {
      "solution": {
        "graph": ""
      }
    },
    "1558": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "1559": {
      "solution": {
        "union-find": ""
      }
    },
    "1560": {
      "solution": {
        "array": ""
      }
    },
    "1561": {
      "solution": {
        "game-theory": ""
      }
    },
    "1562": {
      "solution": {
        "array": ""
      }
    },
    "1563": {
      "solution": {
        "game-theory": ""
      }
    },
    "1564": {
      "solution": {
        "greedy": ""
      }
    },
    "1565": {
      "solution": {
        "database": ""
      }
    },
    "1566": {
      "solution": {
        "enumeration": ""
      }
    },
    "1567": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1568": {
      "solution": {
        "strongly-connected-component": "class Solution {\n\n    private final int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\n\n    public int minDays(int[][] grid) {\n        if (disconnected(grid))\n            return 0;\n\n        // Try to remove 1 land.\n        for (int i = 0; i < grid.length; ++i)\n            for (int j = 0; j < grid[0].length; ++j)\n                if (grid[i][j] == 1) {\n                    grid[i][j] = 0;\n                    if (disconnected(grid))\n                        return 1;\n                    grid[i][j] = 1;\n                }\n\n        // Remove 2 lands.\n        return 2;\n    }\n\n    private boolean disconnected(int[][] grid) {\n        int islandsCount = 0;\n        boolean[][] seen = new boolean[grid.length][grid[0].length];\n        for (int i = 0; i < grid.length; ++i)\n            for (int j = 0; j < grid[0].length; ++j) {\n                if (grid[i][j] == 0 || seen[i][j])\n                    continue;\n                if (++islandsCount > 1)\n                    return true;\n                dfs(grid, i, j, seen);\n            }\n\n        return islandsCount != 1;\n    }\n\n    private void dfs(int[][] grid, int i, int j, boolean[][] seen) {\n        seen[i][j] = true;\n        for (int[] dir : dirs) {\n            int x = i + dir[0];\n            int y = j + dir[1];\n            if (x < 0 || x == grid.length || y < 0 || y == grid[0].length)\n                continue;\n            if (grid[x][y] == 0 || seen[x][y])\n                continue;\n            dfs(grid, x, y, seen);\n        }\n    }\n}\n"
      }
    },
    "1569": {
      "solution": {
        "combinatorics": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    static constexpr int MOD = 1e9 + 7;\n\n    int numOfWays(vector<int>& nums) {\n        int n = nums.size();\n        comb.resize(n + 1, vector<int>(n + 1, 0));\n        precomputeCombinations(n);\n        return (dfs(nums) - 1 + MOD) %\n               MOD; // Subtract 1 because the original order is not counted\n    }\n\nprivate:\n    vector<vector<int>> comb;\n\n    // Precompute binomial coefficients (Pascal's Triangle)\n    void precomputeCombinations(int n) {\n        for (int i = 0; i <= n; ++i) {\n            comb[i][0] = comb[i][i] = 1;\n            for (int j = 1; j < i; ++j) {\n                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;\n            }\n        }\n    }\n\n    int dfs(const vector<int>& nums) {\n        if (nums.size() <= 2)\n            return 1; // Base case: only 0 or 1 reorderings possible\n\n        vector<int> left, right;\n        for (int i = 1; i < nums.size(); ++i) {\n            if (nums[i] < nums[0])\n                left.push_back(nums[i]);\n            else\n                right.push_back(nums[i]);\n        }\n\n        long long leftWays = dfs(left);\n        long long rightWays = dfs(right);\n        long long mergeWays = comb[nums.size() - 1][left.size()];\n        return leftWays * rightWays % MOD * mergeWays % MOD;\n    }\n};\n"
      }
    },
    "1570": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1571": {
      "solution": {
        "database": ""
      }
    },
    "1572": {
      "solution": {
        "matrix": ""
      }
    },
    "1573": {
      "solution": {
        "math": ""
      }
    },
    "1574": {
      "solution": {
        "two-pointers": "class Solution {\n    public int findLengthOfShortestSubarray(int[] arr) {\n        int n = arr.length;\n        int left = 0, right = n - 1;\n        \n        while (left < n - 1 && arr[left] <= arr[left + 1]) {\n            left++;\n        }\n        \n        if (left == n - 1) {\n            return 0;\n        }\n        \n        while (right > 0 && arr[right - 1] <= arr[right]) {\n            right--;\n        }\n        \n        int minRemove = Math.min(n - left - 1, right);        \n        int i = 0, j = right;\n        while (i <= left && j < n) {\n            if (arr[i] <= arr[j]) {\n                minRemove = Math.min(minRemove, j - i - 1);\n                i++;\n            } else {\n                j++;\n            }\n        }\n        \n        return minRemove;\n    }\n}\n"
      }
    },
    "1575": {
      "solution": {
        "memoization": "class Solution {\npublic:\n    int countRoutes(vector<int>& locations, int start, int finish, int fuel) {\n        int n = locations.size();\n        vector<vector<int>> dp(n,\n                               vector<int>(fuel + 1, -1)); // Memoization table\n        return helper(locations, start, finish, fuel, dp);\n    }\n\nprivate:\n    const int MOD = 1e9 + 7;\n\n    int helper(vector<int>& locations, int current, int finish, int fuel,\n               vector<vector<int>>& dp) {\n        if (fuel < 0)\n            return 0; // If fuel is exhausted, no routes possible\n\n        if (dp[current][fuel] != -1)\n            return dp[current][fuel]; // Return cached result\n\n        int routes =\n            (current == finish)\n                ? 1\n                : 0; // Include current as a valid route if it's the finish\n\n        for (int next = 0; next < locations.size(); ++next) {\n            if (next != current) {\n                int cost = abs(locations[current] -\n                               locations[next]); // Fuel cost to travel\n                if (fuel >= cost) {              // Travel if enough fuel\n                    routes = (routes + helper(locations, next, finish,\n                                              fuel - cost, dp)) %\n                             MOD;\n                }\n            }\n        }\n\n        return dp[current][fuel] = routes; // Cache and return the result\n    }\n};\n"
      }
    },
    "1576": {
      "solution": {
        "string": ""
      }
    },
    "1577": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1578": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1579": {
      "solution": {
        "union-find": ""
      }
    },
    "1580": {
      "solution": {
        "greedy": ""
      }
    },
    "1581": {
      "solution": {
        "database": ""
      }
    },
    "1582": {
      "solution": {
        "matrix": ""
      }
    },
    "1583": {
      "solution": {
        "array": ""
      }
    },
    "1584": {
      "solution": {
        "minimum-spanning-tree": "import java.util.*;\n\nclass Solution {\n    class Edge {\n        int u, v, cost;\n        Edge(int u, int v, int cost) {\n            this.u = u;\n            this.v = v;\n            this.cost = cost;\n        }\n    }\n\n    class UnionFind {\n        int[] parent, rank;\n\n        UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n\n        boolean union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            if (rootX != rootY) {\n                if (rank[rootX] > rank[rootY]) {\n                    parent[rootY] = rootX;\n                } else if (rank[rootX] < rank[rootY]) {\n                    parent[rootX] = rootY;\n                } else {\n                    parent[rootY] = rootX;\n                    rank[rootX]++;\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n\n    public int minCostConnectPoints(int[][] points) {\n        int n = points.length;\n        List<Edge> edges = new ArrayList<>();\n\n        // Create all possible edges with their costs\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int cost = Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]);\n                edges.add(new Edge(i, j, cost));\n            }\n        }\n\n        // Sort edges by cost\n        edges.sort(Comparator.comparingInt(e -> e.cost));\n\n        // Kruskal's algorithm to find the MST\n        UnionFind uf = new UnionFind(n);\n        int minCost = 0, edgesUsed = 0;\n\n        for (Edge edge : edges) {\n            if (uf.union(edge.u, edge.v)) {\n                minCost += edge.cost;\n                edgesUsed++;\n                if (edgesUsed == n - 1) {\n                    break;\n                }\n            }\n        }\n\n        return minCost;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] points = { {0, 0}, {2, 2}, {3, 10}, {5, 2}, {7, 0} };\n        System.out.println(\"Minimum cost to connect all points: \" + solution.minCostConnectPoints(points));\n    }\n}\n"
      }
    },
    "1585": {
      "solution": {
        "greedy": ""
      }
    },
    "1586": {
      "solution": {
        "iterator": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n    private List<Integer> nums = new ArrayList<>();\n    private int i = -1;\n\n    public BSTIterator(TreeNode root) {\n        dfs(root);\n    }\n\n    public boolean hasNext() {\n        return i < nums.size() - 1;\n    }\n\n    public int next() {\n        return nums.get(++i);\n    }\n\n    public boolean hasPrev() {\n        return i > 0;\n    }\n\n    public int prev() {\n        return nums.get(--i);\n    }\n\n    private void dfs(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        dfs(root.left);\n        nums.add(root.val);\n        dfs(root.right);\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * boolean param_1 = obj.hasNext();\n * int param_2 = obj.next();\n * boolean param_3 = obj.hasPrev();\n * int param_4 = obj.prev();\n */"
      }
    },
    "1587": {
      "solution": {
        "database": ""
      }
    },
    "1588": {
      "solution": {
        "prefix-sum": "class Solution {\n    public int sumOddLengthSubarrays(int[] arr) {\n        int n = arr.length;\n        int[] prefixSum = new int[n + 1];\n        int totalSum = 0;\n        \n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + arr[i];\n        }\n        \n        for (int start = 0; start < n; start++) {\n            for (int end = start; end < n; end++) {\n                int length = end - start + 1;\n                if (length % 2 == 1) {\n                    totalSum += prefixSum[end + 1] - prefixSum[start];\n                }\n            }\n        }\n        \n        return totalSum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sumOddLengthSubarrays(new int[]{1, 4, 2, 5, 3})); // Output: 58\n        System.out.println(solution.sumOddLengthSubarrays(new int[]{1, 2}));          // Output: 3\n        System.out.println(solution.sumOddLengthSubarrays(new int[]{10, 11, 12}));    // Output: 66\n    }\n}\n"
      }
    },
    "1589": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1590": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1591": {
      "solution": {
        "matrix": ""
      }
    },
    "1592": {
      "solution": {
        "string": ""
      }
    },
    "1593": {
      "solution": {
        "backtracking": ""
      }
    },
    "1594": {
      "solution": {
        "matrix": ""
      }
    },
    "1595": {
      "solution": {
        "matrix": ""
      }
    },
    "1596": {
      "solution": {
        "database": ""
      }
    },
    "1597": {
      "solution": {
        "stack": ""
      }
    },
    "1598": {
      "solution": {
        "stack": ""
      }
    },
    "1599": {
      "solution": {
        "array": ""
      }
    },
    "1600": {
      "solution": {
        "tree": ""
      }
    },
    "1601": {
      "solution": {
        "backtracking": ""
      }
    },
    "1602": {
      "solution": {
        "tree": ""
      }
    },
    "1603": {
      "solution": {
        "counting": ""
      }
    },
    "1604": {
      "solution": {
        "sorting": ""
      }
    },
    "1605": {
      "solution": {
        "matrix": "import java.util.Arrays;\n\npublic class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    public int[][] restoreMatrix(int[] rowSum, int[] colSum) {\n        int rows = rowSum.length;\n        int cols = colSum.length;\n        int[][] matrix = new int[rows][cols];\n        boolean[][] visited = new boolean[rows][cols];\n        \n        dfs(matrix, rowSum, colSum, visited, 0, 0, rows, cols);\n        return matrix;\n    }\n\n    private boolean dfs(int[][] matrix, int[] rowSum, int[] colSum, boolean[][] visited, int i, int j, int rows, int cols) {\n        if (i >= rows || j >= cols || visited[i][j]) return true;\n\n        visited[i][j] = true;\n\n        int fillValue = Math.min(rowSum[i], colSum[j]);\n        matrix[i][j] = fillValue;\n        rowSum[i] -= fillValue;\n        colSum[j] -= fillValue;\n\n        for (int[] direction : DIRECTIONS) {\n            int ni = i + direction[0];\n            int nj = j + direction[1];\n\n            if (ni >= 0 && nj >= 0 && ni < rows && nj < cols && !visited[ni][nj]) {\n                if (!dfs(matrix, rowSum, colSum, visited, ni, nj, rows, cols)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solver = new Solution();\n        int[] rowSum = {3, 8};\n        int[] colSum = {4, 7};\n        \n        int[][] result = solver.restoreMatrix(rowSum, colSum);\n        for (int[] row : result) {\n            System.out.println(Arrays.toString(row));\n        }\n    }\n}\n"
      }
    },
    "1606": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1607": {
      "solution": {
        "database": ""
      }
    },
    "1608": {
      "solution": {
        "sorting": ""
      }
    },
    "1609": {
      "solution": {
        "breadth-first-search": "class Solution {\npublic:\n    bool isEvenOddTree(TreeNode* root) {\n        if (!root) return true;\n        \n        queue<TreeNode*> q;\n        q.push(root);\n        int level = 0; \n        \n        while (!q.empty()) {\n            int size = q.size();\n            int prevVal = (level % 2 == 0) ? INT_MIN : INT_MAX; // Initial value based on level\n            \n            for (int i = 0; i < size; ++i) {\n                TreeNode* node = q.front();\n                q.pop();\n                \n                int val = node->val;\n                \n                if (level % 2 == 0) {\n                    if (val % 2 == 0 || val <= prevVal) return false; // Odd values, strictly increasing\n                } \n                else {\n                    if (val % 2 != 0 || val >= prevVal) return false; // Even values, strictly decreasing\n                }\n                \n                prevVal = val; \n\n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n            }\n            \n            level++;\n        }\n        \n        return true;\n    }\n};\n"
      }
    },
    "1610": {
      "solution": {
        "sliding-window": "import java.util.*;\n\nclass Solution {\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\n        int sameLocationCount = 0;\n        List<Double> angles = new ArrayList<>();\n\n        int x0 = location.get(0);\n        int y0 = location.get(1);\n\n        for (List<Integer> point : points) {\n            int x = point.get(0);\n            int y = point.get(1);\n\n            if (x == x0 && y == y0) {\n                sameLocationCount++;\n            } else {\n                double theta = Math.atan2(y - y0, x - x0) * (180 / Math.PI);\n                angles.add(theta);\n            }\n        }\n\n        Collections.sort(angles);\n\n        int m = angles.size();\n        for (int i = 0; i < m; i++) {\n            angles.add(angles.get(i) + 360);\n        }\n\n        int maxVisible = 0;\n        int left = 0;\n\n        for (int right = 0; right < angles.size(); right++) {\n            while (angles.get(right) - angles.get(left) > angle) {\n                left++;\n            }\n            maxVisible = Math.max(maxVisible, right - left + 1);\n        }\n\n        return maxVisible + sameLocationCount;\n    }\n}\n"
      }
    },
    "1611": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1612": {
      "solution": {
        "tree": ""
      }
    },
    "1613": {
      "solution": {
        "database": ""
      }
    },
    "1614": {
      "solution": {
        "stack": ""
      }
    },
    "1615": {
      "solution": {
        "graph": ""
      }
    },
    "1616": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1617": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1618": {
      "solution": {
        "interactive": ""
      }
    },
    "1619": {
      "solution": {
        "sorting": ""
      }
    },
    "1620": {
      "solution": {
        "enumeration": ""
      }
    },
    "1621": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1622": {
      "solution": {
        "design": ""
      }
    },
    "1623": {
      "solution": {
        "database": ""
      }
    },
    "1624": {
      "solution": {
        "hash-table": ""
      }
    },
    "1625": {
      "solution": {
        "enumeration": ""
      }
    },
    "1626": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1627": {
      "solution": {
        "union-find": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\nprivate:\n    vector<int> parent;\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unionSets(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            parent[rootY] = rootX;\n        }\n    }\n\npublic:\n    vector<bool> areConnected(int n, int threshold,\n                              vector<vector<int>>& queries) {\n        parent.resize(n + 1);\n        for (int i = 1; i <= n; ++i) {\n            parent[i] = i;\n        }\n\n        for (int i = threshold + 1; i <= n; ++i) {\n            for (int j = 2 * i; j <= n; j += i) {\n                unionSets(i, j);\n            }\n        }\n\n        vector<bool> result;\n        for (const auto& query : queries) {\n            int u = query[0];\n            int v = query[1];\n            result.push_back(find(u) == find(v));\n        }\n\n        return result;\n    }\n};\n"
      }
    },
    "1628": {
      "solution": {
        "stack": ""
      }
    },
    "1629": {
      "solution": {
        "string": ""
      }
    },
    "1630": {
      "solution": {
        "sorting": ""
      }
    },
    "1631": {
      "solution": {
        "breadth-first-search": "class Solution {\npublic:\n    bool bfs(vector<vector<int>>& heights, int maxEffort) {\n        int m = heights.size(), n = heights[0].size();\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        queue<pair<int, int>> q;\n        q.push({0, 0});\n        visited[0][0] = true;\n        \n        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        \n        while (!q.empty()) {\n            auto [x, y] = q.front();\n            q.pop();\n            \n            if (x == m - 1 && y == n - 1) return true;\n            \n            for (auto [dx, dy] : directions) {\n                int nx = x + dx, ny = y + dy;\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny]) {\n                    if (abs(heights[x][y] - heights[nx][ny]) <= maxEffort) {\n                        visited[nx][ny] = true;\n                        q.push({nx, ny});\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    int minimumEffortPath(vector<vector<int>>& heights) {\n        int left = 0, right = INT_MAX;\n        int m = heights.size(), n = heights[0].size();\n        \n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (bfs(heights, mid)) {\n                right = mid; \n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        return left;\n    }\n};\n"
      }
    },
    "1632": {
      "solution": {
        "matrix": "class Solution {\n    class Node {\n        int id, val, rank;\n        List<Integer> neighbors;\n        public Node(int id, int val) {\n            this.id = id;\n            this.val = val;\n            this.neighbors = new ArrayList<>();\n        }\n    }\n    \n    class DSU {\n        int[] parent, rank;\n        int size;\n        public DSU(int n) {\n            this.parent = new int[n];\n            for (int i = 0; i < n; i++) parent[i] = i;\n            this.rank = new int[n];\n            this.size = n;\n        }\n\n        public boolean union(int[] a, int[] b) {\n            return union(encode(a[0], a[1]), encode(b[0], b[1]));\n        }\n\n        public boolean union(int a, int b) {\n            int p = find(a), q = find(b);\n            if (p == q) return false;\n            if (rank[p] > rank[q]) {\n                parent[q] = p;\n            } else if (rank[p] < rank[q]) {\n                parent[p] = q;\n            } else {\n                parent[p] = q;\n                rank[q]++;\n            }\n            size--;\n            return true;\n        }\n\n        public int find(int r, int c) {\n            return find(encode(r, c));\n        }\n\n        public int find(int a) {\n            int root = a;\n            while (root != parent[root]) {\n                root = parent[root];\n            }\n            while (root != a) {\n                int p = parent[a];\n                parent[a] = root;\n                a = p;\n            }\n            return root;\n        }\n\n        private int encode(int r, int c) {\n            return r * cols + c;\n        }\n    }\n\n    private int rows, cols;\n    public int[][] matrixRankTransform(int[][] matrix) {\n        this.rows = matrix.length;\n        this.cols = matrix[0].length;\n        DSU dsu = new DSU(rows * cols);\n        \n        connectCellWithEqualRank(dsu, matrix);\n        \n        Map<Integer, Node> graph = new HashMap<>();\n        Node[] nodes = new Node[dsu.size];\n        int[] in = new int[nodes.length];\n        \n        buildGraph(dsu, matrix, graph, nodes, in);\n\n        assignRankThroughTopologicalSort(nodes, in);\n        \n        int[][] ranks = new int[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                ranks[i][j] = graph.get(dsu.find(i, j)).rank;\n            }\n        }\n        return ranks;\n    }\n\n    private void assignRankThroughTopologicalSort(Node[] nodes, int[] in) {\n        Queue<Integer> queue = new LinkedList<>();\n        int rank = 1;\n        for (int i = 0; i < in.length; i++) {\n            if (in[i] == 0) queue.offer(i);\n        }\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            while (size-- > 0) {\n                int cur = queue.poll();\n                nodes[cur].rank = rank;\n                for (int neighbor: nodes[cur].neighbors) {\n                    if (--in[neighbor] != 0) continue;\n                    queue.offer(neighbor);\n                }\n            }\n            rank++;\n        }\n    }\n\n    private void buildGraph(DSU dsu, int[][] matrix, Map<Integer, Node> graph, Node[] nodes, int[] in) {\n        int id = 0;\n        // add nodes\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                int parent = dsu.find(i, j);\n                if (graph.containsKey(parent)) continue;\n                nodes[id] = new Node(id, matrix[i][j]);\n                graph.put(parent, nodes[id]);\n                id++;\n            }\n        }\n        // add edges\n        // 1. row by row\n        for (int i = 0; i < rows; i++) {\n            List<Node> curRow = new ArrayList<>();\n            Set<Integer> seen = new HashSet<>();\n            for (int j = 0; j < cols; j++) {\n                int parent = dsu.find(i, j);\n                if (seen.add(parent)) curRow.add(graph.get(parent));\n            }\n            curRow.sort(Comparator.comparingInt(a -> a.val));\n            for (int m = 0; m < curRow.size() - 1; m++) {\n                int neighborId = curRow.get(m + 1).id;\n                curRow.get(m).neighbors.add(neighborId);\n                in[neighborId]++;\n            }\n        }\n        // 2. col by col\n        for (int j = 0; j < cols; j++) {\n            List<Node> curCol = new ArrayList<>();\n            Set<Integer> seen = new HashSet<>();\n            for (int i = 0; i < rows; i++) {\n                int parent = dsu.find(i, j);\n                if (seen.add(parent)) curCol.add(graph.get(parent));\n            }\n            curCol.sort(Comparator.comparingInt(a -> a.val));\n            for (int m = 0; m < curCol.size() - 1; m++) {\n                int neighborId = curCol.get(m + 1).id;\n                curCol.get(m).neighbors.add(curCol.get(m + 1).id);\n                in[neighborId]++;\n            }\n        }\n    }\n\n    private void connectCellWithEqualRank(DSU dsu, int[][] matrix) {\n        Map<Integer, Map<Integer, List<int[]>>> map = new HashMap<>();\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                map.putIfAbsent(matrix[i][j], new HashMap<>());\n                map.get(matrix[i][j]).computeIfAbsent(i + 1, a -> new ArrayList<>()).add(new int[]{i, j});\n                map.get(matrix[i][j]).computeIfAbsent(-j - 1, a -> new ArrayList<>()).add(new int[]{i, j});\n            }\n        }\n        for (Map<Integer, List<int[]>> nodesMap: map.values()) {\n            for (List<int[]> nodes : nodesMap.values()) {\n                for (int i = 0; i < nodes.size() - 1; i++) {\n                    dsu.union(nodes.get(i), nodes.get(i + 1));\n                }\n            }\n        }\n    }\n}"
      }
    },
    "1633": {
      "solution": {
        "database": ""
      }
    },
    "1634": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1635": {
      "solution": {
        "database": ""
      }
    },
    "1636": {
      "solution": {
        "sorting": ""
      }
    },
    "1637": {
      "solution": {
        "sorting": ""
      }
    },
    "1638": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1639": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1640": {
      "solution": {
        "hash-table": ""
      }
    },
    "1641": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1642": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1643": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1644": {
      "solution": {
        "tree": ""
      }
    },
    "1645": {
      "solution": {
        "database": ""
      }
    },
    "1646": {
      "solution": {
        "array": ""
      }
    },
    "1647": {
      "solution": {
        "greedy": ""
      }
    },
    "1648": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1649": {
      "solution": {
        "merge-sort": "class Solution {\n    private static final int MOD = 1000000007;\n\n    public int createSortedArray(int[] instructions) {\n        FenwickTree tree = new FenwickTree(100001);\n        long cost = 0;\n\n        for (int i = 0; i < instructions.length; i++) {\n            int num = instructions[i];\n            int countSmaller = tree.query(num - 1); // Number of elements less than num\n            int countGreater = i - tree.query(num); // Number of elements greater than num\n            cost = (cost + Math.min(countSmaller, countGreater)) % MOD;\n            tree.update(num, 1);\n        }\n\n        return (int) cost;\n    }\n}\n\nclass FenwickTree {\n    private int[] tree;\n\n    public FenwickTree(int size) {\n        this.tree = new int[size + 1];\n    }\n\n    public void update(int index, int delta) {\n        while (index < tree.length) {\n            tree[index] += delta;\n            index += index & -index;\n        }\n    }\n\n    public int query(int index) {\n        int sum = 0;\n        while (index > 0) {\n            sum += tree[index];\n            index -= index & -index;\n        }\n        return sum;\n    }\n}\n"
      }
    },
    "1650": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1651": {
      "solution": {
        "database": ""
      }
    },
    "1652": {
      "solution": {
        "sliding-window": "class Solution {\n    public int[] decrypt(int[] code, int k) {\n        int n = code.length;\n        int[] result = new int[n];\n        \n        if (k == 0) {\n            return result;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (k > 0) {\n                for (int j = 1; j <= k; j++) {\n                    result[i] += code[(i + j) % n];\n                }\n            } else {\n                for (int j = -1; j >= k; j--) {\n                    result[i] += code[(i + j + n) % n];\n                }\n            }\n        }\n        \n        return result;\n    }\n}\n"
      }
    },
    "1653": {
      "solution": {
        "stack": ""
      }
    },
    "1654": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1655": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1656": {
      "solution": {
        "data-stream": ""
      }
    },
    "1657": {
      "solution": {
        "counting": ""
      }
    },
    "1658": {
      "solution": {
        "sliding-window": "class Solution {\n    public int minOperations(int[] nums, int x) {\n        x = -x;\n        for (int v : nums) {\n            x += v;\n        }\n        Map<Integer, Integer> vis = new HashMap<>();\n        vis.put(0, -1);\n        int n = nums.length;\n        int ans = 1 << 30;\n        for (int i = 0, s = 0; i < n; ++i) {\n            s += nums[i];\n            vis.putIfAbsent(s, i);\n            if (vis.containsKey(s - x)) {\n                int j = vis.get(s - x);\n                ans = Math.min(ans, n - (i - j));\n            }\n        }\n        return ans == 1 << 30 ? -1 : ans;\n    }\n}"
      }
    },
    "1659": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1660": {
      "solution": {
        "tree": ""
      }
    },
    "1661": {
      "solution": {
        "database": ""
      }
    },
    "1662": {
      "solution": {
        "string": ""
      }
    },
    "1663": {
      "solution": {
        "greedy": ""
      }
    },
    "1664": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1665": {
      "solution": {
        "greedy": ""
      }
    },
    "1666": {
      "solution": {
        "tree": ""
      }
    },
    "1667": {
      "solution": {
        "database": ""
      }
    },
    "1668": {
      "solution": {
        "string-matching": "class Solution {\n public:\n  int maxRepeating(string sequence, string word) {\n    int ans = 1;\n    string repeating = word;\n    while (sequence.find(repeating) != string::npos) {\n      ++ans;\n      repeating += word;\n    }\n    return ans - 1;\n  }\n};"
      }
    },
    "1669": {
      "solution": {
        "linked-list": ""
      }
    },
    "1670": {
      "solution": {
        "queue": ""
      }
    },
    "1671": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1672": {
      "solution": {
        "matrix": ""
      }
    },
    "1673": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "1674": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1675": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1676": {
      "solution": {
        "tree": ""
      }
    },
    "1677": {
      "solution": {
        "database": ""
      }
    },
    "1678": {
      "solution": {
        "string": ""
      }
    },
    "1679": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1680": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "1681": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1682": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1683": {
      "solution": {
        "database": ""
      }
    },
    "1684": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "1685": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1686": {
      "solution": {
        "breadth-first-search": "class Solution {\npublic:\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\n        int n = aliceValues.size();\n        vector<tuple<int, int, int>> stones;\n\n        // Create a combined array of (a[i] + b[i], a[i], b[i])\n        for (int i = 0; i < n; ++i) {\n            stones.emplace_back(aliceValues[i] + bobValues[i], aliceValues[i],\n                                bobValues[i]);\n        }\n\n        // Sort stones by combined value in descending order\n        sort(stones.rbegin(), stones.rend());\n\n        int aliceScore = 0, bobScore = 0;\n\n        // Alternate picking stones\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) { // Alice's turn\n                aliceScore += get<1>(stones[i]);\n            } else { // Bob's turn\n                bobScore += get<2>(stones[i]);\n            }\n        }\n\n        // Compare scores to determine the result\n        if (aliceScore > bobScore) {\n            return 1; // Alice wins\n        } else if (bobScore > aliceScore) {\n            return -1; // Bob wins\n        } else {\n            return 0; // Tie\n        }\n    }\n};\n"
      }
    },
    "1687": {
      "solution": {
        "monotonic-queue": "class Solution {\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\n        int length = boxes.length;\n        int[] ports = new int[length + 1];\n        int[] weights = new int[length + 1];\n        int[] differences = new int[length + 1];\n        long[] prefixWeights = new long[length + 1];\n        for (int i = 1; i <= length; i++) {\n            ports[i] = boxes[i - 1][0];\n            weights[i] = boxes[i - 1][1];\n            if (i > 1)\n                differences[i] = differences[i - 1] + (ports[i - 1] != ports[i] ? 1 : 0);\n            prefixWeights[i] = prefixWeights[i - 1] + weights[i];\n        }\n        Deque<Integer> deque = new LinkedList<Integer>();\n        deque.offerLast(0);\n        int[] dp = new int[length + 1];\n        int[] remain = new int[length + 1];\n        for (int i = 1; i <= length; i++) {\n            while (!deque.isEmpty() && (i - deque.peekFirst() > maxBoxes || prefixWeights[i] - prefixWeights[deque.peekFirst()] > maxWeight))\n                deque.pollFirst();\n            dp[i] = remain[deque.peekFirst()] + differences[i] + 2;\n            if (i != length) {\n                remain[i] = dp[i] - differences[i + 1];\n                while (!deque.isEmpty() && remain[i] <= remain[deque.peekLast()])\n                    deque.pollLast();\n                deque.offerLast(i);\n            }\n        }\n        return dp[length];\n    }\n}"
      }
    },
    "1688": {
      "solution": {
        "math": ""
      }
    },
    "1689": {
      "solution": {
        "greedy": ""
      }
    },
    "1690": {
      "solution": {
        "game-theory": "class Solution {\npublic:\n    int stoneGameVII(vector<int>& stones) {\n        int n = stones.size();\n        vector<vector<int>> dp(n, vector<int>(n, 0));\n        vector<int> prefixSum(n + 1, 0);\n        \n        // Compute prefix sums\n        for (int i = 0; i < n; ++i) {\n            prefixSum[i + 1] = prefixSum[i] + stones[i];\n        }\n        \n        // Fill DP table\n        for (int len = 2; len <= n; ++len) { // Length of the subarray\n            for (int i = 0; i <= n - len; ++i) {\n                int j = i + len - 1;\n                int sum = prefixSum[j + 1] - prefixSum[i];\n                dp[i][j] = max(sum - stones[i] - dp[i + 1][j], sum - stones[j] - dp[i][j - 1]);\n            }\n        }\n        \n        return dp[0][n - 1];\n    }\n};\n"
      }
    },
    "1691": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1692": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1693": {
      "solution": {
        "database": ""
      }
    },
    "1694": {
      "solution": {
        "string": ""
      }
    },
    "1695": {
      "solution": {
        "sliding-window": "import java.util.*;\n\nclass Solution {\n    public int maximumUniqueSubarray(int[] nums) {\n        int n = nums.length;\n        Set<Integer> set = new HashSet<>();\n        int left = 0, right = 0;\n        int maxSum = 0, currentSum = 0;\n        \n        while (right < n) {\n            if (!set.contains(nums[right])) {\n                set.add(nums[right]);\n                currentSum += nums[right];\n                maxSum = Math.max(maxSum, currentSum);\n                right++;\n            } else {\n                set.remove(nums[left]);\n                currentSum -= nums[left];\n                left++;\n            }\n        }\n        \n        return maxSum;\n    }\n}\n"
      }
    },
    "1696": {
      "solution": {
        "monotonic-queue": "import java.util.Deque;\nimport java.util.LinkedList;\n\npublic class Solution {\n    public int maxResult(int[] nums, int k) {\n        int n = nums.length;\n        Deque<Integer> deque = new LinkedList<>();\n        int[] dp = new int[n];\n        dp[0] = nums[0];\n        deque.offerLast(0);\n\n        for (int i = 1; i < n; i++) {\n            while (!deque.isEmpty() && deque.peekFirst() < i - k) {\n                deque.pollFirst();\n            }\n            \n            dp[i] = nums[i] + dp[deque.peekFirst()];\n\n            while (!deque.isEmpty() && dp[i] >= dp[deque.peekLast()]) {\n                deque.pollLast();\n            }\n            \n            deque.offerLast(i);\n        }\n        \n        return dp[n - 1];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, -1, -2, 4, -7, 3};\n        int k = 2;\n        System.out.println(solution.maxResult(nums, k));  // Output: 7\n    }\n}\n"
      }
    },
    "1697": {
      "solution": {
        "union-find": ""
      }
    },
    "1698": {
      "solution": {
        "suffix-array": "import java.util.Arrays;\n\npublic class Solution {\n\n    public int countDistinct(String s) {\n        int n = s.length();\n        int[] suffixArray = buildSuffixArray(s);\n        int[] lcpArray = buildLCPArray(s, suffixArray);\n\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            int suffixLength = n - suffixArray[i];\n            count += suffixLength - (i > 0 ? lcpArray[i] : 0);\n        }\n\n        return count;\n    }\n\n    private int[] buildSuffixArray(String s) {\n        int n = s.length();\n        Suffix[] suffixes = new Suffix[n];\n\n        for (int i = 0; i < n; i++) {\n            suffixes[i] = new Suffix(i, s.substring(i));\n        }\n\n        Arrays.sort(suffixes);\n\n        int[] suffixArray = new int[n];\n        for (int i = 0; i < n; i++) {\n            suffixArray[i] = suffixes[i].index;\n        }\n\n        return suffixArray;\n    }\n\n    private int[] buildLCPArray(String s, int[] suffixArray) {\n        int n = s.length();\n        int[] rank = new int[n];\n        int[] lcpArray = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            rank[suffixArray[i]] = i;\n        }\n\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (rank[i] > 0) {\n                int j = suffixArray[rank[i] - 1];\n                while (i + h < n && j + h < n && s.charAt(i + h) == s.charAt(j + h)) {\n                    h++;\n                }\n                lcpArray[rank[i]] = h;\n                if (h > 0) {\n                    h--;\n                }\n            }\n        }\n\n        return lcpArray;\n    }\n\n    class Suffix implements Comparable<Suffix> {\n        int index;\n        String suffix;\n\n        Suffix(int index, String suffix) {\n            this.index = index;\n            this.suffix = suffix;\n        }\n\n        @Override\n        public int compareTo(Suffix other) {\n            return this.suffix.compareTo(other.suffix);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s = \"aabbaba\";\n        int distinctSubstrings = solution.countDistinct(s);\n        System.out.println(\"Number of distinct substrings: \" + distinctSubstrings); // Output: 21\n    }\n}\n"
      }
    },
    "1699": {
      "solution": {
        "database": ""
      }
    },
    "1700": {
      "solution": {
        "queue": ""
      }
    },
    "1701": {
      "solution": {
        "array": ""
      }
    },
    "1702": {
      "solution": {
        "greedy": ""
      }
    },
    "1703": {
      "solution": {
        "sliding-window": "class Solution {\n    public int minMoves(int[] nums, int k) {\n        List<Integer> ones = new ArrayList<>();\n\n        for (int i = 0; i < nums.length; ++i)\n            if (nums[i] == 1)\n                ones.add(i);\n\n      int median = ones.get(getMedIndex(0, k));\n        int moves = 0;\n        for (int i = 0; i < k; ++i)\n            moves += Math.abs(ones.get(i) - median);\n\n        int ans = moves;\n\n        for (int i = 1; i <= ones.size() - k; ++i) {\n          int oldMedianIndex = ones.get(getMedIndex(i - 1, k));\n          int newMedianIndex = ones.get(getMedIndex(i, k));\n            if (k % 2 == 1)\n                moves += newMedianIndex - oldMedianIndex;\n            moves -= newMedianIndex - ones.get(i - 1);\n            moves += ones.get(i + k - 1) - newMedianIndex;\n            ans = Math.min(ans, moves);\n        }\n\n        return ans - nThSum((k - 1) / 2) - nThSum(k / 2);\n    }\n\n    private int getMedIndex(int i, int k) {\n        return (i + (i + k - 1)) / 2;\n    }\n\n    private int nThSum(int n) {\n        return n * (n + 1) / 2;\n    }\n}"
      }
    },
    "1704": {
      "solution": {
        "counting": ""
      }
    },
    "1705": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1706": {
      "solution": {
        "matrix": ""
      }
    },
    "1707": {
      "solution": {
        "trie": ""
      }
    },
    "1708": {
      "solution": {
        "greedy": ""
      }
    },
    "1709": {
      "solution": {
        "database": ""
      }
    },
    "1710": {
      "solution": {
        "greedy": ""
      }
    },
    "1711": {
      "solution": {
        "hash-table": ""
      }
    },
    "1712": {
      "solution": {
        "two-pointers": "class Solution {\n    public int waysToSplit(int[] nums) {\n        int kMod = 1_000_000_007;\n        int n = nums.length;\n        int ans = 0;\n        int[] prefix = nums.clone();\n\n        for (int i = 1; i < n; ++i)\n            prefix[i] += prefix[i - 1];\n\n        for (int i = 0; i < n - 2; ++i) {\n            int j = firstGreaterEqual(prefix, i);\n            if (j == n - 1)\n                break;\n            int mid = prefix[j] - prefix[i];\n            int right = prefix[prefix.length - 1] - prefix[j];\n            if (mid > right)\n                continue;\n            int k = firstGreater(prefix, i);\n            ans = (ans + k - j) % kMod;\n        }\n\n        return ans;\n    }\n\n    private int firstGreaterEqual(int[] prefix, int i) {\n        int left = i + 1;\n        int right = prefix.length - 1;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (prefix[mid] - prefix[i] >= prefix[i])\n                right = mid;\n            else\n                left = mid + 1;\n        }\n        return left;\n    };\n\n    private int firstGreater(int[] prefix, int i) {\n        int left = i + 1;\n        int right = prefix.length - 1;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (prefix[mid] - prefix[i] > prefix[prefix.length - 1] - prefix[mid])\n                right = mid;\n            else\n                left = mid + 1;\n        }\n        return left;\n    };\n}"
      }
    },
    "1713": {
      "solution": {
        "greedy": ""
      }
    },
    "1714": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1715": {
      "solution": {
        "database": ""
      }
    },
    "1716": {
      "solution": {
        "math": ""
      }
    },
    "1717": {
      "solution": {
        "stack": ""
      }
    },
    "1718": {
      "solution": {
        "backtracking": ""
      }
    },
    "1719": {
      "solution": {
        "tree": "class Solution {\npublic:\n    int checkWays(vector<vector<int>>& pairs) {\n        constexpr int kMax = 501;\n        unordered_map<int, vector<int>> graph;\n        vector<int> degrees(kMax);\n        vector<vector<bool>> connected(kMax, vector<bool>(kMax));\n\n        for (const vector<int>& pair : pairs) {\n            const int u = pair[0];\n            const int v = pair[1];\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n            ++degrees[u];\n            ++degrees[v];\n            connected[u][v] = true;\n            connected[v][u] = true;\n        }\n\n        for (auto& [_, children] : graph)\n            ranges::sort(children, ranges::greater{},\n                         [&degrees](int child) { return degrees[child]; });\n\n        const int root = getRoot(degrees, graph.size());\n        if (root == -1)\n            return 0;\n        if (!dfs(graph, root, degrees, connected, {}, vector<bool>(kMax)))\n            return 0;\n        return hasMoreThanOneWay ? 2 : 1;\n    }\n\nprivate:\n    bool hasMoreThanOneWay = false;\n\n    // Returns the root by finding the node with a degree that equals to n - 1.\n    int getRoot(const vector<int>& degrees, int n) {\n        for (int i = 1; i < degrees.size(); ++i)\n            if (degrees[i] == n - 1)\n                return i;\n        return -1;\n    }\n\n    bool dfs(const unordered_map<int, vector<int>>& graph, int u,\n             vector<int>& degrees, vector<vector<bool>>& connected,\n             vector<int>&& ancestors, vector<bool>&& seen) {\n        seen[u] = true;\n\n        for (const int ancestor : ancestors)\n            if (!connected[u][ancestor])\n                return false;\n\n        ancestors.push_back(u);\n\n        for (const int v : graph.at(u)) {\n            if (seen[v])\n                continue;\n            if (degrees[v] == degrees[u])\n                hasMoreThanOneWay = true;\n            if (!dfs(graph, v, degrees, connected, std::move(ancestors),\n                     std::move(seen)))\n                return false;\n        }\n\n        ancestors.pop_back();\n        return true;\n    }\n};"
      }
    },
    "1720": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "1721": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1722": {
      "solution": {
        "union-find": ""
      }
    },
    "1723": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1724": {
      "solution": {
        "minimum-spanning-tree": "class UnionFind {\n public:\n  UnionFind() {}\n  UnionFind(int n) {\n    id.resize(n);\n\n    for (int i = 0; i < n; ++i)\n      id[i][0] = i;\n  }\n\n  void union_(int u, int v, int limit) {\n    const int i = find(u, limit);\n    const int j = find(v, limit);\n    if (i == j)\n      return;\n    id[i][limit] = j;\n  }\n\n  int find(int u, int limit) {\n    const auto it = id[u].upper_bound(limit);\n    const int i = prev(it)->second;\n    if (i == u)\n      return u;\n    const int j = find(i, limit);\n    id[u][limit] = j;\n    return j;\n  }\n\n private:\n  // id[i]'s (key, value) := (limit, id of node i <= limit)\n  vector<map<int, int>> id;\n};\n\nclass DistanceLimitedPathsExist {\n public:\n  DistanceLimitedPathsExist(int n, vector<vector<int>>& edgeList) {\n    uf = UnionFind(n);\n\n    ranges::sort(edgeList, ranges::less{},\n                 [](const vector<int>& edge) { return edge[2]; });\n\n    for (const vector<int>& edge : edgeList) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int d = edge[2];\n      uf.union_(u, v, d);\n    }\n  }\n\n  bool query(int p, int q, int limit) {\n    return uf.find(p, limit - 1) == uf.find(q, limit - 1);\n  }\n\n private:\n  UnionFind uf;\n};"
      }
    },
    "1725": {
      "solution": {
        "array": ""
      }
    },
    "1726": {
      "solution": {
        "counting": "class Solution {\npublic:\n    int tupleSameProduct(vector<int>& nums) {\n        unordered_map<int, int> productFreq;\n        int result = 0;\n\n        for (int i = 0; i < nums.size(); ++i) {\n            for (int j = i + 1; j < nums.size(); ++j) {\n                int product = nums[i] * nums[j]; \n                result += productFreq[product] * 8;\n                ++productFreq[product]; \n            }\n        }\n\n        return result;\n    }\n};\n"
      }
    },
    "1727": {
      "solution": {
        "matrix": ""
      }
    },
    "1728": {
      "solution": {
        "matrix": "import java.util.*;\n\nclass Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    private int rows, cols;\n    private int foodX, foodY;\n    private Map<String, Boolean> memo;\n    \n    public boolean canMouseWin(String[] grid, int catJump, int mouseJump) {\n        rows = grid.length;\n        cols = grid[0].length();\n        memo = new HashMap<>();\n        \n        int mouseX = 0, mouseY = 0, catX = 0, catY = 0;\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i].charAt(j) == 'M') {\n                    mouseX = i;\n                    mouseY = j;\n                } else if (grid[i].charAt(j) == 'C') {\n                    catX = i;\n                    catY = j;\n                } else if (grid[i].charAt(j) == 'F') {\n                    foodX = i;\n                    foodY = j;\n                }\n            }\n        }\n        \n        return dfs(grid, mouseX, mouseY, catX, catY, 0, catJump, mouseJump);\n    }\n    \n    private boolean dfs(String[] grid, int mouseX, int mouseY, int catX, int catY, int turns, int catJump, int mouseJump) {\n        if (turns >= 2 * rows * cols) return false; // Draw due to too many moves\n        String state = mouseX + \",\" + mouseY + \",\" + catX + \",\" + catY + \",\" + turns;\n        if (memo.containsKey(state)) return memo.get(state);\n        \n        // Check win/lose conditions\n        if (mouseX == foodX && mouseY == foodY) return true; // Mouse wins\n        if (catX == foodX && catY == foodY) return false; // Cat wins\n        if (mouseX == catX && mouseY == catY) return false; // Cat catches mouse\n        \n        boolean mouseTurn = (turns % 2 == 0);\n        if (mouseTurn) {\n            // Mouse's turn: try all possible moves\n            for (int[] direction : DIRECTIONS) {\n                for (int jump = 0; jump <= mouseJump; jump++) {\n                    int newX = mouseX + jump * direction[0];\n                    int newY = mouseY + jump * direction[1];\n                    \n                    if (!isValid(grid, newX, newY)) break; // Stop if out of bounds or wall\n                    \n                    if (dfs(grid, newX, newY, catX, catY, turns + 1, catJump, mouseJump)) {\n                        memo.put(state, true);\n                        return true; // Mouse wins\n                    }\n                }\n            }\n        } else {\n            // Cat's turn: try all possible moves\n            for (int[] direction : DIRECTIONS) {\n                for (int jump = 0; jump <= catJump; jump++) {\n                    int newX = catX + jump * direction[0];\n                    int newY = catY + jump * direction[1];\n                    \n                    if (!isValid(grid, newX, newY)) break; \n                    \n                    if (!dfs(grid, mouseX, mouseY, newX, newY, turns + 1, catJump, mouseJump)) {\n                        memo.put(state, false);\n                        return false; // Cat wins\n                    }\n                }\n            }\n        }\n        \n        memo.put(state, !mouseTurn);\n        return !mouseTurn;\n    }\n    \n    private boolean isValid(String[] grid, int x, int y) {\n        return x >= 0 && y >= 0 && x < rows && y < cols && grid[x].charAt(y) != '#';\n    }\n}\n"
      }
    },
    "1729": {
      "solution": {
        "database": ""
      }
    },
    "1730": {
      "solution": {
        "matrix": ""
      }
    },
    "1731": {
      "solution": {
        "database": ""
      }
    },
    "1732": {
      "solution": {
        "prefix-sum": "class Solution {\n    public int largestAltitude(int[] gain) {\n        int n = gain.length;\n        int maxAltitude = 0;\n        int currentAltitude = 0;\n\n        for (int i = 0; i < n; i++) {\n            currentAltitude += gain[i]; // Compute prefix sum as current altitude\n            maxAltitude = Math.max(maxAltitude, currentAltitude); // Update max altitude\n        }\n\n        return maxAltitude;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.largestAltitude(new int[]{-5, 1, 5, 0, -7})); // Output: 1\n        System.out.println(solution.largestAltitude(new int[]{-4, -3, -2, -1, 4, 3, 2})); // Output: 0\n        System.out.println(solution.largestAltitude(new int[]{1, 2, 3, -2, -1})); // Output: 6\n    }\n}\n"
      }
    },
    "1733": {
      "solution": {
        "greedy": ""
      }
    },
    "1734": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "1735": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1736": {
      "solution": {
        "greedy": ""
      }
    },
    "1737": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1738": {
      "solution": {
        "quickselect": "import java.util.*;\n\npublic class Solution {\n    public int kthLargestValue(int[][] matrix, int k) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        \n        int[][] xorMatrix = new int[m][n];\n        List<Integer> xorValues = new ArrayList<>();\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int xor = matrix[i][j];\n                if (i > 0) xor ^= xorMatrix[i - 1][j];\n                if (j > 0) xor ^= xorMatrix[i][j - 1];\n                if (i > 0 && j > 0) xor ^= xorMatrix[i - 1][j - 1];\n                xorMatrix[i][j] = xor;\n                xorValues.add(xor);\n            }\n        }\n        \n        int[] xorArray = xorValues.stream().mapToInt(Integer::intValue).toArray();\n        int kthLargestXOR = quickselect(xorArray, 0, xorArray.length - 1, xorArray.length - k);\n        \n        return kthLargestXOR;\n    }\n    \n    private int quickselect(int[] nums, int left, int right, int k) {\n        while (left < right) {\n            int pivotIndex = partition(nums, left, right);\n            if (pivotIndex == k) {\n                return nums[k];\n            } else if (pivotIndex < k) {\n                left = pivotIndex + 1;\n            } else {\n                right = pivotIndex - 1;\n            }\n        }\n        return nums[left];\n    }\n    \n    private int partition(int[] nums, int left, int right) {\n        int pivot = nums[right];\n        int i = left;\n        for (int j = left; j < right; j++) {\n            if (nums[j] < pivot) {\n                swap(nums, i++, j);\n            }\n        }\n        swap(nums, i, right);\n        return i;\n    }\n    \n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n"
      }
    },
    "1739": {
      "solution": {
        "greedy": ""
      }
    },
    "1740": {
      "solution": {
        "tree": ""
      }
    },
    "1741": {
      "solution": {
        "database": ""
      }
    },
    "1742": {
      "solution": {
        "counting": ""
      }
    },
    "1743": {
      "solution": {
        "hash-table": ""
      }
    },
    "1744": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1745": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1746": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1747": {
      "solution": {
        "database": ""
      }
    },
    "1748": {
      "solution": {
        "counting": "class Solution {\npublic:\n    int sumOfUnique(vector<int>& nums) {\n        unordered_map<int, int> freq;\n        int sum = 0;\n\n        for (int num : nums) {\n            ++freq[num];\n        }\n\n        for (const auto& [num, count] : freq) {\n            if (count == 1) { \n                sum += num;\n            }\n        }\n\n        return sum;\n    }\n};\n"
      }
    },
    "1749": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1750": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1751": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1752": {
      "solution": {
        "array": ""
      }
    },
    "1753": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1754": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1755": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1756": {
      "solution": {
        "stack": ""
      }
    },
    "1757": {
      "solution": {
        "database": ""
      }
    },
    "1758": {
      "solution": {
        "string": ""
      }
    },
    "1759": {
      "solution": {
        "math": ""
      }
    },
    "1760": {
      "solution": {
        "array": ""
      }
    },
    "1761": {
      "solution": {
        "graph": ""
      }
    },
    "1762": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "1763": {
      "solution": {
        "sliding-window": "class Solution {\n    public String longestNiceSubstring(String s) {\n        int n = s.length();\n        int k = -1;\n        int max = 0;\n        for (int i = 0; i < n; ++i) {\n            Set<Character> set = new HashSet<>();\n            for (int j = i; j < n; ++j) {\n                set.add(s.charAt(j));\n                boolean check = true;\n                for (char a : set) {\n                    char b = (char) (a ^ 32);\n                    if (!(set.contains(a) && set.contains(b))) {\n                        check = false;\n                        break;\n                    }\n                }\n                if (check && max < j - i + 1) {\n                    max = j - i + 1;\n                    k = i;\n                }\n            }\n        }\n        return k == -1 ? \"\" : s.substring(k, k + max);\n    }\n}"
      }
    },
    "1764": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1765": {
      "solution": {
        "matrix": ""
      }
    },
    "1766": {
      "solution": {
        "tree": ""
      }
    },
    "1767": {
      "solution": {
        "database": ""
      }
    },
    "1768": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1769": {
      "solution": {
        "string": ""
      }
    },
    "1770": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1771": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1772": {
      "solution": {
        "sorting": ""
      }
    },
    "1773": {
      "solution": {
        "string": ""
      }
    },
    "1774": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1775": {
      "solution": {
        "counting": ""
      }
    },
    "1776": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1777": {
      "solution": {
        "database": ""
      }
    },
    "1778": {
      "solution": {
        "interactive": ""
      }
    },
    "1779": {
      "solution": {
        "array": ""
      }
    },
    "1780": {
      "solution": {
        "math": ""
      }
    },
    "1781": {
      "solution": {
        "counting": ""
      }
    },
    "1782": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1783": {
      "solution": {
        "database": ""
      }
    },
    "1784": {
      "solution": {
        "string": ""
      }
    },
    "1785": {
      "solution": {
        "greedy": ""
      }
    },
    "1786": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1787": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1788": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1789": {
      "solution": {
        "database": ""
      }
    },
    "1790": {
      "solution": {
        "counting": "class Solution {\npublic:\n    bool areAlmostEqual(string s1, string s2) {\n        vector<int> diffIndices; \n        \n        for (int i = 0; i < s1.size(); ++i) {\n            if (s1[i] != s2[i]) {\n                diffIndices.push_back(i);\n            }\n        }\n\n        // If there are no mismatches, strings are already equal\n        if (diffIndices.empty()) {\n            return true;\n        }\n\n        // If there are exactly two mismatches, check if swapping fixes the issue\n        if (diffIndices.size() == 2) {\n            int i = diffIndices[0], j = diffIndices[1];\n            return s1[i] == s2[j] && s1[j] == s2[i];\n        }\n\n        // If there are more than two mismatches, we cannot fix with one swap\n        return false;\n    }\n};\n"
      }
    },
    "1791": {
      "solution": {
        "graph": ""
      }
    },
    "1792": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1793": {
      "solution": {
        "two-pointers": "class Solution {\n    public int maximumScore(int[] nums, int k) {\n        int ans = 0;\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        for (int i = 0; i <= nums.length; ++i) {\n            while (!stack.isEmpty() && (i == nums.length || nums[stack.peek()] > nums[i])) {\n                int h = nums[stack.pop()];\n                int w = stack.isEmpty() ? i : i - stack.peek() - 1;\n                if ((stack.isEmpty() || stack.peek() + 1 <= k) && i - 1 >= k)\n                    ans = Math.max(ans, h * w);\n            }\n            stack.push(i);\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "1794": {
      "solution": {
        "greedy": ""
      }
    },
    "1795": {
      "solution": {
        "database": ""
      }
    },
    "1796": {
      "solution": {
        "hash-table": ""
      }
    },
    "1797": {
      "solution": {
        "linked-list": ""
      }
    },
    "1798": {
      "solution": {
        "greedy": ""
      }
    },
    "1799": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1800": {
      "solution": {
        "array": ""
      }
    },
    "1801": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1802": {
      "solution": {
        "greedy": ""
      }
    },
    "1803": {
      "solution": {
        "trie": ""
      }
    },
    "1804": {
      "solution": {
        "trie": ""
      }
    },
    "1805": {
      "solution": {
        "hash-table": ""
      }
    },
    "1806": {
      "solution": {
        "math": ""
      }
    },
    "1807": {
      "solution": {
        "hash-table": ""
      }
    },
    "1808": {
      "solution": {
        "recursion": ""
      }
    },
    "1809": {
      "solution": {
        "database": ""
      }
    },
    "1810": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1811": {
      "solution": {
        "database": ""
      }
    },
    "1812": {
      "solution": {
        "math": ""
      }
    },
    "1813": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1814": {
      "solution": {
        "counting": ""
      }
    },
    "1815": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1816": {
      "solution": {
        "string": ""
      }
    },
    "1817": {
      "solution": {
        "hash-table": ""
      }
    },
    "1818": {
      "solution": {
        "ordered-set": ""
      }
    },
    "1819": {
      "solution": {
        "number-theory": ""
      }
    },
    "1820": {
      "solution": {
        "matrix": ""
      }
    },
    "1821": {
      "solution": {
        "database": ""
      }
    },
    "1822": {
      "solution": {
        "math": ""
      }
    },
    "1823": {
      "solution": {
        "queue": "class Solution {\n    public int findTheWinner(int n, int k) {\n        List<Integer> players = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            players.add(i);\n        }\n        \n        int index = 0;\n        while (players.size() > 1) {\n            index = (index + k - 1) % players.size();\n            players.remove(index);\n        }\n        \n        return players.get(0);\n    }\n}\n"
      }
    },
    "1824": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1825": {
      "solution": {
        "queue": ""
      }
    },
    "1826": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1827": {
      "solution": {
        "greedy": ""
      }
    },
    "1828": {
      "solution": {
        "geometry": ""
      }
    },
    "1829": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1830": {
      "solution": {
        "combinatorics": ""
      }
    },
    "1831": {
      "solution": {
        "database": ""
      }
    },
    "1832": {
      "solution": {
        "hash-table": ""
      }
    },
    "1833": {
      "solution": {
        "greedy": ""
      }
    },
    "1834": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1835": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "1836": {
      "solution": {
        "linked-list": ""
      }
    },
    "1837": {
      "solution": {
        "math": ""
      }
    },
    "1838": {
      "solution": {
        "sliding-window": "import java.util.Arrays;\n\npublic class Solution {\n    public int maxFrequency(int[] nums, int k) {\n        Arrays.sort(nums); \n        int left = 0;\n        long sum = 0; \n        int maxFreq = 0; \n        \n        for (int right = 0; right < nums.length; right++) {\n            sum += nums[right];\n            while ((right - left + 1) * (long) nums[right] - sum > k) {\n                sum -= nums[left]; \n                left++;\n            }            \n            int windowSize = right - left + 1;\n            maxFreq = Math.max(maxFreq, windowSize);\n        }\n        \n        return maxFreq;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();        \n        int[] nums = {1, 2, 4};\n        int k = 5;\n        System.out.println(solution.maxFrequency(nums, k)); // Output: 3\n    }\n}\n"
      }
    },
    "1839": {
      "solution": {
        "sliding-window": "class Solution {\n  public int longestBeautifulSubstring(String word) {\n    int ans = 0;\n    int count = 1;\n\n    for (int left = 0, right = 1; right < word.length(); ++right) {\n    char curr = word.charAt(right);\n    char prev = word.charAt(right - 1);\n      if (curr >= prev) {\n        if (curr > prev)\n          ++count;\n        if (count == 5)\n          ans = Math.max(ans, right - left + 1);\n      } else {\n        count = 1;\n        left = right;\n      }\n    }\n\n    return ans;\n  }\n}"
      }
    },
    "1840": {
      "solution": {
        "sorting": ""
      }
    },
    "1841": {
      "solution": {
        "database": ""
      }
    },
    "1842": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1843": {
      "solution": {
        "database": ""
      }
    },
    "1844": {
      "solution": {
        "string": ""
      }
    },
    "1845": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1846": {
      "solution": {
        "greedy": ""
      }
    },
    "1847": {
      "solution": {
        "sorting": ""
      }
    },
    "1848": {
      "solution": {
        "array": ""
      }
    },
    "1849": {
      "solution": {
        "backtracking": ""
      }
    },
    "1850": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1851": {
      "solution": {
        "line-sweep": "class T {\n  public int size;\n  public int right;\n  public T(int size, int right) {\n    this.size = size;\n    this.right = right;\n  }\n}\n\nclass Solution {\n  public int[] minInterval(int[][] intervals, int[] queries) {\n    int[] ans = new int[queries.length];\n    Arrays.fill(ans, -1);\n    \n    // Use a minHeap to store intervals sorted by size\n    PriorityQueue<T> minHeap = new PriorityQueue<>((a, b) -> a.size - b.size);\n    \n    // Store the indices of queries\n    Integer[] indices = new Integer[queries.length];\n    for (int i = 0; i < queries.length; ++i)\n      indices[i] = i;\n    \n    // Sort intervals by start time and queries by value\n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n    Arrays.sort(indices, (a, b) -> queries[a] - queries[b]);\n\n    int i = 0; // intervals' index\n    for (final int index : indices) {\n      // Add intervals to the minHeap that start before or at the current query\n      while (i < intervals.length && intervals[i][0] <= queries[index]) {\n        minHeap.offer(new T(intervals[i][1] - intervals[i][0] + 1, intervals[i][1]));\n        ++i;\n      }\n      \n      // Remove intervals from minHeap that end before the current query\n      while (!minHeap.isEmpty() && minHeap.peek().right < queries[index])\n        minHeap.poll();\n      \n      // Assign the size of the smallest interval in minHeap to the current query\n      if (!minHeap.isEmpty())\n        ans[index] = minHeap.peek().size;\n    }\n\n    return ans;\n  }\n}\n"
      }
    },
    "1852": {
      "solution": {
        "sliding-window": "class Solution {\n    public int[] distinctNumbers(int[] nums, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int i = 0; i < k; ++i) {\n            count.merge(nums[i], 1, Integer::sum);\n        }\n        int n = nums.length;\n        int[] ans = new int[n - k + 1];\n        ans[0] = count.size();\n        for (int i = k; i < n; ++i) {\n            count.merge(nums[i], 1, Integer::sum);\n            if (count.merge(nums[i - k], -1, Integer::sum) == 0) {\n                count.remove(nums[i - k]);\n            }\n            ans[i - k + 1] = count.size();\n        }\n        return ans;\n    }\n}"
      }
    },
    "1853": {
      "solution": {
        "database": ""
      }
    },
    "1854": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1855": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1856": {
      "solution": {
        "monotonic-stack": "import java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Solution {\n    public int maxSumMinProduct(int[] nums) {\n        int n = nums.length;\n        long[] prefixSum = new long[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n        \n        int[] left = new int[n];\n        int[] right = new int[n];\n        \n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && nums[stack.peek()] >= nums[i]) {\n                stack.pop();\n            }\n            left[i] = stack.isEmpty() ? 0 : stack.peek() + 1;\n            stack.push(i);\n        }\n        \n        stack.clear();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && nums[stack.peek()] >= nums[i]) {\n                stack.pop();\n            }\n            right[i] = stack.isEmpty() ? n : stack.peek();\n            stack.push(i);\n        }\n        \n        long maxMinProduct = 0;\n        for (int i = 0; i < n; i++) {\n            long minProduct = (prefixSum[right[i]] - prefixSum[left[i]]) * nums[i];\n            maxMinProduct = Math.max(maxMinProduct, minProduct);\n        }\n        \n        return (int) (maxMinProduct % 1000000007);\n    }\n}\n"
      }
    },
    "1857": {
      "solution": {
        "topological-sort": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        vector<vector<int>> graph(n);\n        vector<int> inDegree(n, 0);\n        \n        for (auto& edge : edges) {\n            graph[edge[0]].push_back(edge[1]);\n            inDegree[edge[1]]++;\n        }\n        \n        vector<vector<int>> count(n, vector<int>(26, 0));\n        \n        queue<int> q;\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0) {\n                q.push(i);\n            }\n        }\n        \n        int processedNodes = 0, maxColorValue = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            processedNodes++;\n            \n            count[node][colors[node] - 'a']++;\n            maxColorValue = max(maxColorValue, count[node][colors[node] - 'a']);\n            \n            for (int neighbor : graph[node]) {\n                for (int c = 0; c < 26; c++) {\n                    count[neighbor][c] = max(count[neighbor][c], count[node][c]);\n                }\n                \n                inDegree[neighbor]--;\n                if (inDegree[neighbor] == 0) {\n                    q.push(neighbor);\n                }\n            }\n        }\n        \n        if (processedNodes < n) {\n            return -1;\n        }\n        \n        return maxColorValue;\n    }\n};\n"
      }
    },
    "1858": {
      "solution": {
        "trie": "struct TrieNode {\n    TrieNode *next[26] = {};\n    bool word = false;\n};\nclass Solution {\n    void addWord(TrieNode *node, string &s) {\n        for (char c : s) {\n            if (!node->next[c - 'a']) node->next[c - 'a'] = new TrieNode();\n            node = node->next[c - 'a'];\n        }\n        node->word = true;\n    }\n    string ans, path;\n    void dfs(TrieNode *node) {\n        for (int i = 0; i < 26; ++i) {\n            if (!node->next[i] || !node->next[i]->word) continue;\n            path += 'a' + i;\n            if (path.size() > ans.size()) ans = path;\n            dfs(node->next[i]);\n            path.pop_back();\n        }\n    }\npublic:\n    string longestWord(vector<string>& A) {\n        TrieNode root;\n        for (auto &s : A) addWord(&root, s);\n        dfs(&root);\n        return ans;\n    }\n};"
      }
    },
    "1859": {
      "solution": {
        "sorting": ""
      }
    },
    "1860": {
      "solution": {
        "math": ""
      }
    },
    "1861": {
      "solution": {
        "matrix": "class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    public char[][] rotateTheBox(char[][] box) {\n        int rows = box.length;\n        int cols = box[0].length;\n        \n        // Simulate gravity for each row\n        for (int i = 0; i < rows; i++) {\n            applyGravity(box, i, cols);\n        }\n        \n        // Rotate the box 90 degrees clockwise\n        char[][] rotatedBox = new char[cols][rows];\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                rotatedBox[j][rows - 1 - i] = box[i][j];\n            }\n        }\n        \n        return rotatedBox;\n    }\n    \n    private void applyGravity(char[][] box, int row, int cols) {\n        // Start from the rightmost column and process stones\n        int emptySpace = cols - 1; // Pointer to the last empty space\n        for (int col = cols - 1; col >= 0; col--) {\n            if (box[row][col] == '#') {\n                // Place stone at the empty space\n                box[row][col] = '.';\n                box[row][emptySpace] = '#';\n                emptySpace--;\n            } else if (box[row][col] == '*') {\n                // Reset empty space pointer due to obstacle\n                emptySpace = col - 1;\n            }\n        }\n    }\n}\n"
      }
    },
    "1862": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1863": {
      "solution": {
        "combinatorics": ""
      }
    },
    "1864": {
      "solution": {
        "greedy": ""
      }
    },
    "1865": {
      "solution": {
        "design": ""
      }
    },
    "1866": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1867": {
      "solution": {
        "database": ""
      }
    },
    "1868": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1869": {
      "solution": {
        "string": ""
      }
    },
    "1870": {
      "solution": {
        "array": ""
      }
    },
    "1871": {
      "solution": {
        "sliding-window": "class Solution {\n  public boolean canReach(String s, int minJump, int maxJump) {\n    int count = 0;\n    boolean dp[] = new boolean[s.length()];\n    dp[0] = true;\n\n    for (int i = minJump; i < s.length(); ++i) {\n      count += dp[i - minJump] ? 1 : 0;\n      if (i - maxJump > 0)\n        count -= dp[i - maxJump - 1] ? 1 : 0;\n      dp[i] = count > 0 && s.charAt(i) == '0';\n    }\n\n    return dp[dp.length - 1];\n  }\n}"
      }
    },
    "1872": {
      "solution": {
        "breadth-first-search": "class Solution {\n public:\n  int stoneGameVIII(vector<int>& stones) {\n    const int n = stones.size();\n    vector<int> prefix(n);\n    // dp[i] := the maximum score difference the current player can get when the\n    // game starts at i, i.e. stones[0..i] are merged into the value prefix[i]\n    vector<int> dp(n, INT_MIN);\n\n    partial_sum(stones.begin(), stones.end(), prefix.begin());\n\n    // Must take all when there're only two stones left.\n    dp[n - 2] = prefix.back();\n\n    for (int i = n - 3; i >= 0; --i)\n      dp[i] = max(dp[i + 1], prefix[i + 1] - dp[i + 1]);\n\n    return dp[0];\n  }\n};"
      }
    },
    "1873": {
      "solution": {
        "database": ""
      }
    },
    "1874": {
      "solution": {
        "greedy": ""
      }
    },
    "1875": {
      "solution": {
        "database": ""
      }
    },
    "1876": {
      "solution": {
        "sliding-window": "class Solution {\n    public int countGoodSubstrings(String s) {\n        int count = 0;\n        int n = s.length();\n        \n        for (int i = 0; i <= n - 3; i++) {\n            if (s.charAt(i) != s.charAt(i + 1) && \n                s.charAt(i) != s.charAt(i + 2) &&\n                s.charAt(i + 1) != s.charAt(i + 2)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n}\n"
      }
    },
    "1877": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1878": {
      "solution": {
        "matrix": ""
      }
    },
    "1879": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1880": {
      "solution": {
        "string": ""
      }
    },
    "1881": {
      "solution": {
        "greedy": ""
      }
    },
    "1882": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1883": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1884": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1885": {
      "solution": {
        "two-pointers": "class Solution {\n    public long countPairs(int[] nums1, int[] nums2) {\n        long count = 0;\n        int n = nums1.length;\n        int[] differences = new int[n];\n        for (int i = 0; i < n; i++)\n            differences[i] = nums1[i] - nums2[i];\n        Arrays.sort(differences);\n        for (int i = 0; i < n - 1; i++) {\n            int target = -differences[i] + 1;\n            int index = binarySearch(differences, n, target, i + 1);\n            count += n - index;\n        }\n        return count;\n    }\n\n    public int binarySearch(int[] differences, int n, int target, int startIndex) {\n        int low = startIndex, high = n - 1;\n        if (differences[high] < target)\n            return n;\n        while (low < high) {\n            int mid = (high - low) / 2 + low;\n            if (differences[mid] < target)\n                low = mid + 1;\n            else\n                high = mid;\n        }\n        return low;\n    }\n}"
      }
    },
    "1886": {
      "solution": {
        "matrix": ""
      }
    },
    "1887": {
      "solution": {
        "sorting": ""
      }
    },
    "1888": {
      "solution": {
        "sliding-window": "class Solution {\n  public int minFlips(String s) {\n  int n = s.length();\n    int[][] count = new int[2][2];\n\n    for (int i = 0; i < n; ++i)\n      ++count[s.charAt(i) - '0'][i % 2];\n\n    int ans = Math.min(count[1][0] + count[0][1], count[0][0] + count[1][1]);\n\n    for (int i = 0; i < n; ++i) {\n      --count[s.charAt(i) - '0'][i % 2];\n      ++count[s.charAt(i) - '0'][(n + i) % 2];\n      ans = Math.min(ans, Math.min(count[1][0] + count[0][1], count[0][0] + count[1][1]));\n    }\n\n    return ans;\n  }\n}"
      }
    },
    "1889": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1890": {
      "solution": {
        "database": ""
      }
    },
    "1891": {
      "solution": {
        "array": ""
      }
    },
    "1892": {
      "solution": {
        "database": ""
      }
    },
    "1893": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1894": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1895": {
      "solution": {
        "matrix": "class Solution {\n    public int largestMagicSquare(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int[][] rowSum = new int[m][n + 1]; // Prefix sums for rows\n        int[][] colSum = new int[m + 1][n]; // Prefix sums for columns\n\n        // Calculate prefix sums for rows\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                rowSum[i][j + 1] = rowSum[i][j] + grid[i][j];\n            }\n        }\n\n        // Calculate prefix sums for columns\n        for (int j = 0; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                colSum[i + 1][j] = colSum[i][j] + grid[i][j];\n            }\n        }\n\n        for (int size = Math.min(m, n); size > 1; size--) {\n            for (int i = 0; i + size <= m; i++) {\n                for (int j = 0; j + size <= n; j++) {\n                    if (isMagic(grid, rowSum, colSum, i, j, size)) {\n                        return size;\n                    }\n                }\n            }\n        }\n\n        return 1; // The smallest magic square is always size 1\n    }\n\n    private boolean isMagic(int[][] grid, int[][] rowSum, int[][] colSum, int x, int y, int size) {\n        int target = 0;\n\n        // Calculate the target sum using the first row\n        for (int j = 0; j < size; j++) {\n            target += grid[x][y + j];\n        }\n\n        // Check rows\n        for (int i = 0; i < size; i++) {\n            int rowSumValue = rowSum[x + i][y + size] - rowSum[x + i][y];\n            if (rowSumValue != target) return false;\n        }\n\n        // Check columns\n        for (int j = 0; j < size; j++) {\n            int colSumValue = colSum[x + size][y + j] - colSum[x][y + j];\n            if (colSumValue != target) return false;\n        }\n\n        // Check main diagonal\n        int diag1 = 0;\n        for (int i = 0; i < size; i++) {\n            diag1 += grid[x + i][y + i];\n        }\n        if (diag1 != target) return false;\n\n        // Check secondary diagonal\n        int diag2 = 0;\n        for (int i = 0; i < size; i++) {\n            diag2 += grid[x + i][y + size - 1 - i];\n        }\n        if (diag2 != target) return false;\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        int[][] grid1 = {\n            {7, 1, 4, 5, 6},\n            {2, 5, 1, 6, 4},\n            {1, 5, 4, 3, 2},\n            {1, 2, 7, 3, 4}\n        };\n        System.out.println(solution.largestMagicSquare(grid1)); // Output: 3\n\n        int[][] grid2 = {\n            {5, 1, 3, 1},\n            {9, 3, 3, 1},\n            {1, 3, 3, 8}\n        };\n        System.out.println(solution.largestMagicSquare(grid2)); // Output: 2\n    }\n}\n"
      }
    },
    "1896": {
      "solution": {
        "stack": ""
      }
    },
    "1897": {
      "solution": {
        "counting": ""
      }
    },
    "1898": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1899": {
      "solution": {
        "greedy": ""
      }
    },
    "1900": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1901": {
      "solution": {
        "matrix": "",
        "binary-search": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findPeakGrid(vector<vector<int>>& mat) {\n        int rows = mat.size();\n        int cols = mat[0].size();\n\n        int left = 0, right = cols - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            int maxRow = 0;\n            for (int i = 1; i < rows; ++i) {\n                if (mat[i][mid] > mat[maxRow][mid]) {\n                    maxRow = i;\n                }\n            }\n\n            if ((mid == 0 || mat[maxRow][mid] > mat[maxRow][mid - 1]) &&\n                (mid == cols - 1 || mat[maxRow][mid] > mat[maxRow][mid + 1])) {\n                return {maxRow, mid};\n            }\n            else if (mid > 0 && mat[maxRow][mid - 1] > mat[maxRow][mid]) {\n                right = mid - 1;\n            }\n            else {\n                left = mid + 1;\n            }\n        }\n\n        return {};\n    }\n};\n"
      }
    },
    "1902": {
      "solution": {
        "binary-search-tree": "class Solution {\n    public int maxDepthBST(int[] order) {\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        map.put(0, 0);\n        map.put(Integer.MAX_VALUE, 0);\n        map.put(order[0], 1);\n        int ans = 1;\n        for (int i = 1; i < order.length; ++i) {\n            int v = order[i];\n            Map.Entry<Integer, Integer> lower = map.lowerEntry(v);\n            Map.Entry<Integer, Integer> higher = map.higherEntry(v);\n            int depth = 1 + Math.max(lower.getValue(), higher.getValue());\n            ans = Math.max(ans, depth);\n            map.put(v, depth);\n        }\n        return ans;\n    }\n}"
      }
    },
    "1903": {
      "solution": {
        "greedy": ""
      }
    },
    "1904": {
      "solution": {
        "math": ""
      }
    },
    "1905": {
      "solution": {
        "union-find": "",
        "matrix": "class Solution {\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\n        int m = grid1.length;\n        int n = grid1[0].length;\n        int count = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid2[i][j] == 1) {\n                    if (isSubIsland(grid1, grid2, i, j)) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n\n    private boolean isSubIsland(int[][] grid1, int[][] grid2, int i, int j) {\n        boolean isSubIsland = true;\n        isSubIsland = dfs(grid1, grid2, i, j, isSubIsland);\n        return isSubIsland;\n    }\n\n    private boolean dfs(int[][] grid1, int[][] grid2, int i, int j, boolean isSubIsland) {\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\n            return isSubIsland;\n        }\n        if (grid1[i][j] != 1) {\n            isSubIsland = false;\n        }\n        grid2[i][j] = 0;\n        isSubIsland = dfs(grid1, grid2, i + 1, j, isSubIsland);\n        isSubIsland = dfs(grid1, grid2, i - 1, j, isSubIsland);\n        isSubIsland = dfs(grid1, grid2, i, j + 1, isSubIsland);\n        isSubIsland = dfs(grid1, grid2, i, j - 1, isSubIsland);\n        return isSubIsland;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] grid1 = {\n            {1, 1, 0, 0, 0},\n            {1, 1, 0, 0, 0},\n            {0, 0, 1, 0, 0},\n            {0, 0, 0, 1, 1}\n        };\n        int[][] grid2 = {\n            {1, 1, 0, 0, 0},\n            {0, 1, 0, 0, 0},\n            {0, 0, 1, 0, 0},\n            {0, 0, 0, 1, 0}\n        };\n\n        int result = solution.countSubIslands(grid1, grid2);\n        System.out.println(\"Number of Sub-Islands: \" + result); // Output will depend on grid1 and grid2\n    }\n}\n"
      }
    },
    "1906": {
      "solution": {
        "hash-table": ""
      }
    },
    "1907": {
      "solution": {
        "database": ""
      }
    },
    "1908": {
      "solution": {
        "brainteaser": "class Solution {\n    public boolean nimGame(int[] piles) {\n        int xor = 0;\n        for (int pile : piles)\n            xor ^= pile;\n        return xor != 0;\n    }\n}"
      }
    },
    "1909": {
      "solution": {
        "array": ""
      }
    },
    "1910": {
      "solution": {
        "string": ""
      }
    },
    "1911": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1912": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1913": {
      "solution": {
        "sorting": ""
      }
    },
    "1914": {
      "solution": {
        "matrix": ""
      }
    },
    "1915": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1916": {
      "solution": {
        "topological-sort": ""
      }
    },
    "1917": {
      "solution": {
        "database": ""
      }
    },
    "1918": {
      "solution": {
        "sliding-window": "class Solution {\n    public int kthSmallestSubarraySum(int[] nums, int k) {\n        int min = Integer.MAX_VALUE, sum = 0;\n        for (int num : nums) {\n            min = Math.min(min, num);\n            sum += num;\n        }\n        int low = min, high = sum;\n        while (low < high) {\n            int mid = (high - low) / 2 + low;\n            int count = countSubarrays(nums, mid);\n            if (count < k)\n                low = mid + 1;\n            else\n                high = mid;\n        }\n        return low;\n    }\n\n    public int countSubarrays(int[] nums, int threshold) {\n        int count = 0;\n        int sum = 0;\n        int length = nums.length;\n        int left = 0, right = 0;\n        while (right < length) {\n            sum += nums[right];\n            while (sum > threshold) {\n                sum -= nums[left];\n                left++;\n            }\n            count += right - left + 1;\n            right++;\n        }\n        return count;\n    }\n}"
      }
    },
    "1919": {
      "solution": {
        "database": ""
      }
    },
    "1920": {
      "solution": {
        "array": ""
      }
    },
    "1921": {
      "solution": {
        "greedy": ""
      }
    },
    "1922": {
      "solution": {
        "recursion": "class Solution {\npublic:\n    const int MOD = 1e9 + 7;\n\n    int countGoodNumbers(long long n) {\n        long long evenCount = (n + 1) / 2;\n        long long oddCount = n / 2;\n\n        long long evenPower = modExp(5, evenCount, MOD);\n        long long oddPower = modExp(4, oddCount, MOD);\n\n        return (evenPower * oddPower) % MOD;\n    }\n\nprivate:\n    long long modExp(long long base, long long exp, int mod) {\n        if (exp == 0)\n            return 1;\n        long long half = modExp(base, exp / 2, mod);\n        half = (half * half) % mod;\n        if (exp % 2 != 0) {\n            half = (half * base) % mod;\n        }\n        return half;\n    }\n};\n"
      }
    },
    "1923": {
      "solution": {
        "suffix-array": "class Solution {\n    public int longestCommonSubpath(int n, int[][] paths) {\n        int left = 0;\n        int right = paths[0].length;\n\n        while (left < right) {\n          int m = left + (right - left + 1) / 2;\n            if (checkCommonSubpath(paths, m))\n                left = m;\n            else\n                right = m - 1;\n        }\n\n        return left;\n    }\n\n    private static final long kMod = 8_417_508_174_513L;\n    private static final long kBase = 165_131L;\n\n    private boolean checkCommonSubpath(int[][] paths, int m) {\n        Set<Long>[] hashSets = new Set[paths.length];\n\n        for (int i = 0; i < paths.length; ++i)\n            hashSets[i] = rabinKarp(paths[i], m);\n\n        for (final long subpathHash : hashSets[0])\n            if (Arrays.stream(hashSets).allMatch(hashSet -> hashSet.contains(subpathHash)))\n                return true;\n\n        return false;\n    }\n\n    private Set<Long> rabinKarp(int[] path, int m) {\n        Set<Long> hashes = new HashSet<>();\n        long maxPower = 1;\n        long hash = 0;\n        for (int i = 0; i < path.length; ++i) {\n            hash = (hash * kBase + path[i]) % kMod;\n            if (i >= m)\n                hash = (hash - path[i - m] * maxPower % kMod + kMod) % kMod;\n            else\n                maxPower = maxPower * kBase % kMod;\n            if (i >= m - 1)\n                hashes.add(hash);\n        }\n        return hashes;\n    }\n}"
      }
    },
    "1924": {
      "solution": {
        "geometry": ""
      }
    },
    "1925": {
      "solution": {
        "enumeration": ""
      }
    },
    "1926": {
      "solution": {
        "matrix": ""
      }
    },
    "1927": {
      "solution": {
        "game-theory": ""
      }
    },
    "1928": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1929": {
      "solution": {
        "array": ""
      }
    },
    "1930": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1931": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1932": {
      "solution": {
        "tree": ""
      }
    },
    "1933": {
      "solution": {
        "string": ""
      }
    },
    "1934": {
      "solution": {
        "database": ""
      }
    },
    "1935": {
      "solution": {
        "hash-table": ""
      }
    },
    "1936": {
      "solution": {
        "greedy": ""
      }
    },
    "1937": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1938": {
      "solution": {
        "trie": ""
      }
    },
    "1939": {
      "solution": {
        "database": ""
      }
    },
    "1940": {
      "solution": {
        "counting": "class Solution {\npublic:\n    vector<int> longestCommomSubsequence(vector<vector<int>>& arrays) {\n        unordered_map<int, int> counter;\n        vector<int> res;\n        int n = arrays.size();\n        for (auto array : arrays) {\n            for (auto e : array) {\n                counter[e] += 1;\n                if (counter[e] == n) {\n                    res.push_back(e);\n                }\n            }\n        }\n        return res;\n    }\n};"
      }
    },
    "1941": {
      "solution": {
        "counting": ""
      }
    },
    "1942": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1943": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1944": {
      "solution": {
        "monotonic-stack": "import java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Solution {\n    public int[] canSeePersonsCount(int[] heights) {\n        int n = heights.length;\n        int[] result = new int[n];\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && heights[stack.peek()] <= heights[i]) {\n                result[stack.pop()]++;\n            }\n            if (!stack.isEmpty()) {\n                result[stack.peek()]++; \n            }\n            stack.push(i);\n        }\n\n        return result;\n    }\n}\n"
      }
    },
    "1945": {
      "solution": {
        "string": ""
      }
    },
    "1946": {
      "solution": {
        "greedy": ""
      }
    },
    "1947": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1948": {
      "solution": {
        "hash-function": ""
      }
    },
    "1949": {
      "solution": {
        "database": ""
      }
    },
    "1950": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "1951": {
      "solution": {
        "database": ""
      }
    },
    "1952": {
      "solution": {
        "number-theory": "#include <cmath>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i <= sqrt(num); ++i) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    bool isThree(int n) {\n        int root = sqrt(n);\n        \n        return root * root == n && isPrime(root);\n    }\n};\n"
      }
    },
    "1953": {
      "solution": {
        "greedy": ""
      }
    },
    "1954": {
      "solution": {
        "math": ""
      }
    },
    "1955": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1956": {
      "solution": {
        "geometry": ""
      }
    },
    "1957": {
      "solution": {
        "string": ""
      }
    },
    "1958": {
      "solution": {
        "matrix": ""
      }
    },
    "1959": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1960": {
      "solution": {
        "rolling-hash": "class Solution {\npublic:\n    long long maxProduct(string s) {\n        const int n = s.length();\n        long ans = 1;\n        vector<long> pows{1}; // pows[i] := kBase^i % kHash\n        // hashL[i] = the hash of the first i letters of s, where hashL[i] =\n        // (26^(i - 1) * s[0] + 26^(i - 2) * s[1] + ... + s[i - 1]) % kHash\n        vector<long> hashL{0};\n        // hashR[i] = the hash of the last i letters of s, where hashR[i] =\n        // (26^(i - 1) * s[-1] + 26^(i - 2) * s[-2] + ... + s[-i]) % kHash\n        vector<long> hashR{0};\n        // maxLeft[i] := the maximum odd length of palindromes in s[0..i]\n        vector<int> maxLeft(n);\n        // maxRight[i] := the maximum odd length of palindromes in s[i..n - 1]\n        vector<int> maxRight(n);\n\n        for (int i = 0; i < n; ++i)\n            pows.push_back(pows.back() * kBase % kHash);\n\n        for (int i = 0; i < n; ++i)\n            hashL.push_back((hashL.back() * kBase + val(s[i])) % kHash);\n\n        for (int i = n - 1; i >= 0; --i)\n            hashR.push_back((hashR.back() * kBase + val(s[i])) % kHash);\n\n        ranges::reverse(hashR);\n\n        int maxLength = 1;\n        for (int r = 0; r < n; ++r) {\n            const int l = (r - maxLength - 2) + 1;\n            if (l >= 0 && isPalindrome(l, r + 1, hashL, hashR, pows))\n                maxLength += 2;\n            maxLeft[r] = maxLength;\n        }\n\n        maxLength = 1;\n        for (int l = n - 1; l >= 0; --l) {\n            const int r = (l + maxLength + 2) - 1;\n            if (r < n && isPalindrome(l, r + 1, hashL, hashR, pows))\n                maxLength += 2;\n            maxRight[l] = maxLength;\n        }\n\n        for (int i = 1; i < n; ++i)\n            ans = max(ans, static_cast<long>(maxLeft[i - 1]) * maxRight[i]);\n\n        return ans;\n    }\n\nprivate:\n    static constexpr int kBase = 26;\n    static constexpr int kHash = 1'000'000'007;\n\n    static constexpr int val(char c) { return c - 'a'; }\n\n    bool isPalindrome(int l, int r, const vector<long>& hashL,\n                      const vector<long>& hashR, const vector<long>& pows) {\n        return getLeftRollingHash(l, r, hashL, pows) ==\n               getRightRollingHash(l, r, hashR, pows);\n    }\n\n    // Returns the left rolling hash of s[l..r).\n    long getLeftRollingHash(int l, int r, const vector<long>& hashL,\n                            const vector<long>& pows) {\n        const long h = (hashL[r] - hashL[l] * pows[r - l]) % kHash;\n        return h < 0 ? h + kHash : h;\n    }\n\n    // Returns the right rolling hash of s[l..r).\n    long getRightRollingHash(int l, int r, const vector<long>& hashR,\n                             const vector<long>& pows) {\n        const long h = (hashR[l] - hashR[r] * pows[r - l]) % kHash;\n        return h < 0 ? h + kHash : h;\n    }\n};"
      }
    },
    "1961": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1962": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "1963": {
      "solution": {
        "two-pointers": ""
      }
    },
    "1964": {
      "solution": {
        "array": ""
      }
    },
    "1965": {
      "solution": {
        "database": ""
      }
    },
    "1966": {
      "solution": {
        "array": ""
      }
    },
    "1967": {
      "solution": {
        "string": ""
      }
    },
    "1968": {
      "solution": {
        "greedy": ""
      }
    },
    "1969": {
      "solution": {
        "recursion": ""
      }
    },
    "1970": {
      "solution": {
        "union-find": ""
      }
    },
    "1971": {
      "solution": {
        "union-find": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\nprivate:\n    vector<int> parent;\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unionSets(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            parent[rootY] = rootX;\n        }\n    }\n\npublic:\n    bool validPath(int n, vector<vector<int>>& edges, int source,\n                   int destination) {\n        parent.resize(n);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n\n        for (const auto& edge : edges) {\n            unionSets(edge[0], edge[1]);\n        }\n\n        return find(source) == find(destination);\n    }\n};\n"
      }
    },
    "1972": {
      "solution": {
        "database": ""
      }
    },
    "1973": {
      "solution": {
        "tree": ""
      }
    },
    "1974": {
      "solution": {
        "greedy": ""
      }
    },
    "1975": {
      "solution": {
        "matrix": "class Solution {\n    public long maxMatrixSum(int[][] matrix) {\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n\n        long totalSum = 0;\n        int minAbsValue = Integer.MAX_VALUE;\n        int negativeCount = 0;\n\n        for (int[] row : matrix) {\n            for (int num : row) {\n                totalSum += Math.abs(num);\n                if (num < 0) {\n                    negativeCount++;\n                }\n                minAbsValue = Math.min(minAbsValue, Math.abs(num));\n            }\n        }\n\n        // If the count of negatives is odd, adjust the sum\n        if (negativeCount % 2 != 0) {\n            totalSum -= 2 * minAbsValue;\n        }\n\n        return totalSum;\n    }\n}\n"
      }
    },
    "1976": {
      "solution": {
        "shortest-path": "class Solution {\npublic:\n    int countPaths(int n, vector<vector<int>>& roads) {\n        vector<vector<pair<int, int>>> graph(n);\n\n        for (const vector<int>& road : roads) {\n            const int u = road[0];\n            const int v = road[1];\n            const int w = road[2];\n            graph[u].emplace_back(v, w);\n            graph[v].emplace_back(u, w);\n        }\n\n        return dijkstra(graph, 0, n - 1);\n    }\n\nprivate:\n    int dijkstra(const vector<vector<pair<int, int>>>& graph, int src,\n                 int dst) {\n        constexpr int kMod = 1'000'000'007;\n        vector<long> ways(graph.size());\n        vector<long> dist(graph.size(), LONG_MAX);\n\n        ways[src] = 1;\n        dist[src] = 0;\n        using P = pair<long, int>; // (d, u)\n        priority_queue<P, vector<P>, greater<>> minHeap;\n        minHeap.emplace(dist[src], src);\n\n        while (!minHeap.empty()) {\n            const auto [d, u] = minHeap.top();\n            minHeap.pop();\n            if (d > dist[u])\n                continue;\n            for (const auto& [v, w] : graph[u])\n                if (d + w < dist[v]) {\n                    dist[v] = d + w;\n                    ways[v] = ways[u];\n                    minHeap.emplace(dist[v], v);\n                } else if (d + w == dist[v]) {\n                    ways[v] += ways[u];\n                    ways[v] %= kMod;\n                }\n        }\n\n        return ways[dst];\n    }\n};"
      }
    },
    "1977": {
      "solution": {
        "suffix-array": "class Solution {\n    public int numberOfCombinations(String num) {\n        if (num.charAt(0) == '0')\n            return 0;\n\n      int kMod = 1_000_000_007;\n      int n = num.length();\n        // dp[i][k] := the number of possible lists of integers ending in num[i] with\n        // the length of the last number being 1..k\n        long[][] dp = new long[n][n + 1];\n        // lcs[i][j] := the number of the same digits in num[i..n) and num[j..n)\n        int[][] lcs = new int[n + 1][n + 1];\n\n        // Step 1: Compute LCS array\n        for (int i = n - 1; i >= 0; --i)\n            for (int j = i + 1; j < n; ++j)\n                if (num.charAt(i) == num.charAt(j))\n                    lcs[i][j] = lcs[i + 1][j + 1] + 1;\n\n        // Step 2: Dynamic programming to count number of combinations\n        for (int i = 0; i < n; ++i)\n            for (int k = 1; k <= i + 1; ++k) {\n                dp[i][k] += dp[i][k - 1];\n                dp[i][k] %= kMod;\n                // The last number is num[s..i].\n              int s = i - k + 1;\n                if (num.charAt(s) == '0')\n                    // If the number starts with '0', skip it as it's invalid\n                    continue;\n                if (s == 0) {\n                    // If the whole string is considered, increment the count by 1\n                    dp[i][k] += 1;\n                    continue;\n                }\n                if (s < k) {\n                    // If the length k is not enough, add counts from num[0..s - 1]\n                    dp[i][k] += dp[s - 1][s];\n                    continue;\n                }\n              int left = lcs[s - k][s];\n                if (left >= k || num.charAt(s - k + left) <= num.charAt(s + left))\n                    // If num[s - k..s - 1] <= num[s..i], add counts from dp[s - 1][k]\n                    dp[i][k] += dp[s - 1][k];\n                else\n                    // Otherwise, add counts from dp[s - 1][k - 1]\n                    dp[i][k] += dp[s - 1][k - 1];\n                \n                dp[i][k] %= kMod;\n            }\n\n        return (int) dp[n - 1][n] % kMod;\n    }\n}\n"
      }
    },
    "1978": {
      "solution": {
        "database": ""
      }
    },
    "1979": {
      "solution": {
        "number-theory": "#include <algorithm>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    int findGCD(vector<int>& nums) {\n        int minNum = *min_element(nums.begin(), nums.end());\n        int maxNum = *max_element(nums.begin(), nums.end());\n\n        return gcd(minNum, maxNum);\n    }\n};\n"
      }
    },
    "1980": {
      "solution": {
        "backtracking": ""
      }
    },
    "1981": {
      "solution": {
        "matrix": "class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    private Integer[][] memo;\n\n    public int minimizeTheDifference(int[][] mat, int target) {\n        int rows = mat.length;\n        int cols = mat[0].length;\n        memo = new Integer[rows][5000]; \n\n        for (int[] row : mat) {\n            Arrays.sort(row);\n        }\n\n        return dfs(mat, target, 0, 0);\n    }\n\n    private int dfs(int[][] mat, int target, int row, int currentSum) {\n        if (row == mat.length) {\n            return Math.abs(currentSum - target);\n        }\n\n        // Memoization check\n        if (memo[row][currentSum] != null) {\n            return memo[row][currentSum];\n        }\n\n        int minDiff = Integer.MAX_VALUE;\n\n        // Explore each element in the current row\n        for (int num : mat[row]) {\n            int newSum = currentSum + num;\n            if (newSum - target > minDiff) break; // Prune if new sum exceeds current minDiff\n            \n            minDiff = Math.min(minDiff, dfs(mat, target, row + 1, newSum));\n        }\n\n        return memo[row][currentSum] = minDiff;\n    }\n}\n"
      }
    },
    "1982": {
      "solution": {
        "divide-and-conquer": "class Solution {\npublic:\n    vector<int> recoverArray(int n, vector<int>& sums) {\n        ranges::sort(sums);\n        return recover(sums);\n    }\n\nprivate:\n    vector<int> recover(const vector<int>& sums) {\n        if (sums.size() == 1) // sums[0] must be 0.\n            return {};\n\n        // Either num or -num must be in the final array.\n        //  num + sumsExcludingNum = sumsIncludingNum\n        // -num + sumsIncludingNum = sumsExcludingNum\n        unordered_map<int, int> count;\n        for (const int sum : sums)\n            ++count[sum];\n\n        const int num = sums[1] - sums[0];\n        vector<int> sumsExcludingNum;\n        vector<int> sumsIncludingNum;\n        bool chooseSumsIncludingNum = false;\n\n        for (const int sum : sums) {\n            if (count[sum] == 0)\n                continue;\n            --count[sum];\n            --count[sum + num];\n            sumsExcludingNum.push_back(sum);\n            sumsIncludingNum.push_back(sum + num);\n            if (sum + num == 0)\n                chooseSumsIncludingNum = true;\n        }\n\n        vector<int> recovered = recover(\n            chooseSumsIncludingNum ? sumsIncludingNum : sumsExcludingNum);\n        recovered.push_back(chooseSumsIncludingNum ? -num : num);\n        return recovered;\n    }\n};"
      }
    },
    "1983": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "1984": {
      "solution": {
        "sliding-window": "import java.util.Arrays;\n\nclass Solution {\n    public int minimumDifference(int[] nums, int k) {\n        Arrays.sort(nums);\n        int minDiff = Integer.MAX_VALUE;\n        for (int i = 0; i <= nums.length - k; i++) {\n            int diff = nums[i + k - 1] - nums[i];\n            minDiff = Math.min(minDiff, diff);\n        }\n\n        return minDiff;\n    }\n}\n"
      }
    },
    "1985": {
      "solution": {
        "quickselect": "class Solution {\n    Random rand;\n\n    public int compare(String a, String b) {\n        if (a.length() != b.length()) {\n            return b.length() - a.length();\n        } else {\n            return b.compareTo(a);\n        }\n    }\n\n    public String kthLargestNumber(String[] nums, int k) {\n        rand = new Random();\n        quickSort(nums, k, 0, nums.length);\n        return nums[k - 1];\n    }\n\n    public void quickSort(String[] nums, int k, int start, int end) {\n        int selected = start + rand.nextInt(end - start);\n        swap(nums, selected, start);\n        int idx = start;\n        for (int i = start + 1; i < end; i++) {\n            if (compare(nums[start], nums[i]) > 0) {\n                swap(nums, ++idx, i);\n            }\n        }\n        swap(nums, idx, start);\n        if (k == idx - start + 1) {\n            return;\n        } else if (k < idx - start + 1) {\n            quickSort(nums, k, start, idx);\n        } else {\n            quickSort(nums, k - (idx - start + 1), idx + 1, end);\n        }\n    }\n\n    public void swap(String[] nums, int a, int b) {\n        String temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}",
        "heap-(priority-queue)": "class Solution {\n\n  public String kthLargestNumber(String[] nums, int k) {\n    Queue<String> minHeap = new PriorityQueue<>(\n        (a, b) -> a.length() == b.length() ? a.compareTo(b) : a.length() - b.length());\n\n    for (final String num : nums) {\n      minHeap.offer(num);\n      if (minHeap.size() > k)\n        minHeap.poll();\n    }\n\n    return minHeap.poll();\n  }\n}"
      }
    },
    "1986": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1987": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1988": {
      "solution": {
        "database": ""
      }
    },
    "1989": {
      "solution": {
        "greedy": ""
      }
    },
    "1990": {
      "solution": {
        "database": ""
      }
    },
    "1991": {
      "solution": {
        "prefix-sum": "class Solution {\n    public int findMiddleIndex(int[] nums) {\n        int totalSum = 0;\n        int leftSum = 0;\n\n        for (int num : nums) {\n            totalSum += num;\n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            if (leftSum == totalSum - leftSum - nums[i]) {\n                return i;\n            }\n            leftSum += nums[i];\n        }\n\n        // If no middle index is found, return -1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.findMiddleIndex(new int[]{2, 3, -1, 8, 4})); // Output: 3\n        System.out.println(solution.findMiddleIndex(new int[]{1, 2, 3})) ; // Output: -1\n    }\n}\n"
      }
    },
    "1992": {
      "solution": {
        "matrix": "class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    private boolean[][] visited;\n\n    public int[][] findFarmland(int[][] land) {\n        int rows = land.length;\n        int cols = land[0].length;\n        visited = new boolean[rows][cols];\n\n        List<int[]> result = new ArrayList<>();\n\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (land[r][c] == 1 && !visited[r][c]) {\n                    int[] bounds = new int[4]; // {topRow, leftCol, bottomRow, rightCol}\n                    bounds[0] = r; // Initialize top-left row\n                    bounds[1] = c; // Initialize top-left col\n                    bounds[2] = r; // Initialize bottom-right row\n                    bounds[3] = c; // Initialize bottom-right col\n\n                    dfs(land, r, c, bounds);\n\n                    result.add(bounds);\n                }\n            }\n        }\n\n        return result.toArray(new int[result.size()][]);\n    }\n\n    private void dfs(int[][] land, int r, int c, int[] bounds) {\n        visited[r][c] = true;\n\n        // Update rectangle boundaries\n        bounds[0] = Math.min(bounds[0], r); // Update top row\n        bounds[1] = Math.min(bounds[1], c); // Update left column\n        bounds[2] = Math.max(bounds[2], r); // Update bottom row\n        bounds[3] = Math.max(bounds[3], c); // Update right column\n\n        for (int[] direction : DIRECTIONS) {\n            int newRow = r + direction[0];\n            int newCol = c + direction[1];\n\n            // Check bounds and whether the cell is unvisited farmland\n            if (newRow >= 0 && newRow < land.length && newCol >= 0 && newCol < land[0].length \n                && land[newRow][newCol] == 1 && !visited[newRow][newCol]) {\n                dfs(land, newRow, newCol, bounds);\n            }\n        }\n    }\n}\n"
      }
    },
    "1993": {
      "solution": {
        "tree": ""
      }
    },
    "1994": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1995": {
      "solution": {
        "enumeration": ""
      }
    },
    "1996": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "1997": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "1998": {
      "solution": {
        "union-find": ""
      }
    },
    "1999": {
      "solution": {
        "enumeration": ""
      }
    },
    "2000": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2001": {
      "solution": {
        "number-theory": ""
      }
    },
    "2002": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2003": {
      "solution": {
        "union-find": ""
      }
    },
    "2004": {
      "solution": {
        "database": ""
      }
    },
    "2005": {
      "solution": {
        "game-theory": ""
      }
    },
    "2006": {
      "solution": {
        "counting": ""
      }
    },
    "2007": {
      "solution": {
        "greedy": ""
      }
    },
    "2008": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2009": {
      "solution": {
        "sliding-window": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\nclass Solution {\n    public int minOperations(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int num : nums) {\n            set.add(num);\n        }\n        int[] uniqueNums = new int[set.size()];\n        int index = 0;\n        for (int num : set) {\n            uniqueNums[index++] = num;\n        }\n        Arrays.sort(uniqueNums);\n\n        int maxLength = 0;\n        int left = 0;\n        for (int right = 0; right < uniqueNums.length; ++right) {\n            while (uniqueNums[right] - uniqueNums[left] >= nums.length) {\n                left++;\n            }\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return nums.length - maxLength;\n    }\n}\n"
      }
    },
    "2010": {
      "solution": {
        "database": ""
      }
    },
    "2011": {
      "solution": {
        "string": ""
      }
    },
    "2012": {
      "solution": {
        "array": ""
      }
    },
    "2013": {
      "solution": {
        "counting": ""
      }
    },
    "2014": {
      "solution": {
        "backtracking": ""
      }
    },
    "2015": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2016": {
      "solution": {
        "array": ""
      }
    },
    "2017": {
      "solution": {
        "matrix": ""
      }
    },
    "2018": {
      "solution": {
        "matrix": ""
      }
    },
    "2019": {
      "solution": {
        "stack": ""
      }
    },
    "2020": {
      "solution": {
        "database": ""
      }
    },
    "2021": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2022": {
      "solution": {
        "matrix": "class Solution {\n  public int[][] construct2DArray(int[] original, int m, int n) {\n    if (original.length != m * n)\n      return new int[][] {};\n\n    int[][] ans = new int[m][n];\n\n    for (int i = 0; i < original.length; ++i)\n      ans[i / n][i % n] = original[i];\n\n    return ans;\n  }\n}"
      }
    },
    "2023": {
      "solution": {
        "counting": ""
      }
    },
    "2024": {
      "solution": {
        "sliding-window": "class Solution {\n    public int maxConsecutiveAnswers(String answerKey, int k) {\n        return Math.max(maxConsecutiveChar(answerKey, k, 'T'), maxConsecutiveChar(answerKey, k, 'F'));\n    }\n\n    private int maxConsecutiveChar(String answerKey, int k, char ch) {\n        int maxLen = 0;\n        int left = 0, right = 0;\n        int flipCount = 0;\n\n        while (right < answerKey.length()) {\n            if (answerKey.charAt(right) != ch) {\n                flipCount++;\n            }\n\n            while (flipCount > k) {\n                if (answerKey.charAt(left) != ch) {\n                    flipCount--;\n                }\n                left++;\n            }\n\n            maxLen = Math.max(maxLen, right - left + 1);\n            right++;\n        }\n\n        return maxLen;\n    }\n}\n"
      }
    },
    "2025": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2026": {
      "solution": {
        "database": ""
      }
    },
    "2027": {
      "solution": {
        "greedy": ""
      }
    },
    "2028": {
      "solution": {
        "math": ""
      }
    },
    "2029": {
      "solution": {
        "game-theory": "class Solution {\npublic:\n    bool stoneGameIX(vector<int>& stones) {\n        vector<int> count(3);\n\n        for (const int stone : stones)\n            ++count[stone % 3];\n\n        if (count[0] % 2 == 0)\n            return min(count[1], count[2]) > 0;\n        return abs(count[1] - count[2]) > 2;\n    }\n};"
      }
    },
    "2030": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "2031": {
      "solution": {
        "merge-sort": "class FenwickTree {\n  public FenwickTree(int n) {\n    sums = new int[n + 1];\n  }\n\n  public void add(int i, int delta) {\n    while (i < sums.length) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  public int get(int i) {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n\n  private int[] sums;\n\n  private static int lowbit(int i) {\n    return i & -i;\n  }\n}\n\nclass Solution {\n  public int subarraysWithMoreZerosThanOnes(int[] nums) {\n  int kMod = 1_000_000_007;\n  int n = nums.length;\n    int ans = 0;\n    int prefix = 0;\n    FenwickTree tree = new FenwickTree(2 * n + 1);\n    tree.add(remap(0, n), 1);\n\n    for (final int num : nums) {\n      prefix += num == 0 ? -1 : 1;\n      ans += tree.get(remap(prefix - 1, n));\n      ans %= kMod;\n      tree.add(remap(prefix, n), 1);\n    }\n\n    return ans;\n  }\n\n  private int remap(int i, int n) {\n    return i + n + 1;\n  }\n}"
      }
    },
    "2032": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2033": {
      "solution": {
        "matrix": ""
      }
    },
    "2034": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2035": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2036": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2037": {
      "solution": {
        "greedy": ""
      }
    },
    "2038": {
      "solution": {
        "game-theory": "class Solution {\npublic:\n    bool winnerOfGame(string colors) {\n        int countA = 0, countB = 0;\n        \n        for (int i = 1; i < colors.size() - 1; ++i) {\n            if (colors[i] == 'A' && colors[i - 1] == 'A' && colors[i + 1] == 'A') {\n                countA++;\n            }\n            if (colors[i] == 'B' && colors[i - 1] == 'B' && colors[i + 1] == 'B') {\n                countB++;\n            }\n        }\n        \n        return countA > countB;  // A wins if it can remove more pieces\n    }\n};\n"
      }
    },
    "2039": {
      "solution": {
        "graph": ""
      }
    },
    "2040": {
      "solution": {
        "array": ""
      }
    },
    "2041": {
      "solution": {
        "database": ""
      }
    },
    "2042": {
      "solution": {
        "string": ""
      }
    },
    "2043": {
      "solution": {
        "design": ""
      }
    },
    "2044": {
      "solution": {
        "backtracking": ""
      }
    },
    "2045": {
      "solution": {
        "shortest-path": "class Solution {\npublic:\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\n        vector<vector<int>> graph(n + 1);\n        queue<pair<int, int>> q{{{1, 0}}};\n        // minTime[u][0] := the first minimum time to reach the node u\n        // minTime[u][1] := the second minimum time to reach the node u\n        vector<vector<int>> minTime(n + 1, vector<int>(2, INT_MAX));\n        minTime[1][0] = 0;\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n        }\n\n        while (!q.empty()) {\n            const auto [u, prevTime] = q.front();\n            q.pop();\n            // Start from green.\n            // If `numChangeSignal` is odd, now red.\n            // If `numChangeSignal` is even, now green.\n            const int numChangeSignal = prevTime / change;\n            const int waitTime =\n                numChangeSignal % 2 == 0 ? 0 : change - prevTime % change;\n            const int newTime = prevTime + waitTime + time;\n            for (const int v : graph[u])\n                if (newTime < minTime[v][0]) {\n                    minTime[v][0] = newTime;\n                    q.emplace(v, newTime);\n                } else if (minTime[v][0] < newTime && newTime < minTime[v][1]) {\n                    if (v == n)\n                        return newTime;\n                    minTime[v][1] = newTime;\n                    q.emplace(v, newTime);\n                }\n        }\n\n        throw;\n    }\n};"
      }
    },
    "2046": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2047": {
      "solution": {
        "string": ""
      }
    },
    "2048": {
      "solution": {
        "backtracking": ""
      }
    },
    "2049": {
      "solution": {
        "tree": ""
      }
    },
    "2050": {
      "solution": {
        "topological-sort": ""
      }
    },
    "2051": {
      "solution": {
        "database": ""
      }
    },
    "2052": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2053": {
      "solution": {
        "counting": "class Solution {\npublic:\n    string kthDistinct(vector<string>& arr, int k) {\n        unordered_map<string, int> freq; \n        \n        for (const string& str : arr) {\n            ++freq[str];\n        }\n\n        vector<string> distinctStrings;\n        for (const string& str : arr) {\n            if (freq[str] == 1) {\n                distinctStrings.push_back(str);\n            }\n        }\n\n        // Return the k-th distinct string if it exists\n        return (k <= distinctStrings.size()) ? distinctStrings[k - 1] : \"\";\n    }\n};\n"
      }
    },
    "2054": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2055": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2056": {
      "solution": {
        "backtracking": ""
      }
    },
    "2057": {
      "solution": {
        "array": ""
      }
    },
    "2058": {
      "solution": {
        "linked-list": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        if (!head || !head->next || !head->next->next)\n            return {-1, -1};\n\n        vector<int> criticalIndices;\n        ListNode* prev = head;\n        ListNode* curr = head->next;\n        int index = 1;\n\n        while (curr->next) {\n            if ((curr->val > prev->val && curr->val > curr->next->val) ||\n                (curr->val < prev->val && curr->val < curr->next->val)) {\n                criticalIndices.push_back(index);\n            }\n            prev = curr;\n            curr = curr->next;\n            index++;\n        }\n\n        if (criticalIndices.size() < 2)\n            return {-1, -1};\n\n        int minDist = INT_MAX;\n        for (int i = 1; i < criticalIndices.size(); ++i) {\n            minDist = min(minDist, criticalIndices[i] - criticalIndices[i - 1]);\n        }\n\n        int maxDist = criticalIndices.back() - criticalIndices.front();\n        return {minDist, maxDist};\n    }\n};\n"
      }
    },
    "2059": {
      "solution": {
        "breadth-first-search": ""
      }
    },
    "2060": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2061": {
      "solution": {
        "matrix": ""
      }
    },
    "2062": {
      "solution": {
        "hash-table": ""
      }
    },
    "2063": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2064": {
      "solution": {
        "array": ""
      }
    },
    "2065": {
      "solution": {
        "backtracking": ""
      }
    },
    "2066": {
      "solution": {
        "database": ""
      }
    },
    "2067": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2068": {
      "solution": {
        "counting": "class Solution {\n public:\n  bool checkAlmostEquivalent(string word1, string word2) {\n    vector<int> count(26);\n\n    for (const char c : word1)\n      ++count[c - 'a'];\n\n    for (const char c : word2)\n      --count[c - 'a'];\n\n    return ranges::all_of(count, [](int freq) { return abs(freq) <= 3; });\n  }\n};"
      }
    },
    "2069": {
      "solution": {
        "design": ""
      }
    },
    "2070": {
      "solution": {
        "sorting": ""
      }
    },
    "2071": {
      "solution": {
        "monotonic-queue": "import java.util.Arrays;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Solution {\n    private int[] tasks;\n    private int[] workers;\n    private int strength;\n    private int pills;\n    private int taskCount;\n    private int workerCount;\n\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\n        Arrays.sort(tasks);\n        Arrays.sort(workers);\n        this.tasks = tasks;\n        this.workers = workers;\n        this.strength = strength;\n        this.pills = pills;\n        taskCount = tasks.length; \n        workerCount = workers.length; \n\n        int left = 0, right = Math.min(workerCount, taskCount);\n        while (left < right) {\n            int mid = (left + right + 1) / 2; \n            if (check(mid)) {\n                left = mid; \n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return left; \n    }\n\n    private boolean check(int x) {\n        int taskIdx = 0;\n        Deque<Integer> taskQueue = new ArrayDeque<>();\n        int remainingPills = pills;\n\n        for (int workerIdx = workerCount - x; workerIdx < workerCount; ++workerIdx) {\n            while (taskIdx < x && tasks[taskIdx] <= workers[workerIdx] + strength) {\n                taskQueue.offer(tasks[taskIdx++]); \n            }\n            if (taskQueue.isEmpty()) {\n                return false;\n            }\n            if (taskQueue.peekFirst() <= workers[workerIdx]) {\n                taskQueue.pollFirst(); \n            } else if (remainingPills == 0) {\n                return false; \n            } else {\n                --remainingPills; \n                taskQueue.pollLast();\n            }\n        }\n      \n        return true; \n    }\n}"
      }
    },
    "2072": {
      "solution": {
        "database": ""
      }
    },
    "2073": {
      "solution": {
        "queue": ""
      }
    },
    "2074": {
      "solution": {
        "linked-list": ""
      }
    },
    "2075": {
      "solution": {
        "string": ""
      }
    },
    "2076": {
      "solution": {
        "union-find": ""
      }
    },
    "2077": {
      "solution": {
        "graph": ""
      }
    },
    "2078": {
      "solution": {
        "greedy": ""
      }
    },
    "2079": {
      "solution": {
        "array": ""
      }
    },
    "2080": {
      "solution": {
        "design": ""
      }
    },
    "2081": {
      "solution": {
        "enumeration": ""
      }
    },
    "2082": {
      "solution": {
        "database": ""
      }
    },
    "2083": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2084": {
      "solution": {
        "database": ""
      }
    },
    "2085": {
      "solution": {
        "counting": ""
      }
    },
    "2086": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2087": {
      "solution": {
        "greedy": ""
      }
    },
    "2088": {
      "solution": {
        "matrix": ""
      }
    },
    "2089": {
      "solution": {
        "sorting": "",
        "binary-search": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        sort(nums.begin(), nums.end());\n        \n        vector<int> result;\n        int n = nums.size();\n        \n        int left = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\n        if (left == n || nums[left] != target) return result;\n        while (left < n && nums[left] == target) {\n            result.push_back(left);\n            left++;\n        }\n        \n        return result;\n    }\n};\n"
      }
    },
    "2090": {
      "solution": {
        "sliding-window": "class Solution {\n    public int[] getAverages(int[] nums, int k) {\n        int n = nums.length;\n        int[] result = new int[n];\n        Arrays.fill(result, -1);\n\n        if (2 * k + 1 > n) return result;  \n        long windowSum = 0;\n        int windowSize = 2 * k + 1;\n        for (int i = 0; i < windowSize; i++) {\n            windowSum += nums[i];\n        }\n        result[k] = (int)(windowSum / windowSize);\n        for (int i = k + 1; i < n - k; i++) {\n            windowSum = windowSum - nums[i - k - 1] + nums[i + k];\n            result[i] = (int)(windowSum / windowSize);\n        }\n\n        return result;\n    }\n}\n"
      }
    },
    "2091": {
      "solution": {
        "greedy": ""
      }
    },
    "2092": {
      "solution": {
        "union-find": ""
      }
    },
    "2093": {
      "solution": {
        "shortest-path": "class Solution {\npublic:\n    int minimumCost(int n, vector<vector<int>>& E, int d) {\n        vector<unordered_map<int, int>> G(n);\n        for (auto &e : E) {\n            int u = e[0], v = e[1], w = e[2];\n            G[u][v] = w;\n            G[v][u] = w;\n        }\n        vector<vector<int>> dist(d + 1, vector<int>(n, INT_MAX));\n        auto dijkstra = [&](int i) {\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\n            pq.emplace(0, 0);\n            dist[i][0] = 0;\n            while (pq.size()) {\n                auto [cost, u] = pq.top();\n                pq.pop();\n                if (cost > dist[i][u]) continue;\n                for (auto &[v, w] : G[u]) {\n                    int keep = cost + w, use = i > 0 ? dist[i - 1][u] + w / 2 : INT_MAX, newCost = min(use, keep);\n                    if (dist[i][v] > newCost) {\n                        dist[i][v] = newCost;\n                        pq.emplace(dist[i][v], v);\n                    }\n                }\n            }\n        };\n        for (int i = 0; i <= d; ++i) dijkstra(i);\n        return dist[d][n - 1] == INT_MAX ? -1 : dist[d][n - 1];\n    }\n};"
      }
    },
    "2094": {
      "solution": {
        "enumeration": ""
      }
    },
    "2095": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2096": {
      "solution": {
        "tree": ""
      }
    },
    "2097": {
      "solution": {
        "eulerian-circuit": "class Solution {\n    public int[][] validArrangement(int[][] pairs) {\n        List<int[]> ans = new ArrayList<>();\n        Map<Integer, Stack<Integer>> graph = new HashMap<>();\n        Map<Integer, Integer> outDegree = new HashMap<>();\n        Map<Integer, Integer> inDegrees = new HashMap<>();\n\n        for (int[] pair : pairs) {\n          int start = pair[0];\n          int end = pair[1];\n            graph.putIfAbsent(start, new Stack<>());\n            graph.get(start).push(end);\n            outDegree.merge(start, 1, Integer::sum);\n            inDegrees.merge(end, 1, Integer::sum);\n        }\n\n      int startNode = getStartNode(graph, outDegree, inDegrees, pairs);\n        eulerDFS(graph, startNode, ans);\n        Collections.reverse(ans);\n        return ans.stream().toArray(int[][]::new);\n    }\n\n    private int getStartNode(Map<Integer, Stack<Integer>> graph, Map<Integer, Integer> outDegree,\n            Map<Integer, Integer> inDegrees, int[][] pairs) {\n        for (final int u : graph.keySet())\n            if (outDegree.getOrDefault(u, 0) - inDegrees.getOrDefault(u, 0) == 1)\n                return u;\n        return pairs[0][0];\n    }\n\n    private void eulerDFS(Map<Integer, Stack<Integer>> graph, int u, List<int[]> ans) {\n        Stack<Integer> stack = graph.get(u);\n        while (stack != null && !stack.isEmpty()) {\n          int v = stack.pop();\n            eulerDFS(graph, v, ans);\n            ans.add(new int[] { u, v });\n        }\n    }\n}"
      }
    },
    "2098": {
      "solution": {
        "greedy": ""
      }
    },
    "2099": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2100": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2101": {
      "solution": {
        "geometry": ""
      }
    },
    "2102": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2103": {
      "solution": {
        "hash-table": ""
      }
    },
    "2104": {
      "solution": {
        "monotonic-stack": "class Solution {\n    public long subArrayRanges(int[] nums) {\n        return subarraySum(nums, '<') - subarraySum(nums, '>');\n    }\n\n    private long subarraySum(int[] A, char op) {\n        int n = A.length;\n        long res = 0;\n        int[] prev = new int[n];\n        int[] next = new int[n];\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        Arrays.fill(prev, -1);\n        Arrays.fill(next, n);\n\n        for (int i = 0; i < n; ++i) {\n            while (!stack.isEmpty() && func(op, A[stack.peek()], A[i])) {\n                int index = stack.pop();\n                next[index] = i;\n            }\n            if (!stack.isEmpty())\n                prev[i] = stack.peek();\n            stack.push(i);\n        }\n\n        for (int i = 0; i < n; ++i)\n            res += (long) A[i] * (i - prev[i]) * (next[i] - i);\n\n        return res;\n    }\n\n    private boolean func(char op, int a, int b) {\n        if (op == '<')\n            return a < b;\n        return a > b;\n    }\n}"
      }
    },
    "2105": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2106": {
      "solution": {
        "sliding-window": "class Solution {\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\n      int maxRight = Math.max(startPos, fruits[fruits.length - 1][0]);\n        int ans = 0;\n        int[] amounts = new int[1 + maxRight];\n        int[] prefix = new int[2 + maxRight];\n\n        for (int[] dp : fruits)\n            amounts[dp[0]] = dp[1];\n\n        for (int i = 0; i + 1 < prefix.length; ++i)\n            prefix[i + 1] = prefix[i] + amounts[i];\n\n      int maxRightSteps = Math.min(maxRight - startPos, k);\n        for (int rightSteps = 0; rightSteps <= maxRightSteps; ++rightSteps) {\n          int leftSteps = Math.max(0, k - 2 * rightSteps);\n            ans = Math.max(ans, getFruits(startPos, maxRight, leftSteps, rightSteps, prefix));\n        }\n\n      int maxLeftSteps = Math.min(startPos, k);\n        for (int leftSteps = 0; leftSteps <= maxLeftSteps; ++leftSteps) {\n          int rightSteps = Math.max(0, k - 2 * leftSteps);\n            ans = Math.max(ans, getFruits(startPos, maxRight, leftSteps, rightSteps, prefix));\n        }\n\n        return ans;\n    }\n\n    private int getFruits(int startPos, int maxRight, int leftSteps, int rightSteps, int[] prefix) {\n      int left = Math.max(0, startPos - leftSteps);\n      int right = Math.min(maxRight, startPos + rightSteps);\n        return prefix[right + 1] - prefix[left];\n    }\n}"
      }
    },
    "2107": {
      "solution": {
        "sliding-window": "class Solution {\n    public int shareCandies(int[] candies, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        int n = candies.length;\n        for (int i = k; i < n; ++i) {\n            count.merge(candies[i], 1, Integer::sum);\n        }\n        int ans = count.size();\n        for (int i = k; i < candies.length; ++i) {\n            if (count.merge(candies[i], -1, Integer::sum) == 0) {\n                count.remove(candies[i]);\n            }\n            count.merge(candies[i - k], 1, Integer::sum);\n            ans = Math.max(ans, count.size());\n        }\n        return ans;\n    }\n}"
      }
    },
    "2108": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2109": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2110": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2111": {
      "solution": {
        "array": ""
      }
    },
    "2112": {
      "solution": {
        "database": ""
      }
    },
    "2113": {
      "solution": {
        "array": ""
      }
    },
    "2114": {
      "solution": {
        "string": ""
      }
    },
    "2115": {
      "solution": {
        "topological-sort": ""
      }
    },
    "2116": {
      "solution": {
        "stack": ""
      }
    },
    "2117": {
      "solution": {
        "math": ""
      }
    },
    "2118": {
      "solution": {
        "database": ""
      }
    },
    "2119": {
      "solution": {
        "math": ""
      }
    },
    "2120": {
      "solution": {
        "string": ""
      }
    },
    "2121": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2122": {
      "solution": {
        "enumeration": ""
      }
    },
    "2123": {
      "solution": {
        "matrix": ""
      }
    },
    "2124": {
      "solution": {
        "string": ""
      }
    },
    "2125": {
      "solution": {
        "matrix": ""
      }
    },
    "2126": {
      "solution": {
        "greedy": ""
      }
    },
    "2127": {
      "solution": {
        "topological-sort": ""
      }
    },
    "2128": {
      "solution": {
        "matrix": "class Solution {\n    public boolean removeOnes(int[][] grid) {\n        Set<String> s = new HashSet<>();\n        int n = grid[0].length;\n        for (var row : grid) {\n            var cs = new char[n];\n            for (int i = 0; i < n; ++i) {\n                cs[i] = (char) (row[0] ^ row[i]);\n            }\n            s.add(String.valueOf(cs));\n        }\n        return s.size() == 1;\n    }\n}"
      }
    },
    "2129": {
      "solution": {
        "string": ""
      }
    },
    "2130": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2131": {
      "solution": {
        "counting": ""
      }
    },
    "2132": {
      "solution": {
        "matrix": ""
      }
    },
    "2133": {
      "solution": {
        "matrix": "class Solution {\n  public boolean checkValid(int[][] matrix) {\n    final int n = matrix.length;\n\n    for (int i = 0; i < n; ++i) {\n      Set<Integer> row = new HashSet<>();\n      Set<Integer> col = new HashSet<>();\n      for (int j = 0; j < n; ++j) {\n        row.add(matrix[i][j]);\n        col.add(matrix[j][i]);\n      }\n      if (Math.min(row.size(), col.size()) < n)\n        return false;\n    }\n\n    return true;\n  }\n}"
      }
    },
    "2134": {
      "solution": {
        "sliding-window": "class Solution {\n    public int minSwaps(int[] nums) {\n      int n = nums.length;\n      int k = (int) Arrays.stream(nums).filter(a -> a == 1).count();\n        int ones = 0;\n        int maxOnes = 0;\n\n        for (int i = 0; i < n * 2; ++i) {\n            if (i >= k && nums[(i - k) % n] == 1)\n                --ones;\n            if (nums[i % n] == 1)\n                ++ones;\n            maxOnes = Math.max(maxOnes, ones);\n        }\n\n        return k - maxOnes;\n    }\n}"
      }
    },
    "2135": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2136": {
      "solution": {
        "greedy": ""
      }
    },
    "2137": {
      "solution": {
        "array": ""
      }
    },
    "2138": {
      "solution": {
        "string": ""
      }
    },
    "2139": {
      "solution": {
        "greedy": ""
      }
    },
    "2140": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2141": {
      "solution": {
        "greedy": ""
      }
    },
    "2142": {
      "solution": {
        "database": ""
      }
    },
    "2143": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2144": {
      "solution": {
        "greedy": ""
      }
    },
    "2145": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2146": {
      "solution": {
        "matrix": ""
      }
    },
    "2147": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2148": {
      "solution": {
        "sorting": ""
      }
    },
    "2149": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2150": {
      "solution": {
        "counting": ""
      }
    },
    "2151": {
      "solution": {
        "backtracking": ""
      }
    },
    "2152": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2153": {
      "solution": {
        "database": ""
      }
    },
    "2154": {
      "solution": {
        "sorting": ""
      }
    },
    "2155": {
      "solution": {
        "array": ""
      }
    },
    "2156": {
      "solution": {
        "sliding-window": "class Solution {\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\n        long maxPower = 1;\n        long hash = 0;\n        int bestLeft = -1;\n\n        for (int i = s.length() - 1; i >= 0; --i) {\n            hash = (hash * power + val(s.charAt(i))) % modulo;\n            if (i + k < s.length())\n                hash = (hash - val(s.charAt(i + k)) * maxPower % modulo + modulo) % modulo;\n            else\n                maxPower = maxPower * power % modulo;\n            if (hash == hashValue)\n                bestLeft = i;\n        }\n\n        return s.substring(bestLeft, bestLeft + k);\n    }\n\n    private int val(char c) {\n        return c - 'a' + 1;\n    }\n}"
      }
    },
    "2157": {
      "solution": {
        "union-find": ""
      }
    },
    "2158": {
      "solution": {
        "ordered-set": ""
      }
    },
    "2159": {
      "solution": {
        "database": ""
      }
    },
    "2160": {
      "solution": {
        "greedy": ""
      }
    },
    "2161": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2162": {
      "solution": {
        "enumeration": ""
      }
    },
    "2163": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2164": {
      "solution": {
        "sorting": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> sortEvenOdd(vector<int>& nums) {\n        vector<int> even, odd;\n\n        for (int i = 0; i < nums.size(); i++) {\n            if (i % 2 == 0) {\n                even.push_back(nums[i]);\n            } else {\n                odd.push_back(nums[i]);\n            }\n        }\n\n        sort(even.begin(), even.end());\n        sort(odd.rbegin(), odd.rend()); // reverse sort\n\n        int evenIndex = 0, oddIndex = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (i % 2 == 0) {\n                nums[i] = even[evenIndex++];\n            } else {\n                nums[i] = odd[oddIndex++];\n            }\n        }\n\n        return nums;\n    }\n};\n"
      }
    },
    "2165": {
      "solution": {
        "sorting": ""
      }
    },
    "2166": {
      "solution": {
        "design": ""
      }
    },
    "2167": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2168": {
      "solution": {
        "rolling-hash": ""
      }
    },
    "2169": {
      "solution": {
        "math": ""
      }
    },
    "2170": {
      "solution": {
        "counting": ""
      }
    },
    "2171": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2172": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2173": {
      "solution": {
        "database": ""
      }
    },
    "2174": {
      "solution": {
        "matrix": "class Solution {\n    public int removeOnes(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int state = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    state |= 1 << (i * n + j);\n                }\n            }\n        }\n        Deque<Integer> q = new ArrayDeque<>();\n        q.offer(state);\n        Set<Integer> vis = new HashSet<>();\n        vis.add(state);\n        int ans = 0;\n        while (!q.isEmpty()) {\n            for (int k = q.size(); k > 0; --k) {\n                state = q.poll();\n                if (state == 0) {\n                    return ans;\n                }\n                for (int i = 0; i < m; ++i) {\n                    for (int j = 0; j < n; ++j) {\n                        if (grid[i][j] == 0) {\n                            continue;\n                        }\n                        int nxt = state;\n                        for (int r = 0; r < m; ++r) {\n                            nxt &= ~(1 << (r * n + j));\n                        }\n                        for (int c = 0; c < n; ++c) {\n                            nxt &= ~(1 << (i * n + c));\n                        }\n                        if (!vis.contains(nxt)) {\n                            vis.add(nxt);\n                            q.offer(nxt);\n                        }\n                    }\n                }\n            }\n            ++ans;\n        }\n        return -1;\n    }\n}"
      }
    },
    "2175": {
      "solution": {
        "database": ""
      }
    },
    "2176": {
      "solution": {
        "array": ""
      }
    },
    "2177": {
      "solution": {
        "math": ""
      }
    },
    "2178": {
      "solution": {
        "backtracking": ""
      }
    },
    "2179": {
      "solution": {
        "merge-sort": "class FenwickTree {\n  public FenwickTree(int n) {\n    sums = new int[n + 1];\n  }\n\n  public void add(int i, int delta) {\n    while (i < sums.length) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  public int get(int i) {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n\n  private int[] sums;\n\n  private static int lowbit(int i) {\n    return i & -i;\n  }\n}\n\nclass Solution {\n  public long goodTriplets(int[] nums1, int[] nums2) {\n  int n = nums1.length;\n    long ans = 0;\n    Map<Integer, Integer> numToIndex = new HashMap<>();\n    int[] nums = new int[n];\n    int[] leftSmaller = new int[n];\n    int[] rightLarger = new int[n];\n    FenwickTree tree1 = new FenwickTree(n);\n    FenwickTree tree2 = new FenwickTree(n);\n\n    for (int i = 0; i < n; ++i)\n      numToIndex.put(nums1[i], i);\n    for (int i = 0; i < n; ++i)\n      nums[i] = numToIndex.get(nums2[i]);\n\n    for (int i = 0; i < n; ++i) {\n      leftSmaller[i] = tree1.get(nums[i]);\n      tree1.add(nums[i] + 1, 1);\n    }\n\n    for (int i = n - 1; i >= 0; --i) {\n      rightLarger[i] = tree2.get(n) - tree2.get(nums[i]);\n      tree2.add(nums[i] + 1, 1);\n    }\n\n    for (int i = 0; i < n; ++i)\n      ans += (long) leftSmaller[i] * rightLarger[i];\n\n    return ans;\n  }\n}"
      }
    },
    "2180": {
      "solution": {
        "math": ""
      }
    },
    "2181": {
      "solution": {
        "linked-list": ""
      }
    },
    "2182": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2183": {
      "solution": {
        "number-theory": ""
      }
    },
    "2184": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2185": {
      "solution": {
        "string-matching": ""
      }
    },
    "2186": {
      "solution": {
        "counting": ""
      }
    },
    "2187": {
      "solution": {
        "array": "",
        "binary-search": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canCompleteTrips(const vector<int>& buses, long long time, int trips) {\n        long long completedTrips = 0;\n        for (int bus : buses) {\n            completedTrips += time / bus;\n            if (completedTrips >= trips) {\n                return true;\n            }\n        }\n        return completedTrips >= trips;\n    }\n    \n    long long minimumTime(vector<int>& buses, int trips) {\n        long long left = 1, right = (long long) *min_element(buses.begin(), buses.end()) * trips;\n        \n        while (left < right) {\n            long long mid = left + (right - left) / 2;\n            \n            if (canCompleteTrips(buses, mid, trips)) {\n                right = mid; \n            } else {\n                left = mid + 1; \n            }\n        }\n        \n        return left; \n    }\n};\n"
      }
    },
    "2188": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2189": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2190": {
      "solution": {
        "counting": ""
      }
    },
    "2191": {
      "solution": {
        "sorting": ""
      }
    },
    "2192": {
      "solution": {
        "topological-sort": ""
      }
    },
    "2193": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2194": {
      "solution": {
        "string": ""
      }
    },
    "2195": {
      "solution": {
        "greedy": ""
      }
    },
    "2196": {
      "solution": {
        "tree": ""
      }
    },
    "2197": {
      "solution": {
        "stack": ""
      }
    },
    "2198": {
      "solution": {
        "math": ""
      }
    },
    "2199": {
      "solution": {
        "database": ""
      }
    },
    "2200": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2201": {
      "solution": {
        "hash-table": ""
      }
    },
    "2202": {
      "solution": {
        "greedy": ""
      }
    },
    "2203": {
      "solution": {
        "shortest-path": "class Solution {\npublic:\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1,\n                            int src2, int dest) {\n        vector<vector<pair<int, int>>> graph(n);\n        vector<vector<pair<int, int>>> reversedGraph(n);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            const int w = edge[2];\n            graph[u].emplace_back(v, w);\n            reversedGraph[v].emplace_back(u, w);\n        }\n\n        const vector<long> fromSrc1 = dijkstra(graph, src1);\n        const vector<long> fromSrc2 = dijkstra(graph, src2);\n        const vector<long> fromDest = dijkstra(reversedGraph, dest);\n        long ans = kMax;\n\n        for (int i = 0; i < n; ++i) {\n            if (fromSrc1[i] == kMax || fromSrc2[i] == kMax ||\n                fromDest[i] == kMax)\n                continue;\n            ans = min(ans, fromSrc1[i] + fromSrc2[i] + fromDest[i]);\n        }\n\n        return ans == kMax ? -1 : ans;\n    }\n\nprivate:\n    static constexpr long kMax = 10'000'000'000;\n\n    vector<long> dijkstra(const vector<vector<pair<int, int>>>& graph,\n                          int src) {\n        vector<long> dist(graph.size(), kMax);\n\n        dist[src] = 0;\n        using P = pair<long, int>; // (d, u)\n        priority_queue<P, vector<P>, greater<>> minHeap;\n        minHeap.emplace(dist[src], src);\n\n        while (!minHeap.empty()) {\n            const auto [d, u] = minHeap.top();\n            minHeap.pop();\n            if (d > dist[u])\n                continue;\n            for (const auto& [v, w] : graph[u])\n                if (d + w < dist[v]) {\n                    dist[v] = d + w;\n                    minHeap.emplace(dist[v], v);\n                }\n        }\n\n        return dist;\n    }\n};"
      }
    },
    "2204": {
      "solution": {
        "union-find": ""
      }
    },
    "2205": {
      "solution": {
        "database": ""
      }
    },
    "2206": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2207": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2208": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2209": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2210": {
      "solution": {
        "array": ""
      }
    },
    "2211": {
      "solution": {
        "stack": ""
      }
    },
    "2212": {
      "solution": {
        "backtracking": ""
      }
    },
    "2213": {
      "solution": {
        "ordered-set": ""
      }
    },
    "2214": {
      "solution": {
        "greedy": ""
      }
    },
    "2215": {
      "solution": {
        "hash-table": ""
      }
    },
    "2216": {
      "solution": {
        "stack": ""
      }
    },
    "2217": {
      "solution": {
        "math": ""
      }
    },
    "2218": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2219": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2220": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2221": {
      "solution": {
        "combinatorics": ""
      }
    },
    "2222": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2223": {
      "solution": {
        "suffix-array": "class Solution {\n    public long sumScores(String s) {\n      int n = s.length();\n        // https://cp-algorithms.com/string/z-function.html#implementation\n        int[] z = new int[n];\n        // [left, right] := the indices of the rightmost segment match\n        int left = 0;\n        int right = 0;\n\n        for (int i = 1; i < n; ++i) {\n            if (i < right)\n                z[i] = Math.min(right - i, z[i - left]);\n            while (i + z[i] < n && s.charAt(z[i]) == s.charAt(i + z[i]))\n                ++z[i];\n            if (i + z[i] > right) {\n                left = i;\n                right = i + z[i];\n            }\n        }\n\n        return Arrays.stream(z).asLongStream().sum() + n;\n    }\n}"
      }
    },
    "2224": {
      "solution": {
        "greedy": ""
      }
    },
    "2225": {
      "solution": {
        "counting": ""
      }
    },
    "2226": {
      "solution": {
        "array": ""
      }
    },
    "2227": {
      "solution": {
        "trie": ""
      }
    },
    "2228": {
      "solution": {
        "database": ""
      }
    },
    "2229": {
      "solution": {
        "sorting": ""
      }
    },
    "2230": {
      "solution": {
        "database": ""
      }
    },
    "2231": {
      "solution": {
        "heap-(priority-queue)": "class Solution {\n    public int largestInteger(int num) {\n        String s = String.valueOf(num);\n        int ans = 0;\n        // maxHeap[0] := the odd digits\n        // maxHeap[1] := the even digits\n        Queue<Integer>[] maxHeap = new Queue[2];\n\n        for (int i = 0; i < 2; ++i)\n            maxHeap[i] = new PriorityQueue<>(Comparator.reverseOrder());\n\n        for (char c : s.toCharArray()) {\n            int digit = c - '0';\n            maxHeap[digit & 1].offer(digit);\n        }\n\n        for (char c : s.toCharArray()) {\n            int i = c - '0' & 1;\n            ans = (ans * 10 + maxHeap[i].poll());\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "2232": {
      "solution": {
        "enumeration": ""
      }
    },
    "2233": {
      "solution": {
        "heap-(priority-queue)": "class Solution {\n    public int maximumProduct(int[] nums, int k) {\n        int kMod = 1_000_000_007;\n        long ans = 1;\n        Queue<Integer> minHeap = new PriorityQueue<>();\n\n        for (int num : nums)\n            minHeap.offer(num);\n\n        for (int i = 0; i < k; ++i) {\n            int minNum = minHeap.poll();\n            minHeap.offer(minNum + 1);\n        }\n\n        while (!minHeap.isEmpty()) {\n            ans *= minHeap.poll();\n            ans %= kMod;\n        }\n\n        return (int) ans;\n    }\n}"
      }
    },
    "2234": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2235": {
      "solution": {
        "math": ""
      }
    },
    "2236": {
      "solution": {
        "tree": ""
      }
    },
    "2237": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2238": {
      "solution": {
        "database": ""
      }
    },
    "2239": {
      "solution": {
        "array": ""
      }
    },
    "2240": {
      "solution": {
        "enumeration": ""
      }
    },
    "2241": {
      "solution": {
        "design": ""
      }
    },
    "2242": {
      "solution": {
        "enumeration": ""
      }
    },
    "2243": {
      "solution": {
        "string": ""
      }
    },
    "2244": {
      "solution": {
        "counting": ""
      }
    },
    "2245": {
      "solution": {
        "matrix": ""
      }
    },
    "2246": {
      "solution": {
        "topological-sort": ""
      }
    },
    "2247": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2248": {
      "solution": {
        "counting": "class Solution {\npublic:\n    vector<int> intersection(vector<vector<int>>& nums) {\n        unordered_map<int, int> freq;\n        int n = nums.size();\n\n        // Count the frequency of each element across all arrays\n        for (const auto& arr : nums) {\n            unordered_set<int>\n                seen; // To avoid counting duplicates within the same array\n            for (int num : arr) {\n                if (seen.find(num) == seen.end()) {\n                    freq[num]++;\n                    seen.insert(num);\n                }\n            }\n        }\n\n        // Collect the elements that appear in every array\n        vector<int> result;\n        for (const auto& [num, count] : freq) {\n            if (count == n) {\n                result.push_back(num);\n            }\n        }\n\n        // Sort the result\n        sort(result.begin(), result.end());\n\n        return result;\n    }\n};\n"
      }
    },
    "2249": {
      "solution": {
        "geometry": ""
      }
    },
    "2250": {
      "solution": {
        "sorting": ""
      }
    },
    "2251": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2252": {
      "solution": {
        "database": ""
      }
    },
    "2253": {
      "solution": {
        "database": ""
      }
    },
    "2254": {
      "solution": {
        "stack": ""
      }
    },
    "2255": {
      "solution": {
        "string": ""
      }
    },
    "2256": {
      "solution": {
        "prefix-sum": "class Solution {\n    public int minimumAverageDifference(int[] nums) {\n        int n = nums.length;\n        long totalSum = 0;\n        \n        for (int num : nums) {\n            totalSum += num;\n        }\n        \n        long leftSum = 0;  // Sum of elements to the left of the current index\n        long minDiff = Long.MAX_VALUE;\n        int resultIndex = -1;\n\n        for (int i = 0; i < n; i++) {\n            // Update leftSum (sum of elements from 0 to i)\n            leftSum += nums[i];\n            \n            // Calculate rightSum (totalSum - leftSum)\n            long rightSum = totalSum - leftSum;\n            \n            // Calculate the average difference\n            long leftAvg = leftSum / (i + 1);\n            long rightAvg = (i == n - 1) ? 0 : rightSum / (n - i - 1);  // Avoid division by zero for the last element\n            \n            // Calculate the absolute difference in averages\n            long diff = Math.abs(leftAvg - rightAvg);\n            \n            // Update resultIndex if a new minimum difference is found\n            if (diff < minDiff) {\n                minDiff = diff;\n                resultIndex = i;\n            }\n        }\n        \n        return resultIndex;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.minimumAverageDifference(new int[]{2, 4, 1, 3, 2})); // Output: 2\n        System.out.println(solution.minimumAverageDifference(new int[]{0, 0, 0, 0})); // Output: 0\n    }\n}\n"
      }
    },
    "2257": {
      "solution": {
        "matrix": ""
      }
    },
    "2258": {
      "solution": {
        "matrix": ""
      }
    },
    "2259": {
      "solution": {
        "enumeration": ""
      }
    },
    "2260": {
      "solution": {
        "sliding-window": "class Solution {\n  public int minimumCardPickup(int[] cards) {\n    int ans = Integer.MAX_VALUE;\n    Map<Integer, Integer> seen = new HashMap<>();\n\n    for (int i = 0; i < cards.length; ++i) {\n      if (seen.containsKey(cards[i]))\n        ans = Math.min(ans, i - seen.get(cards[i]) + 1);\n      seen.put(cards[i], i);\n    }\n\n    return ans == Integer.MAX_VALUE ? -1 : ans;\n  }\n}"
      }
    },
    "2261": {
      "solution": {
        "trie": "class Solution {\npublic:\n    int countDistinct(vector<int>& nums, int k, int p) {\n        struct TrieNode {\n            unordered_map<int, TrieNode*> children;\n        };\n\n        TrieNode* root = new TrieNode();\n        int distinctCount = 0;\n\n        for (int i = 0; i < nums.size(); ++i) {\n            TrieNode* node = root;\n            int divisibleCount = 0;\n\n            for (int j = i; j < nums.size(); ++j) {\n                if (nums[j] % p == 0)\n                    ++divisibleCount;\n\n                // Stop adding subarrays if divisible count exceeds k\n                if (divisibleCount > k)\n                    break;\n\n                // If the current number is not in the trie, add it\n                if (!node->children.count(nums[j])) {\n                    node->children[nums[j]] = new TrieNode();\n                    ++distinctCount; // Each new node represents a new subarray\n                }\n\n                node = node->children[nums[j]];\n            }\n        }\n\n        return distinctCount;\n    }\n};\n"
      }
    },
    "2262": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2263": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2264": {
      "solution": {
        "string": ""
      }
    },
    "2265": {
      "solution": {
        "tree": ""
      }
    },
    "2266": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2267": {
      "solution": {
        "matrix": ""
      }
    },
    "2268": {
      "solution": {
        "counting": ""
      }
    },
    "2269": {
      "solution": {
        "sliding-window": "class Solution {\n  public int divisorSubstrings(int num, int k) {\n  String s = String.valueOf(num);\n    int ans = 0;\n\n    for (int i = 0; i + k <= s.length(); ++i) {\n    int x = Integer.parseInt(s.substring(i, i + k));\n      if (x != 0 && num % x == 0)\n        ++ans;\n    }\n\n    return ans;\n  }\n}"
      }
    },
    "2270": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2271": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2272": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2273": {
      "solution": {
        "sorting": ""
      }
    },
    "2274": {
      "solution": {
        "sorting": ""
      }
    },
    "2275": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2276": {
      "solution": {
        "ordered-set": ""
      }
    },
    "2277": {
      "solution": {
        "tree": ""
      }
    },
    "2278": {
      "solution": {
        "string": ""
      }
    },
    "2279": {
      "solution": {
        "greedy": ""
      }
    },
    "2280": {
      "solution": {
        "geometry": ""
      }
    },
    "2281": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "2282": {
      "solution": {
        "matrix": ""
      }
    },
    "2283": {
      "solution": {
        "counting": ""
      }
    },
    "2284": {
      "solution": {
        "counting": ""
      }
    },
    "2285": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2286": {
      "solution": {
        "design": ""
      }
    },
    "2287": {
      "solution": {
        "counting": ""
      }
    },
    "2288": {
      "solution": {
        "string": ""
      }
    },
    "2289": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "2290": {
      "solution": {
        "shortest-path": "class Solution {\n public:\n  int minimumObstacles(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    using T = tuple<int, int, int>;  // (d, i, j)\n    priority_queue<T, vector<T>, greater<>> minHeap;\n    vector<vector<int>> dist(m, vector<int>(n, INT_MAX));\n\n    minHeap.emplace(grid[0][0], 0, 0);\n    dist[0][0] = grid[0][0];\n\n    while (!minHeap.empty()) {\n      const auto [d, i, j] = minHeap.top();\n      minHeap.pop();\n      if (i == m - 1 && j == n - 1)\n        return d;\n      for (const auto& [dx, dy] : dirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        const int newDist = d + grid[i][j];\n        if (newDist < dist[x][y]) {\n          dist[x][y] = newDist;\n          minHeap.emplace(newDist, x, y);\n        }\n      }\n    }\n\n    return dist[m - 1][n - 1];\n  }\n};"
      }
    },
    "2291": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2292": {
      "solution": {
        "database": ""
      }
    },
    "2293": {
      "solution": {
        "array": ""
      }
    },
    "2294": {
      "solution": {
        "greedy": ""
      }
    },
    "2295": {
      "solution": {
        "hash-table": ""
      }
    },
    "2296": {
      "solution": {
        "doubly-linked-list": "class TextEditor {\n    private class Node {\n        char c;\n        Node prev, next;\n\n        Node(char c) {\n            this.c = c;\n        }\n    }\n\n    private Node head, tail, cursor;\n\n    public TextEditor() {\n        head = new Node('0');\n        tail = new Node('0');\n        head.next = tail;\n        tail.prev = head;\n        cursor = tail;\n    }\n\n    public void addText(String text) {\n        for (char c : text.toCharArray()) {\n            Node newNode = new Node(c);\n            Node prev = cursor.prev;\n            prev.next = newNode;\n            newNode.prev = prev;\n            newNode.next = cursor;\n            cursor.prev = newNode;\n        }\n    }\n\n    public int deleteText(int k) {\n        int deleted = 0;\n        while (k > 0 && cursor.prev != head) {\n            Node prev = cursor.prev;\n            prev.prev.next = cursor;\n            cursor.prev = prev.prev;\n            k--;\n            deleted++;\n        }\n        return deleted;\n    }\n\n    public String cursorLeft(int k) {\n        while (k > 0 && cursor.prev != head) {\n            cursor = cursor.prev;\n            k--;\n        }\n        return getText();\n    }\n\n    public String cursorRight(int k) {\n        while (k > 0 && cursor != tail) {\n            cursor = cursor.next;\n            k--;\n        }\n        return getText();\n    }\n\n    private String getText() {\n        StringBuilder sb = new StringBuilder();\n        Node temp = cursor.prev;\n        for (int i = 0; i < 10 && temp != head; i++) {\n            sb.append(temp.c);\n            temp = temp.prev;\n        }\n        return sb.reverse().toString();\n    }\n}\n"
      }
    },
    "2297": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "2298": {
      "solution": {
        "database": ""
      }
    },
    "2299": {
      "solution": {
        "string": ""
      }
    },
    "2300": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2301": {
      "solution": {
        "string-matching": ""
      }
    },
    "2302": {
      "solution": {
        "sliding-window": "class Solution {\n    public long countSubarrays(int[] nums, long k) {\n        long ans = 0;\n        long sum = 0;\n\n        for (int left = 0, right = 0; right < nums.length; ++right) {\n            sum += nums[right];\n            while (sum * (right - left + 1) >= k)\n                sum -= nums[left++];\n            ans += right - left + 1;\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "2303": {
      "solution": {
        "array": ""
      }
    },
    "2304": {
      "solution": {
        "matrix": ""
      }
    },
    "2305": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2306": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2307": {
      "solution": {
        "union-find": ""
      }
    },
    "2308": {
      "solution": {
        "database": ""
      }
    },
    "2309": {
      "solution": {
        "enumeration": ""
      }
    },
    "2310": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2311": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2312": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2313": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2314": {
      "solution": {
        "database": ""
      }
    },
    "2315": {
      "solution": {
        "string": ""
      }
    },
    "2316": {
      "solution": {
        "union-find": ""
      }
    },
    "2317": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2318": {
      "solution": {
        "memoization": "class Solution {\npublic:\n    int distinctSequences(int n) {\n        vector<vector<vector<int>>> mem(n + 1,\n                                        vector<vector<int>>(7, vector<int>(7)));\n        return distinctSequences(n, 0, 0, mem);\n    }\n\nprivate:\n    static constexpr int kMod = 1'000'000'007;\n\n    // Returns the number of distinct sequences for n dices with `prev` and\n    // `prevPrev`.\n    int distinctSequences(int n, int prev, int prevPrev,\n                          vector<vector<vector<int>>>& mem) {\n        if (n == 0)\n            return 1;\n        if (mem[n][prev][prevPrev] > 0)\n            return mem[n][prev][prevPrev];\n\n        for (int dice = 1; dice <= 6; ++dice)\n            if (dice != prev && dice != prevPrev &&\n                (prev == 0 || gcd(dice, prev) == 1)) {\n                mem[n][prev][prevPrev] +=\n                    distinctSequences(n - 1, dice, prev, mem);\n                mem[n][prev][prevPrev] %= kMod;\n            }\n\n        return mem[n][prev][prevPrev];\n    }\n};"
      }
    },
    "2319": {
      "solution": {
        "matrix": ""
      }
    },
    "2320": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2321": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2322": {
      "solution": {
        "tree": ""
      }
    },
    "2323": {
      "solution": {
        "greedy": ""
      }
    },
    "2324": {
      "solution": {
        "database": ""
      }
    },
    "2325": {
      "solution": {
        "hash-table": ""
      }
    },
    "2326": {
      "solution": {
        "matrix": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\npublic class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\n        int[][] result = new int[m][n];\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                result[i][j] = -1;\n            }\n        }\n        \n        int r = 0, c = 0, dirIndex = 0;\n        \n        ListNode current = head;\n        while (current != null) {\n            result[r][c] = current.val;\n            current = current.next;\n            \n            int newR = r + DIRECTIONS[dirIndex][0];\n            int newC = c + DIRECTIONS[dirIndex][1];\n            \n            if (newR < 0 || newR >= m || newC < 0 || newC >= n || result[newR][newC] != -1) {\n                dirIndex = (dirIndex + 1) % 4;\n                newR = r + DIRECTIONS[dirIndex][0];\n                newC = c + DIRECTIONS[dirIndex][1];\n            }\n            \n            r = newR;\n            c = newC;\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        ListNode head = new ListNode(3);\n        head.next = new ListNode(0);\n        head.next.next = new ListNode(2);\n        head.next.next.next = new ListNode(6);\n        head.next.next.next.next = new ListNode(8);\n        head.next.next.next.next.next = new ListNode(1);\n        head.next.next.next.next.next.next = new ListNode(7);\n        head.next.next.next.next.next.next.next = new ListNode(9);\n        head.next.next.next.next.next.next.next.next = new ListNode(4);\n        head.next.next.next.next.next.next.next.next.next = new ListNode(2);\n        head.next.next.next.next.next.next.next.next.next.next = new ListNode(5);\n        Solution spiralMatrix = new Solution();\n        int[][] result = spiralMatrix.spiralMatrix(3, 5, head);\n        for (int[] row : result) {\n            for (int val : row) {\n                System.out.print(val + \" \");\n            }\n            System.out.println();\n        }\n    }\n}"
      }
    },
    "2327": {
      "solution": {
        "queue": ""
      }
    },
    "2328": {
      "solution": {
        "matrix": ""
      }
    },
    "2329": {
      "solution": {
        "database": ""
      }
    },
    "2330": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2331": {
      "solution": {
        "tree": ""
      }
    },
    "2332": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2333": {
      "solution": {
        "heap-(priority-queue)": "class Solution {\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\n        int[] diff = getDiff(nums1, nums2);\n        int k = k1 + k2;\n        if (Arrays.stream(diff).asLongStream().sum() <= k)\n            return 0;\n\n        Map<Integer, Integer> count = new HashMap<>();\n        // (num, freq)\n        Queue<Pair<Integer, Integer>> maxHeap = new PriorityQueue<>((a, b) -> b.getKey() - a.getKey());\n\n        for (int d : diff)\n            if (d != 0)\n                count.merge(d, 1, Integer::sum);\n\n        for (Map.Entry<Integer, Integer> entry : count.entrySet())\n            maxHeap.offer(new Pair<>(entry.getKey(), entry.getValue()));\n\n        while (k > 0) {\n            Pair<Integer, Integer> pair = maxHeap.poll();\n            int maxNum = pair.getKey();\n            int maxNumFreq = pair.getValue();\n            // Buck decrease in this turn\n            int numDecreased = Math.min(k, maxNumFreq);\n            k -= numDecreased;\n            if (maxNumFreq > numDecreased)\n                maxHeap.offer(new Pair<>(maxNum, maxNumFreq - numDecreased));\n            if (!maxHeap.isEmpty() && maxHeap.peek().getKey() + 1 == maxNum) {\n                Pair<Integer, Integer> secondNode = maxHeap.poll();\n                int secondMaxNum = secondNode.getKey();\n                int secondMaxNumFreq = secondNode.getValue();\n                maxHeap.offer(new Pair<>(secondMaxNum, secondMaxNumFreq + numDecreased));\n            } else if (maxNum > 1) {\n                maxHeap.offer(new Pair<>(maxNum - 1, numDecreased));\n            }\n        }\n\n        long ans = 0;\n        while (!maxHeap.isEmpty()) {\n            Pair<Integer, Integer> pair = maxHeap.poll();\n            int num = pair.getKey();\n            int freq = pair.getValue();\n            ans += (long) num * num * freq;\n        }\n\n        return ans;\n    }\n\n    private int[] getDiff(int[] nums1, int[] nums2) {\n        int[] diff = new int[nums1.length];\n        for (int i = 0; i < nums1.length; ++i)\n            diff[i] = Math.abs(nums1[i] - nums2[i]);\n        return diff;\n    }\n}"
      }
    },
    "2334": {
      "solution": {
        "union-find": ""
      }
    },
    "2335": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2336": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2337": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2338": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2339": {
      "solution": {
        "database": ""
      }
    },
    "2340": {
      "solution": {
        "greedy": ""
      }
    },
    "2341": {
      "solution": {
        "counting": ""
      }
    },
    "2342": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2343": {
      "solution": {
        "radix-sort": "import java.math.BigInteger;\nimport java.util.*;\n\nclass Solution {\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\n        int[] ans = new int[queries.length];\n        for (int i = 0; i < queries.length; i++) {\n            ans[i] = getKSmallestIndex(nums, queries[i][0], queries[i][1]);\n        }\n        return ans;\n    }\n\n    private int getKSmallestIndex(String[] nums, int k, int trim) {\n        int startIndex = nums[0].length() - trim;\n        List<Pair<String, Integer>> trimmed = new ArrayList<>();  \n\n        for (int i = 0; i < nums.length; ++i) {\n            String numStr = nums[i].substring(startIndex);\n            trimmed.add(new Pair<>(numStr, i));\n        }\n\n        int n = trimmed.size();\n        String[] numArray = new String[n];\n        int[] indexArray = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            numArray[i] = trimmed.get(i).getKey();\n            indexArray[i] = trimmed.get(i).getValue();\n        }\n\n        radixSort(numArray, indexArray);\n\n        return indexArray[k - 1];\n    }\n\n    public static void radixSort(String[] arr, int[] indexArr) {\n        int maxLen = Arrays.stream(arr).mapToInt(String::length).max().orElse(0);\n        for (int exp = maxLen - 1; exp >= 0; exp--) {\n            countingSort(arr, indexArr, exp);\n        }\n    }\n\n    private static void countingSort(String[] arr, int[] indexArr, int exp) {\n        int n = arr.length;\n        String[] output = new String[n];\n        int[] outputIndex = new int[n];\n        int[] count = new int[256];  // ASCII characters count\n\n        for (int i = 0; i < n; i++) {\n            char index = exp < arr[i].length() ? arr[i].charAt(exp) : 0;\n            count[index]++;\n        }\n\n        for (int i = 1; i < 256; i++) {\n            count[i] += count[i - 1];\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            char index = exp < arr[i].length() ? arr[i].charAt(exp) : 0;\n            output[count[index] - 1] = arr[i];\n            outputIndex[count[index] - 1] = indexArr[i];\n            count[index]--;\n        }\n\n        System.arraycopy(output, 0, arr, 0, n);\n        System.arraycopy(outputIndex, 0, indexArr, 0, n);\n    }\n\n    static class Pair<K, V> {\n        private final K key;\n        private final V value;\n\n        public Pair(K key, V value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        public K getKey() {\n            return key;\n        }\n\n        public V getValue() {\n            return value;\n        }\n    }\n\n}\n",
        "quickselect": "import java.util.*;\n\npublic class Solution {\n\n    class Pair implements Comparable<Pair> {\n        String trimmedNumber;\n        int originalIndex;\n\n        public Pair(String trimmedNumber, int originalIndex) {\n            this.trimmedNumber = trimmedNumber;\n            this.originalIndex = originalIndex;\n        }\n\n        @Override\n        public int compareTo(Pair other) {\n            if (this.trimmedNumber.equals(other.trimmedNumber)) {\n                return Integer.compare(this.originalIndex, other.originalIndex);\n            }\n            return this.trimmedNumber.compareTo(other.trimmedNumber);\n        }\n    }\n\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\n        int[] result = new int[queries.length];\n        int resultIndex = 0;\n        Map<Integer, String[]> trimmedMap = new HashMap<>();\n\n        for (int[] query : queries) {\n            int trimLength = query[1];\n            \n            if (!trimmedMap.containsKey(trimLength)) {\n                trimmedMap.put(trimLength, trimStrings(nums, trimLength));\n            }\n            String[] trimmedArray = trimmedMap.get(trimLength);\n            \n            Pair[] pairs = new Pair[trimmedArray.length];\n            for (int i = 0; i < trimmedArray.length; i++) {\n                pairs[i] = new Pair(trimmedArray[i], i);\n            }\n            \n            Pair kthSmallest = findKthSmallest(pairs, query[0]);\n            result[resultIndex++] = kthSmallest.originalIndex;\n        }\n\n        return result;\n    }\n\n    private String[] trimStrings(String[] nums, int trimLength) {\n        int fullLength = nums[0].length();\n        if (trimLength == fullLength) {\n            return nums; // No trimming needed\n        }\n\n        String[] trimmed = new String[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            trimmed[i] = nums[i].substring(fullLength - trimLength);\n        }\n        return trimmed;\n    }\n\n    private Pair findKthSmallest(Pair[] pairs, int k) {\n        k--; // Convert k to zero-based index\n        int left = 0;\n        int right = pairs.length - 1;\n\n        while (left <= right) {\n            int pivotIndex = partition(pairs, left, right);\n            if (pivotIndex == k) {\n                return pairs[k];\n            } else if (pivotIndex < k) {\n                left = pivotIndex + 1;\n            } else {\n                right = pivotIndex - 1;\n            }\n        }\n\n        return pairs[k];\n    }\n\n    private int partition(Pair[] pairs, int left, int right) {\n        // Select middle element as pivot\n        int mid = left + (right - left) / 2;\n        Pair pivot = pairs[mid];\n        \n        swap(pairs, mid, right);\n\n        int i = left;\n        for (int j = left; j < right; j++) {\n            if (pairs[j].compareTo(pivot) <= 0) {\n                swap(pairs, i, j);\n                i++;\n            }\n        }\n        \n        swap(pairs, i, right);\n        return i;\n    }\n\n    private void swap(Pair[] pairs, int i, int j) {\n        Pair temp = pairs[i];\n        pairs[i] = pairs[j];\n        pairs[j] = temp;\n    }\n}\n"
      }
    },
    "2344": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2345": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "2346": {
      "solution": {
        "database": ""
      }
    },
    "2347": {
      "solution": {
        "counting": ""
      }
    },
    "2348": {
      "solution": {
        "math": ""
      }
    },
    "2349": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2350": {
      "solution": {
        "greedy": ""
      }
    },
    "2351": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2352": {
      "solution": {
        "matrix": "class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    private int n;\n\n    public int equalPairs(int[][] grid) {\n        n = grid.length;\n        int count = 0;\n\n        for (int row = 0; row < n; row++) {\n            for (int col = 0; col < n; col++) {\n                if (checkEquality(grid, row, col)) {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n\n    private boolean checkEquality(int[][] grid, int row, int col) {\n        for (int i = 0; i < n; i++) {\n            if (grid[row][i] != grid[i][col]) {\n                return false; \n            }\n        }\n        return true;\n    }\n}\n"
      }
    },
    "2353": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2354": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2355": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "2356": {
      "solution": {
        "database": ""
      }
    },
    "2357": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2358": {
      "solution": {
        "greedy": ""
      }
    },
    "2359": {
      "solution": {
        "graph": ""
      }
    },
    "2360": {
      "solution": {
        "topological-sort": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int longestCycle(vector<int>& edges) {\n        int n = edges.size();\n        vector<int> inDegree(n, 0);\n\n        for (int i = 0; i < n; i++) {\n            if (edges[i] != -1) {\n                inDegree[edges[i]]++;\n            }\n        }\n\n        queue<int> q;\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n\n            int neighbor = edges[node];\n            if (neighbor != -1) {\n                inDegree[neighbor]--;\n                if (inDegree[neighbor] == 0) {\n                    q.push(neighbor);\n                }\n            }\n        }\n\n        int longestCycle = -1;\n        vector<bool> visited(n, false);\n\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] > 0 && !visited[i]) {\n                int current = i, length = 0;\n                while (!visited[current]) {\n                    visited[current] = true;\n                    current = edges[current];\n                    length++;\n                }\n                longestCycle = max(longestCycle, length);\n            }\n        }\n\n        return longestCycle;\n    }\n};\n"
      }
    },
    "2361": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2362": {
      "solution": {
        "database": ""
      }
    },
    "2363": {
      "solution": {
        "ordered-set": ""
      }
    },
    "2364": {
      "solution": {
        "hash-table": ""
      }
    },
    "2365": {
      "solution": {
        "hash-table": ""
      }
    },
    "2366": {
      "solution": {
        "greedy": ""
      }
    },
    "2367": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2368": {
      "solution": {
        "union-find": ""
      }
    },
    "2369": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2370": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2371": {
      "solution": {
        "matrix": "class Solution {\n    public int[][] minScore(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        List<int[]> nums = new ArrayList<>();\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                nums.add(new int[] {grid[i][j], i, j});\n            }\n        }\n        Collections.sort(nums, (a, b) -> a[0] - b[0]);\n        int[] rowMax = new int[m];\n        int[] colMax = new int[n];\n        int[][] ans = new int[m][n];\n        for (int[] num : nums) {\n            int i = num[1], j = num[2];\n            ans[i][j] = Math.max(rowMax[i], colMax[j]) + 1;\n            rowMax[i] = ans[i][j];\n            colMax[j] = ans[i][j];\n        }\n        return ans;\n    }\n}"
      }
    },
    "2372": {
      "solution": {
        "database": ""
      }
    },
    "2373": {
      "solution": {
        "matrix": ""
      }
    },
    "2374": {
      "solution": {
        "graph": ""
      }
    },
    "2375": {
      "solution": {
        "stack": ""
      }
    },
    "2376": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2377": {
      "solution": {
        "database": ""
      }
    },
    "2378": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2379": {
      "solution": {
        "sliding-window": "class Solution {\n    public int minimumRecolors(String blocks, int k) {\n        int countB = 0;\n        int maxCountB = 0;\n\n        for (int i = 0; i < blocks.length(); ++i) {\n            if (blocks.charAt(i) == 'B')\n                ++countB;\n            if (i >= k && blocks.charAt(i - k) == 'B')\n                --countB;\n            maxCountB = Math.max(maxCountB, countB);\n        }\n\n        return k - maxCountB;\n    }\n}"
      }
    },
    "2380": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2381": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2382": {
      "solution": {
        "union-find": ""
      }
    },
    "2383": {
      "solution": {
        "greedy": ""
      }
    },
    "2384": {
      "solution": {
        "counting": ""
      }
    },
    "2385": {
      "solution": {
        "tree": ""
      }
    },
    "2386": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2387": {
      "solution": {
        "matrix": ""
      }
    },
    "2388": {
      "solution": {
        "database": ""
      }
    },
    "2389": {
      "solution": {
        "prefix-sum": "",
        "binary-search": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> answerQueries(vector<int>& nums, vector<int>& queries) {\n        sort(nums.begin(), nums.end());\n\n        vector<int> prefixSum(nums.size());\n        prefixSum[0] = nums[0];\n        for (int i = 1; i < nums.size(); ++i) {\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\n        }\n\n        vector<int> result;\n        for (int query : queries) {\n            int idx = upper_bound(prefixSum.begin(), prefixSum.end(), query) - prefixSum.begin();\n            result.push_back(idx); \n        }\n\n        return result;\n    }\n};\n"
      }
    },
    "2390": {
      "solution": {
        "stack": "import java.util.*;\n\nclass Solution {\n    public String removeStars(String s) {\n        Deque<Integer> stack = new ArrayDeque<>();\n        \n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (ch == '*') {\n                if (!stack.isEmpty()) {\n                    stack.pop(); \n                }\n            } else {\n                stack.push(i); \n            }\n        }\n        \n        StringBuilder result = new StringBuilder();\n        while (!stack.isEmpty()) {\n            result.append(s.charAt(stack.pop()));\n        }\n        \n        return result.reverse().toString();\n    }\n}\n"
      }
    },
    "2391": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2392": {
      "solution": {
        "matrix": ""
      }
    },
    "2393": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2394": {
      "solution": {
        "database": ""
      }
    },
    "2395": {
      "solution": {
        "hash-table": ""
      }
    },
    "2396": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2397": {
      "solution": {
        "matrix": ""
      }
    },
    "2398": {
      "solution": {
        "sliding-window": "class Solution {\n    public int maximumRobots(int[] times, int[] costs, long budget) {\n        long sum = 0;\n        int i = 0, n = times.length;\n        Deque<Integer> deque = new LinkedList<Integer>();\n        for (int j = 0; j < n; ++j) {\n            sum += costs[j];\n            while (!deque.isEmpty() && times[deque.peekLast()] <= times[j])\n                deque.pollLast();\n            deque.addLast(j);\n            if (times[deque.getFirst()] + (j - i + 1) * sum > budget) {\n                if (deque.getFirst() == i)\n                    deque.pollFirst();\n                sum -= costs[i++];\n            }\n        }\n        return n - i;\n    }\n}\n"
      }
    },
    "2399": {
      "solution": {
        "hash-table": ""
      }
    },
    "2400": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2401": {
      "solution": {
        "sliding-window": "class Solution {\n  public int longestNiceSubarray(int[] nums) {\n    int ans = 0;\n    int used = 0;\n\n    for (int left = 0, right = 0; right < nums.length; ++right) {\n      while ((used & nums[right]) > 0)\n        used ^= nums[left++];\n      used |= nums[right];\n      ans = Math.max(ans, right - left + 1);\n    }\n\n    return ans;\n  }\n}"
      }
    },
    "2402": {
      "solution": {
        "heap-(priority-queue)": "#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int mostBooked(int n, vector<vector<int>>& meetings) {\n        // Sort meetings by start time\n        sort(meetings.begin(), meetings.end());\n\n        // Priority queue for free rooms (min-heap of room indices)\n        priority_queue<int, vector<int>, greater<int>> freeRooms;\n        for (int i = 0; i < n; ++i) freeRooms.push(i);\n\n        // Priority queue for occupied rooms (min-heap of {endTime, roomIndex})\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<>> occupiedRooms;\n\n        // Array to track usage count for each room\n        vector<int> roomUsage(n, 0);\n\n        // Process each meeting\n        for (const auto& meeting : meetings) {\n            long long start = meeting[0];\n            long long end = meeting[1];\n\n            // Free up rooms that have completed their meetings\n            while (!occupiedRooms.empty() && occupiedRooms.top().first <= start) {\n                freeRooms.push(occupiedRooms.top().second);\n                occupiedRooms.pop();\n            }\n\n            // Assign a room for the current meeting\n            if (!freeRooms.empty()) {\n                // Take the smallest available room\n                int room = freeRooms.top();\n                freeRooms.pop();\n                occupiedRooms.push({end, room});\n                roomUsage[room]++;\n            } else {\n                // Wait for the earliest room to be free\n                auto earliest = occupiedRooms.top();\n                occupiedRooms.pop();\n                long long newEndTime = earliest.first + (end - start);\n                occupiedRooms.push({newEndTime, earliest.second});\n                roomUsage[earliest.second]++;\n            }\n        }\n\n        // Find the room with the highest usage\n        int maxBookedRoom = 0;\n        for (int i = 1; i < n; ++i) {\n            if (roomUsage[i] > roomUsage[maxBookedRoom]) {\n                maxBookedRoom = i;\n            }\n        }\n\n        return maxBookedRoom;\n    }\n};\n"
      }
    },
    "2403": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2404": {
      "solution": {
        "counting": ""
      }
    },
    "2405": {
      "solution": {
        "greedy": ""
      }
    },
    "2406": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2407": {
      "solution": {
        "monotonic-queue": "class Solution {\n    public int lengthOfLIS(int[] nums, int k) {\n        SegmentTree root = new SegmentTree(1, 100000);\n        int res = 0;\n        for (int num : nums) {\n            int preMax = root.rangeMaxQuery(root, num - k, num - 1);\n            root.update(root, num, preMax + 1);\n            res = Math.max(res, preMax + 1);\n        }\n        return res;\n    }\n}\n\nclass SegmentTree {\n    SegmentTree left, right;\n    int start, end, val;\n    public SegmentTree(int start, int end) {\n        this.start = start;\n        this.end = end;\n        setup(this, start, end);\n    }\n    public void setup(SegmentTree node, int start, int end) {\n        if (start == end) return;\n        int mid = start + (end - start) / 2;\n        if (node.left == null) {\n            node.left = new SegmentTree(start, mid);\n            node.right = new SegmentTree(mid + 1, end);\n        }\n        setup(node.left, start, mid);\n        setup(node.right, mid + 1, end);\n        node.val = Math.max(node.left.val, node.right.val);\n    }\n    \n    public void update(SegmentTree node, int index, int val) {\n        if (index < node.start || index > node.end) return;\n        if (node.start == node.end && node.start == index) {\n            node.val = val;\n            return;\n        }\n        update(node.left, index, val);\n        update(node.right, index, val);\n        node.val = Math.max(node.left.val, node.right.val);\n    }\n    \n    public int rangeMaxQuery(SegmentTree node, int start, int end) {\n        if (node.start > end || node.end < start) return 0;\n        if (node.start >= start && node.end <= end) return node.val;\n        return Math.max(rangeMaxQuery(node.left, start, end), rangeMaxQuery(node.right, start, end));\n    }\n}"
      }
    },
    "2408": {
      "solution": {
        "design": ""
      }
    },
    "2409": {
      "solution": {
        "math": ""
      }
    },
    "2410": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2411": {
      "solution": {
        "sliding-window": "class Solution {\n  public int[] smallestSubarrays(int[] nums) {\n  int kMaxBit = 30;\n    int[] ans = new int[nums.length];\n    int[] closest = new int[kMaxBit];\n\n    Arrays.fill(ans, 1);\n\n    for (int i = nums.length - 1; i >= 0; --i)\n      for (int j = 0; j < kMaxBit; ++j) {\n        if ((nums[i] >> j & 1) == 1)\n          closest[j] = i;\n        ans[i] = Math.max(ans[i], closest[j] - i + 1);\n      }\n\n    return ans;\n  }\n}"
      }
    },
    "2412": {
      "solution": {
        "greedy": ""
      }
    },
    "2413": {
      "solution": {
        "number-theory": "class Solution {\npublic:\n    int smallestEvenMultiple(int n) {\n        if (n % 2 == 0) {\n            return n;  // If n is even, return n itself\n        } else {\n            return 2 * n;  // If n is odd, return 2 * n\n        }\n    }\n};\n"
      }
    },
    "2414": {
      "solution": {
        "string": ""
      }
    },
    "2415": {
      "solution": {
        "tree": ""
      }
    },
    "2416": {
      "solution": {
        "trie": "class Solution {\npublic:\n    vector<int> sumPrefixScores(vector<string>& words) {\n        struct TrieNode {\n            unordered_map<char, TrieNode*> children;\n            int count = 0;  \n        };\n\n        TrieNode* root = new TrieNode();\n\n        auto insert = [&](const string& word) {\n            TrieNode* node = root;\n            for (char c : word) {\n                if (!node->children.count(c))\n                    node->children[c] = new TrieNode();\n                node = node->children[c];\n                ++node->count; \n            }\n        };\n\n        auto getPrefixScore = [&](const string& word) -> int {\n            TrieNode* node = root;\n            int score = 0;\n            for (char c : word) {\n                node = node->children[c];\n                score += node->count;  \n            }\n            return score;\n        };\n\n        for (const string& word : words)\n            insert(word);\n\n        vector<int> result;\n        for (const string& word : words)\n            result.push_back(getPrefixScore(word));\n\n        return result;\n    }\n};\n"
      }
    },
    "2417": {
      "solution": {
        "enumeration": ""
      }
    },
    "2418": {
      "solution": {
        "sorting": ""
      }
    },
    "2419": {
      "solution": {
        "brainteaser": "class Solution {\n    public int longestSubarray(int[] nums) {\n        int max = 0;\n        for (int num : nums) {\n            max = Math.max(max, num);\n        }\n\n        int maxLength = 0;\n        int currentLength = 0;\n        for (int num : nums) {\n            if (num == max) {\n                currentLength++;\n                maxLength = Math.max(maxLength, currentLength);\n            } else {\n                currentLength = 0;\n            }\n        }\n        return maxLength;\n    }\n}\n"
      }
    },
    "2420": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2421": {
      "solution": {
        "union-find": "class UnionFind {\npublic:\n    UnionFind(int n) : parent(n), rank(n) { iota(parent.begin(), parent.end(), 0); }\n\n    void unionByRank(int u, int v) {\n        const int i = find(u);\n        const int j = find(v);\n        if (i == j)\n            return;\n        if (rank[i] < rank[j]) {\n            parent[i] = j;\n        } else if (rank[i] > rank[j]) {\n            parent[j] = i;\n        } else {\n            parent[i] = j;\n            ++rank[j];\n        }\n    }\n\n    int find(int u) { return parent[u] == u ? u : parent[u] = find(parent[u]); }\n\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n};\n\nclass Solution {\npublic:\n    int numberOfGoodPaths(vector<int>& vals, vector<vector<int>>& edges) {\n        const int n = vals.size();\n        int ans = n;\n        UnionFind uf(n);\n        vector<vector<int>> tree(n);\n        map<int, vector<int>> valToNodes;\n\n        for (int i = 0; i < vals.size(); ++i)\n            valToNodes[vals[i]].push_back(i);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            if (vals[v] <= vals[u])\n                tree[u].push_back(v);\n            if (vals[u] <= vals[v])\n                tree[v].push_back(u);\n        }\n\n        for (const auto& [val, nodes] : valToNodes) {\n            for (const int u : nodes)\n                for (const int v : tree[u])\n                    uf.unionByRank(u, v);\n            unordered_map<int, int> rootCount;\n            for (const int u : nodes)\n                ++rootCount[uf.find(u)];\n            for (const auto& [_, count] : rootCount)\n                ans += count * (count - 1) / 2;\n        }\n\n        return ans;\n    }\n};"
      }
    },
    "2422": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2423": {
      "solution": {
        "counting": ""
      }
    },
    "2424": {
      "solution": {
        "union-find": ""
      }
    },
    "2425": {
      "solution": {
        "brainteaser": ""
      }
    },
    "2426": {
      "solution": {
        "merge-sort": "import java.util.*;\n\nclass Solution {\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\n        int n = nums1.length;\n        int[] A = new int[n];\n        \n        for (int i = 0; i < n; ++i) {\n            A[i] = nums1[i] - nums2[i];\n        }\n        \n        long[] ans = {0}; \n        mergeSort(A, 0, n - 1, diff, ans);\n        \n        return ans[0];\n    }\n\n    private void mergeSort(int[] A, int left, int right, int diff, long[] ans) {\n        if (left >= right) {\n            return;\n        }\n        \n        int m = (left + right) / 2;\n        mergeSort(A, left, m, diff, ans);\n        mergeSort(A, m + 1, right, diff, ans);\n        merge(A, left, m, right, diff, ans);\n    }\n\n    private void merge(int[] A, int left, int m, int right, int diff, long[] ans) {\n        int lo = m + 1;\n        int hi = m + 1; \n        for (int i = left; i <= m; ++i) {\n            while (hi <= right && A[i] > A[hi] + diff) {\n                ++hi;\n            }\n            ans[0] += right - hi + 1;\n        }\n        \n        int[] sorted = new int[right - left + 1];\n        int k = 0; // Index for sorted array\n        int i = left; // Index for left subarray\n        int j = m + 1; // Index for right subarray\n        \n        while (i <= m && j <= right) {\n            if (A[i] <= A[j]) {\n                sorted[k++] = A[i++];\n            } else {\n                sorted[k++] = A[j++];\n            }\n        }\n        \n        while (i <= m) {\n            sorted[k++] = A[i++];\n        }\n        \n        while (j <= right) {\n            sorted[k++] = A[j++];\n        }\n        \n        System.arraycopy(sorted, 0, A, left, sorted.length);\n    }\n}\n"
      }
    },
    "2427": {
      "solution": {
        "number-theory": "#include <cmath> \n#include <algorithm>  \n\nclass Solution {\npublic:\n    int commonFactors(int a, int b) {\n        int gcdValue = std::gcd(a, b);  \n        int count = 0;\n        \n        for (int i = 1; i <= sqrt(gcdValue); ++i) {\n            if (gcdValue % i == 0) {  \n                count++; \n                if (i != gcdValue / i) {\n                    count++;  \n                }\n            }\n        }\n        \n        return count;\n    }\n};\n"
      }
    },
    "2428": {
      "solution": {
        "matrix": ""
      }
    },
    "2429": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2430": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2431": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2432": {
      "solution": {
        "array": ""
      }
    },
    "2433": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2434": {
      "solution": {
        "stack": ""
      }
    },
    "2435": {
      "solution": {
        "matrix": "class Solution {\n  public int numberOfPaths(int[][] grid, int k) {\n    final int kMod = 1_000_000_007;\n    final int m = grid.length;\n    final int n = grid[0].length;\n    // dp[i][j][sum] : = the number of paths to(i, j), where the sum / k == sum\n    int[][][] dp = new int[m][n][k];\n    dp[0][0][grid[0][0] % k] = 1;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        for (int sum = 0; sum < k; ++sum) {\n          final int newSum = (sum + grid[i][j]) % k;\n          if (i > 0)\n            dp[i][j][newSum] += dp[i - 1][j][sum];\n          if (j > 0)\n            dp[i][j][newSum] += dp[i][j - 1][sum];\n          dp[i][j][newSum] %= kMod;\n        }\n\n    return dp[m - 1][n - 1][0];\n  }\n}"
      }
    },
    "2436": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2437": {
      "solution": {
        "enumeration": ""
      }
    },
    "2438": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2439": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2440": {
      "solution": {
        "tree": ""
      }
    },
    "2441": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2442": {
      "solution": {
        "math": ""
      }
    },
    "2443": {
      "solution": {
        "enumeration": ""
      }
    },
    "2444": {
      "solution": {
        "monotonic-queue": "class Solution {\n    public long countSubarrays(int[] nums, int minK, int maxK) {\n        long ans = 0;\n        int j1 = -1, j2 = -1, k = -1;\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] < minK || nums[i] > maxK) {\n                k = i;\n            }\n            if (nums[i] == minK) {\n                j1 = i;\n            }\n            if (nums[i] == maxK) {\n                j2 = i;\n            }\n            ans += Math.max(0, Math.min(j1, j2) - k);\n        }\n        return ans;\n    }\n}"
      }
    },
    "2445": {
      "solution": {
        "tree": ""
      }
    },
    "2446": {
      "solution": {
        "string": ""
      }
    },
    "2447": {
      "solution": {
        "number-theory": ""
      }
    },
    "2448": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2449": {
      "solution": {
        "greedy": ""
      }
    },
    "2450": {
      "solution": {
        "math": ""
      }
    },
    "2451": {
      "solution": {
        "hash-table": ""
      }
    },
    "2452": {
      "solution": {
        "string": ""
      }
    },
    "2453": {
      "solution": {
        "counting": ""
      }
    },
    "2454": {
      "solution": {
        "monotonic-stack": "class Solution {\n    public int[] secondGreaterElement(int[] nums) {\n        int[] ans = new int[nums.length];\n        Arrays.fill(ans, -1);\n        // a decreasing stack that stores indices that met the first greater number\n        Deque<Integer> prevStack = new ArrayDeque<>();\n        // a decreasing stack that stores indices\n        Deque<Integer> currStack = new ArrayDeque<>();\n\n        for (int i = 0; i < nums.length; ++i) {\n            while (!prevStack.isEmpty() && nums[prevStack.peek()] < nums[i])\n                ans[prevStack.poll()] = nums[i];\n            Deque<Integer> decreasingIndices = new ArrayDeque<>();\n            while (!currStack.isEmpty() && nums[currStack.peek()] < nums[i])\n                decreasingIndices.push(currStack.poll());\n            while (!decreasingIndices.isEmpty())\n                prevStack.push(decreasingIndices.poll());\n            currStack.push(i);\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "2455": {
      "solution": {
        "math": ""
      }
    },
    "2456": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2457": {
      "solution": {
        "greedy": ""
      }
    },
    "2458": {
      "solution": {
        "tree": ""
      }
    },
    "2459": {
      "solution": {
        "greedy": ""
      }
    },
    "2460": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2461": {
      "solution": {
        "sliding-window": "class Solution {\n  public long maximumSubarraySum(int[] nums, int k) {\n    long ans = 0;\n    long sum = 0;\n    int distinct = 0;\n    Map<Integer, Integer> count = new HashMap<>();\n\n    for (int i = 0; i < nums.length; ++i) {\n      sum += nums[i];\n      if (count.merge(nums[i], 1, Integer::sum) == 1)\n        ++distinct;\n      if (i >= k) {\n        if (count.merge(nums[i - k], -1, Integer::sum) == 0)\n          --distinct;\n        sum -= nums[i - k];\n      }\n      if (i >= k - 1 && distinct == k)\n        ans = Math.max(ans, sum);\n    }\n\n    return ans;\n  }\n}"
      }
    },
    "2462": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2463": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2464": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2465": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2466": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2467": {
      "solution": {
        "tree": ""
      }
    },
    "2468": {
      "solution": {
        "string": ""
      }
    },
    "2469": {
      "solution": {
        "math": ""
      }
    },
    "2470": {
      "solution": {
        "number-theory": ""
      }
    },
    "2471": {
      "solution": {
        "tree": ""
      }
    },
    "2472": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2473": {
      "solution": {
        "shortest-path": "class Solution {\n public:\n  vector<long long> minCost(int n, vector<vector<int>>& roads,\n                            vector<int>& appleCost, int k) {\n    vector<long long> ans;\n    vector<vector<pair<int, long>>> graph(n);\n\n    for (const vector<int>& road : roads) {\n      const int u = road[0] - 1;\n      const int v = road[1] - 1;\n      const int w = road[2];\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n    }\n\n    for (int i = 0; i < n; ++i)\n      ans.push_back(dijkstra(graph, i, appleCost, k));\n\n    return ans;\n  }\n\n private:\n  long dijkstra(const vector<vector<pair<int, long>>>& graph, int i,\n                const vector<int>& appleCost, int k) {\n    vector<long> forwardCost(graph.size(), LONG_MAX);\n    vector<long> totalCost(graph.size(), LONG_MAX);\n    forwardCost[i] = 0;\n    queue<int> q{{i}};\n\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      for (const auto& [v, w] : graph[u]) {\n        const long nextCost = forwardCost[u] + w;\n        if (nextCost >= forwardCost[v])\n          continue;\n        forwardCost[v] = nextCost;\n        // Take apple at city v and return back to city i.\n        totalCost[v] = (k + 1) * nextCost + appleCost[v];\n        q.push(v);\n      }\n    }\n\n    return min(static_cast<long>(appleCost[i]), ranges::min(totalCost));\n  }\n};"
      }
    },
    "2474": {
      "solution": {
        "database": ""
      }
    },
    "2475": {
      "solution": {
        "sorting": ""
      }
    },
    "2476": {
      "solution": {
        "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private List<Integer> nums = new ArrayList<>();\n\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\n        inorder(root);\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int x : queries) {\n            int i = Collections.binarySearch(nums, x + 1);\n            int j = Collections.binarySearch(nums, x);\n            i = i < 0 ? -i - 2 : i - 1;\n            j = j < 0 ? -j - 1 : j;\n            int mi = i >= 0 && i < nums.size() ? nums.get(i) : -1;\n            int mx = j >= 0 && j < nums.size() ? nums.get(j) : -1;\n            ans.add(List.of(mi, mx));\n        }\n        return ans;\n    }\n\n    private void inorder(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        inorder(root.left);\n        nums.add(root.val);\n        inorder(root.right);\n    }\n}\n"
      }
    },
    "2477": {
      "solution": {
        "tree": ""
      }
    },
    "2478": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2479": {
      "solution": {
        "tree": ""
      }
    },
    "2480": {
      "solution": {
        "database": ""
      }
    },
    "2481": {
      "solution": {
        "geometry": "class Solution {\npublic:\n    int numberOfCuts(int n) {\n        if (n == 1)\n            return 0;                  // No cuts needed for one part\n        return n % 2 == 0 ? n / 2 : n; // Even: n/2 cuts, Odd: n cuts\n    }\n};\n"
      }
    },
    "2482": {
      "solution": {
        "matrix": "class Solution {\n    public int[][] onesMinusZeros(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int[] rows = new int[m];\n        int[] cols = new int[n];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                int v = grid[i][j];\n                rows[i] += v;\n                cols[j] += v;\n            }\n        }\n        int[][] diff = new int[m][n];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                diff[i][j] = rows[i] + cols[j] - (n - rows[i]) - (m - cols[j]);\n            }\n        }\n        return diff;\n    }\n}"
      }
    },
    "2483": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2484": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2485": {
      "solution": {
        "prefix-sum": "class Solution {\n    public int pivotInteger(int n) {\n        int totalSum = n * (n + 1) / 2;\n        \n        for (int x = 1; x <= n; x++) {\n            int sumLeft = x * (x + 1) / 2;            \n            int sumRight = totalSum - sumLeft + x;\n            \n            if (sumLeft == sumRight) {\n                return x;\n            }\n        }\n        \n        // Return -1 if no pivot integer is found\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.pivotInteger(8));  // Output: 6\n        System.out.println(solution.pivotInteger(1));  // Output: 1\n        System.out.println(solution.pivotInteger(5));  // Output: -1\n    }\n}\n"
      }
    },
    "2486": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2487": {
      "solution": {
        "linked-list": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNodes(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n        head = prev;\n\n        ListNode* newHead = head;\n        ListNode* maxNode = head;\n        curr = head->next;\n\n        while (curr) {\n            if (curr->val < maxNode->val) {\n                maxNode->next = curr->next;\n            } else {\n                maxNode = curr;\n            }\n            curr = maxNode->next;\n        }\n\n        prev = nullptr;\n        curr = newHead;\n        while (curr) {\n            ListNode* next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n};\n"
      }
    },
    "2488": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2489": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2490": {
      "solution": {
        "string": ""
      }
    },
    "2491": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2492": {
      "solution": {
        "breadth-first-search": "class Solution {\npublic:\n    int minScore(int n, vector<vector<int>>& roads) {\n        vector<vector<pair<int, int>>> graph(n + 1);\n        \n        for (auto& road : roads) {\n            int u = road[0], v = road[1], score = road[2];\n            graph[u].push_back({v, score});\n            graph[v].push_back({u, score});\n        }\n        \n        vector<bool> visited(n + 1, false);\n        queue<int> q;\n        q.push(1);\n        visited[1] = true;\n        int minScore = INT_MAX;\n        \n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            for (auto& neighbor : graph[node]) {\n                int nextCity = neighbor.first;\n                int roadScore = neighbor.second;\n                \n                minScore = min(minScore, roadScore);\n                \n                if (!visited[nextCity]) {\n                    visited[nextCity] = true;\n                    q.push(nextCity);\n                }\n            }\n        }\n        \n        return minScore;\n    }\n};\n"
      }
    },
    "2493": {
      "solution": {
        "union-find": ""
      }
    },
    "2494": {
      "solution": {
        "database": ""
      }
    },
    "2495": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2496": {
      "solution": {
        "string": ""
      }
    },
    "2497": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2498": {
      "solution": {
        "greedy": "",
        "binary-search": "class Solution {\npublic:\n    int maxJump(vector<int>& stones) {\n        int ans = stones[1] - stones[0];\n        for (int i = 2; i < stones.size(); ++i)\n            ans = max(ans, stones[i] - stones[i - 2]);\n        return ans;\n    }\n};"
      }
    },
    "2499": {
      "solution": {
        "counting": ""
      }
    },
    "2500": {
      "solution": {
        "matrix": ""
      }
    },
    "2501": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2502": {
      "solution": {
        "design": ""
      }
    },
    "2503": {
      "solution": {
        "union-find": ""
      }
    },
    "2504": {
      "solution": {
        "database": ""
      }
    },
    "2505": {
      "solution": {
        "brainteaser": ""
      }
    },
    "2506": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2507": {
      "solution": {
        "number-theory": ""
      }
    },
    "2508": {
      "solution": {
        "graph": ""
      }
    },
    "2509": {
      "solution": {
        "tree": ""
      }
    },
    "2510": {
      "solution": {
        "matrix": "class Solution {\n  public boolean isThereAPath(int[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    // Map negative (the number of 0s - the number of 1s) to non-negative one.\n    int cells = m + n - 1;\n    if (cells % 2 == 1)\n      return false;\n    Boolean[][][] mem = new Boolean[m][n][cells * 2 + 1];\n    return isThereAPath(grid, 0, 0, 0, cells, mem);\n  }\n\n  // Returns 1 if there's a path to grid[i][j]\n  // s.t. `sum` = (the number of 0s - the number of 1s).\n  private boolean isThereAPath(int[][] grid, int i, int j, int sum, final int cells,\n                               Boolean[][][] mem) {\n    if (i == grid.length || j == grid[0].length)\n      return false;\n    sum += grid[i][j] == 0 ? 1 : -1;\n    if (i == grid.length - 1 && j == grid[0].length - 1)\n      return sum == 0;\n    final int k = cells + sum;\n    if (mem[i][j][k] != null)\n      return mem[i][j][k];\n    return mem[i][j][k] = isThereAPath(grid, i + 1, j, sum, cells, mem) ||\n                          isThereAPath(grid, i, j + 1, sum, cells, mem);\n  }\n}"
      }
    },
    "2511": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2512": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2513": {
      "solution": {
        "number-theory": ""
      }
    },
    "2514": {
      "solution": {
        "combinatorics": ""
      }
    },
    "2515": {
      "solution": {
        "string": ""
      }
    },
    "2516": {
      "solution": {
        "sliding-window": "class Solution {\n    public int takeCharacters(String s, int k) {\n      int n = s.length();\n        int ans = n;\n        int[] count = new int[3];\n\n        for (final char c : s.toCharArray())\n            ++count[c - 'a'];\n\n        if (count[0] < k || count[1] < k || count[2] < k)\n            return -1;\n\n        for (int left = 0, right = 0; right < n; ++right) {\n            --count[s.charAt(right) - 'a'];\n            while (count[s.charAt(right) - 'a'] < k)\n                ++count[s.charAt(left++) - 'a'];\n            ans = Math.min(ans, n - (right - left + 1));\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "2517": {
      "solution": {
        "greedy": ""
      }
    },
    "2518": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2519": {
      "solution": {
        "merge-sort": "class FenwickTree {\n  public FenwickTree(int n) {\n    sums = new int[n + 1];\n  }\n\n  public void add(int i, int delta) {\n    while (i < sums.length) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  public int get(int i) {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n\n  private int[] sums;\n\n  private static int lowbit(int i) {\n    return i & -i;\n  }\n}\n\nclass Solution {\n  public int kBigIndices(int[] nums, int k) {\n  int n = nums.length;\n    int ans = 0;\n    FenwickTree leftTree = new FenwickTree(n);\n    FenwickTree rightTree = new FenwickTree(n);\n    int[] left = new int[n];\n    int[] right = new int[n];\n\n    for (int i = 0; i < n; ++i) {\n      left[i] = leftTree.get(nums[i] - 1);\n      leftTree.add(nums[i], 1);\n    }\n\n    for (int i = n - 1; i >= 0; --i) {\n      right[i] = rightTree.get(nums[i] - 1);\n      rightTree.add(nums[i], 1);\n    }\n\n    for (int i = 0; i < n; ++i)\n      if (left[i] >= k && right[i] >= k)\n        ++ans;\n\n    return ans;\n  }\n}"
      }
    },
    "2520": {
      "solution": {
        "math": ""
      }
    },
    "2521": {
      "solution": {
        "number-theory": ""
      }
    },
    "2522": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2523": {
      "solution": {
        "number-theory": ""
      }
    },
    "2524": {
      "solution": {
        "sliding-window": "class Solution {\n    public int maxFrequencyScore(int[] nums, int k) {\n      int mod = (int) 1e9 + 7;\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int i = 0; i < k; ++i) {\n            count.put(nums[i], count.getOrDefault(nums[i], 0) + 1);\n        }\n        long curr = 0;\n        for (var e : count.entrySet()) {\n            curr = (curr + qmi(e.getKey(), e.getValue(), mod)) % mod;\n        }\n        long ans = curr;\n        for (int i = k; i < nums.length; ++i) {\n            int a = nums[i - k];\n            int b = nums[i];\n            if (a != b) {\n                if (count.getOrDefault(b, 0) > 0) {\n                    curr += (b - 1) * qmi(b, count.get(b), mod) % mod;\n                } else {\n                    curr += b;\n                }\n                if (count.getOrDefault(a, 0) > 1) {\n                    curr -= (a - 1) * qmi(a, count.get(a) - 1, mod) % mod;\n                } else {\n                    curr -= a;\n                }\n                curr = (curr + mod) % mod;\n                count.put(b, count.getOrDefault(b, 0) + 1);\n                count.put(a, count.getOrDefault(a, 0) - 1);\n                ans = Math.max(ans, curr);\n            }\n        }\n        return (int) ans;\n    }\n\n    long qmi(long a, long k, long p) {\n        long res = 1;\n        while (k != 0) {\n            if ((k & 1) == 1) {\n                res = res * a % p;\n            }\n            k >>= 1;\n            a = a * a % p;\n        }\n        return res;\n    }\n}"
      }
    },
    "2525": {
      "solution": {
        "math": ""
      }
    },
    "2526": {
      "solution": {
        "queue": "",
        "ordered-set": "class DataStream {\npublic:\n    DataStream(int value, int k) : targetValue(value), requiredCount(k), currentCount(0) {}\n\n    bool consec(int num) {\n        if (num == targetValue) {\n            currentCount++;\n        } else {\n            currentCount = 0;\n        }\n        return currentCount >= requiredCount;\n    }\n\nprivate:\n    int targetValue;  // The target value to check for\n    int requiredCount;  // The required number of consecutive occurrences\n    int currentCount;  // The current number of consecutive occurrences\n};\n\n/**\n * Your DataStream object will be instantiated and called as such:\n * DataStream* obj = new DataStream(value, k);\n * bool param_1 = obj->consec(num);\n */\n"
      }
    },
    "2527": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2528": {
      "solution": {
        "sliding-window": "class Solution {\n  public long maxPower(int[] stations, int right, int k) {\n    long left = Arrays.stream(stations).min().getAsInt();\n    long right = Arrays.stream(stations).asLongStream().sum() + k + 1;\n\n    while (left < right) {\n    long mid = (left + right) / 2;\n      if (check(stations.clone(), right, k, mid))\n        left = mid + 1;\n      else\n        right = mid;\n    }\n\n    return left - 1;\n  }\n\n  boolean check(int[] stations, int right, int additionalStations, long minPower) {\n  int n = stations.length;\n    long power = 0;\n\n    for (int i = 0; i < right; ++i)\n      power += stations[i];\n\n    for (int i = 0; i < n; ++i) {\n      if (i + right < n)\n        power += stations[i + right]; \n      if (power < minPower) {\n      long requiredPower = minPower - power;\n        if (requiredPower > additionalStations)\n          return false;\n        stations[Math.min(n - 1, i + right)] += requiredPower;\n        additionalStations -= requiredPower;\n        power += requiredPower;\n      }\n      if (i - right >= 0)\n        power -= stations[i - right];\n    }\n\n    return true;\n  }\n}"
      }
    },
    "2529": {
      "solution": {
        "counting": "",
        "binary-search": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maximumCount(vector<int>& nums) {\n        int n = nums.size();\n        \n        // Find the first non-negative index\n        int firstNonNegative = lower_bound(nums.begin(), nums.end(), 0) - nums.begin();\n        \n        // Find the first positive index\n        int firstPositive = upper_bound(nums.begin(), nums.end(), 0) - nums.begin();\n        \n        // Count negatives and positives\n        int negativeCount = firstNonNegative; // All elements before the first non-negative are negative\n        int positiveCount = n - firstPositive; // All elements from firstPositive to the end are positive\n        \n        return max(negativeCount, positiveCount);\n    }\n};\n"
      }
    },
    "2530": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2531": {
      "solution": {
        "counting": ""
      }
    },
    "2532": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2533": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2534": {
      "solution": {
        "queue": ""
      }
    },
    "2535": {
      "solution": {
        "math": ""
      }
    },
    "2536": {
      "solution": {
        "matrix": ""
      }
    },
    "2537": {
      "solution": {
        "sliding-window": "import java.util.*;\n\nclass Solution {\n    public long countGood(int[] nums, int k) {\n        long ans = 0;\n        int pairs = 0;\n        Map<Integer, Integer> count = new HashMap<>();\n\n        for (int left = 0, right = 0; right < nums.length; ++right) {\n            pairs += count.getOrDefault(nums[right], 0);\n            count.put(nums[right], count.getOrDefault(nums[right], 0) + 1);\n            \n            while (pairs >= k) {\n                pairs -= count.get(nums[left]) - 1;\n                count.put(nums[left], count.get(nums[left]) - 1);\n                left++;\n            }\n            \n            ans += left;\n        }\n\n        return ans;\n    }\n}\n"
      }
    },
    "2538": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2539": {
      "solution": {
        "combinatorics": ""
      }
    },
    "2540": {
      "solution": {
        "two-pointers": "",
        "binary-search": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\n        for (int num : nums1) {\n            if (binary_search(nums2.begin(), nums2.end(), num)) {\n                return num;\n            }\n        }\n        return -1; \n    }\n};\n"
      }
    },
    "2541": {
      "solution": {
        "greedy": ""
      }
    },
    "2542": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2543": {
      "solution": {
        "number-theory": ""
      }
    },
    "2544": {
      "solution": {
        "math": ""
      }
    },
    "2545": {
      "solution": {
        "matrix": ""
      }
    },
    "2546": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2547": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2548": {
      "solution": {
        "greedy": ""
      }
    },
    "2549": {
      "solution": {
        "math": ""
      }
    },
    "2550": {
      "solution": {
        "recursion": "class Solution {\npublic:\n    const int MOD = 1e9 + 7;\n\n    int monkeyMove(int n) {\n        // We need to calculate 2^n - 2, because we can choose to move\n        // the monkeys in either clockwise or counter-clockwise direction\n        // for each of the n monkeys, but the two configurations (all clockwise\n        // and all counter-clockwise) don't result in any collision. Thus, the\n        // total number of collisions is 2^n - 2.\n\n        return (modExp(2, n, MOD) - 2 + MOD) % MOD;\n    }\n\nprivate:\n    long long modExp(long long base, long long exp, int mod) {\n        if (exp == 0)\n            return 1;\n        long long half = modExp(base, exp / 2, mod);\n        half = (half * half) % mod;\n        if (exp % 2 != 0) {\n            half = (half * base) % mod;\n        }\n        return half;\n    }\n};\n"
      }
    },
    "2551": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2552": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2553": {
      "solution": {
        "array": ""
      }
    },
    "2554": {
      "solution": {
        "greedy": ""
      }
    },
    "2555": {
      "solution": {
        "sliding-window": "class Solution {\n    public int maximizeWin(int[] prizePositions, int k) {\n        int ans = 0;\n        int[] dp = new int[prizePositions.length + 1];\n\n        for (int i = 0, j = 0; i < prizePositions.length; ++i) {\n            while (prizePositions[i] - prizePositions[j] > k)\n                ++j;\n          int covered = i - j + 1;\n            dp[i + 1] = Math.max(dp[i], covered);\n            ans = Math.max(ans, dp[j] + covered);\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "2556": {
      "solution": {
        "matrix": "class Solution {\n    public boolean isPossibleToCutPath(int[][] grid) {\n        if (!dfs(grid, 0, 0))\n            return true;\n        // Reassign (0, 0) as 1.\n        grid[0][0] = 1;\n        return !dfs(grid, 0, 0);\n    }\n\n    // Returns true is there's a path from (0, 0) to (m - 1, n - 1).\n    // Also marks the visited path as 0 except (m - 1, n - 1).\n    private boolean dfs(int[][] grid, int i, int j) {\n        if (i == grid.length || j == grid[0].length)\n            return false;\n        if (i == grid.length - 1 && j == grid[0].length - 1)\n            return true;\n        if (grid[i][j] == 0)\n            return false;\n\n        grid[i][j] = 0;\n        return dfs(grid, i + 1, j) || dfs(grid, i, j + 1);\n    }\n}"
      }
    },
    "2557": {
      "solution": {
        "greedy": ""
      }
    },
    "2558": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2559": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2560": {
      "solution": {
        "array": "",
        "binary-search": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minCapability(vector<int>& nums, int k) {\n        int left = *min_element(nums.begin(), nums.end());\n        int right = *max_element(nums.begin(), nums.end());\n        int result = right;\n\n        auto canRob = [&](int maxCapability) -> bool {\n            int count = 0;\n            int i = 0;\n            while (i < nums.size()) {\n                if (nums[i] <= maxCapability) {\n                    count++;\n                    i += 2;\n                } else {\n                    i++;\n                }\n                if (count >= k) return true; \n            }\n            return count >= k;\n        };\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (canRob(mid)) {\n                result = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return result;\n    }\n};\n"
      }
    },
    "2561": {
      "solution": {
        "greedy": ""
      }
    },
    "2562": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2563": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2564": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2565": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2566": {
      "solution": {
        "greedy": ""
      }
    },
    "2567": {
      "solution": {
        "greedy": ""
      }
    },
    "2568": {
      "solution": {
        "brainteaser": "class Solution {\n    public int minImpossibleOR(int[] nums) {\n        int res = 1;\n        Set<Integer> seen = new HashSet<>();\n        for (int num : nums) {\n            seen.add(num);\n        }\n\n        while (seen.contains(res)) {\n            res <<= 1; // Move to the next power of 2\n        }\n        \n        return res;\n    }\n}\n"
      }
    },
    "2569": {
      "solution": {
        "segment-tree": ""
      }
    },
    "2570": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2571": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2572": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2573": {
      "solution": {
        "union-find": ""
      }
    },
    "2574": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2575": {
      "solution": {
        "math": ""
      }
    },
    "2576": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2577": {
      "solution": {
        "shortest-path": "class Solution {\n public:\n  int minimumTime(vector<vector<int>>& grid) {\n    if (grid[0][1] > 1 && grid[1][0] > 1)\n      return -1;\n\n    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = grid.size();\n    const int n = grid[0].size();\n    using T = tuple<int, int, int>;  // (time, i, j)\n    priority_queue<T, vector<T>, greater<>> minHeap;\n    vector<vector<bool>> seen(m, vector<bool>(n));\n\n    minHeap.emplace(0, 0, 0);\n    seen[0][0] = true;\n\n    while (!minHeap.empty()) {\n      const auto [time, i, j] = minHeap.top();\n      minHeap.pop();\n      if (i == m - 1 && j == n - 1)\n        return time;\n      for (const auto& [dx, dy] : dirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        if (seen[x][y])\n          continue;\n        const int extraWait = (grid[x][y] - time) % 2 == 0 ? 1 : 0;\n        const int nextTime = max(time + 1, grid[x][y] + extraWait);\n        minHeap.emplace(nextTime, x, y);\n        seen[x][y] = true;\n      }\n    }\n\n    throw;\n  }\n};"
      }
    },
    "2578": {
      "solution": {
        "greedy": ""
      }
    },
    "2579": {
      "solution": {
        "math": ""
      }
    },
    "2580": {
      "solution": {
        "sorting": ""
      }
    },
    "2581": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2582": {
      "solution": {
        "math": ""
      }
    },
    "2583": {
      "solution": {
        "tree": ""
      }
    },
    "2584": {
      "solution": {
        "number-theory": ""
      }
    },
    "2585": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2586": {
      "solution": {
        "string": ""
      }
    },
    "2587": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2588": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2589": {
      "solution": {
        "stack": ""
      }
    },
    "2590": {
      "solution": {
        "design": ""
      }
    },
    "2591": {
      "solution": {
        "greedy": ""
      }
    },
    "2592": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2593": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2594": {
      "solution": {
        "array": ""
      }
    },
    "2595": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2596": {
      "solution": {
        "matrix": ""
      }
    },
    "2597": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2598": {
      "solution": {
        "greedy": ""
      }
    },
    "2599": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2600": {
      "solution": {
        "greedy": ""
      }
    },
    "2601": {
      "solution": {
        "number-theory": ""
      }
    },
    "2602": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2603": {
      "solution": {
        "topological-sort": ""
      }
    },
    "2604": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2605": {
      "solution": {
        "enumeration": ""
      }
    },
    "2606": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2607": {
      "solution": {
        "number-theory": ""
      }
    },
    "2608": {
      "solution": {
        "graph": ""
      }
    },
    "2609": {
      "solution": {
        "string": ""
      }
    },
    "2610": {
      "solution": {
        "hash-table": ""
      }
    },
    "2611": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2612": {
      "solution": {
        "ordered-set": ""
      }
    },
    "2613": {
      "solution": {
        "ordered-set": ""
      }
    },
    "2614": {
      "solution": {
        "number-theory": "class Solution {\n public:\n  int diagonalPrime(vector<vector<int>>& nums) {\n    int ans = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n      const int a = nums[i][i];\n      const int b = nums[i][nums.size() - i - 1];\n      if (isPrime(a))\n        ans = max(ans, a);\n      if (isPrime(b))\n        ans = max(ans, b);\n    }\n    return ans;\n  }\n\n private:\n  bool isPrime(int n) {\n    if (n <= 1)\n      return false;\n    for (int i = 2; i * i <= n; ++i)\n      if (n % i == 0)\n        return false;\n    return true;\n  }\n};"
      }
    },
    "2615": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2616": {
      "solution": {
        "greedy": ""
      }
    },
    "2617": {
      "solution": {
        "union-find": ""
      }
    },
    "2638": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2639": {
      "solution": {
        "matrix": ""
      }
    },
    "2640": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2641": {
      "solution": {
        "tree": ""
      }
    },
    "2642": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2643": {
      "solution": {
        "matrix": "class Solution {\n  public int[] rowAndMaximumOnes(int[][] mat) {\n    int[] ans = new int[2];\n\n    for (int i = 0; i < mat.length; ++i) {\n      int ones = (int) Arrays.stream(mat[i]).filter(a -> a == 1).count();\n      if (ones > ans[1]) {\n        ans[0] = i;\n        ans[1] = ones;\n      }\n    }\n\n    return ans;\n  }\n}"
      }
    },
    "2644": {
      "solution": {
        "array": ""
      }
    },
    "2645": {
      "solution": {
        "stack": ""
      }
    },
    "2646": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2647": {
      "solution": {
        "math": ""
      }
    },
    "2651": {
      "solution": {
        "math": ""
      }
    },
    "2652": {
      "solution": {
        "math": ""
      }
    },
    "2653": {
      "solution": {
        "sliding-window": "class Solution {\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\n        int[] ans = new int[nums.length - k + 1];\n        int[] count = new int[50];\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] < 0)\n                ++count[nums[i] + 50];\n            if (i - k >= 0 && nums[i - k] < 0)\n                --count[nums[i - k] + 50];\n            if (i + 1 >= k)\n                ans[i - k + 1] = getXthSmallestNum(count, x);\n        }\n\n        return ans;\n    }\n\n    private int getXthSmallestNum(int[] count, int x) {\n        int prefix = 0;\n        for (int i = 0; i < 50; ++i) {\n            prefix += count[i];\n            if (prefix >= x)\n                return i - 50;\n        }\n        return 0;\n    }\n}"
      }
    },
    "2654": {
      "solution": {
        "number-theory": ""
      }
    },
    "2655": {
      "solution": {
        "sorting": ""
      }
    },
    "2656": {
      "solution": {
        "greedy": ""
      }
    },
    "2657": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2658": {
      "solution": {
        "union-find": ""
      }
    },
    "2659": {
      "solution": {
        "ordered-set": "class Solution {\npublic:\n    long long countOperationsToEmptyArray(vector<int>& nums) {\n        const int n = nums.size();\n        long ans = n;\n        unordered_map<int, int> numToIndex;\n\n        for (int i = 0; i < n; ++i)\n            numToIndex[nums[i]] = i;\n\n        ranges::sort(nums);\n\n        for (int i = 1; i < n; ++i)\n            // On the i-th step we've already removed the i - 1 smallest numbers\n            // and can ignore them. If an element nums[i] has smaller index in\n            // origin array than nums[i - 1], we should rotate the whole left\n            // array n - i times to set nums[i] element on the first position.\n            if (numToIndex[nums[i]] < numToIndex[nums[i - 1]])\n                ans += n - i;\n\n        return ans;\n    }\n};"
      }
    },
    "2660": {
      "solution": {
        "array": ""
      }
    },
    "2661": {
      "solution": {
        "matrix": ""
      }
    },
    "2662": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2663": {
      "solution": {
        "greedy": ""
      }
    },
    "2664": {
      "solution": {
        "matrix": ""
      }
    },
    "2668": {
      "solution": {
        "database": ""
      }
    },
    "2669": {
      "solution": {
        "database": ""
      }
    },
    "2670": {
      "solution": {
        "hash-table": ""
      }
    },
    "2671": {
      "solution": {
        "design": ""
      }
    },
    "2672": {
      "solution": {
        "array": ""
      }
    },
    "2673": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2674": {
      "solution": {
        "linked-list": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode[] splitCircularLinkedList(ListNode list) {\n        ListNode a = list, b = list;\n        while (b.next != list && b.next.next != list) {\n            a = a.next;\n            b = b.next.next;\n        }\n        if (b.next != list) {\n            b = b.next;\n        }\n        ListNode list2 = a.next;\n        b.next = list2;\n        a.next = list;\n        return new ListNode[] {list, list2};\n    }\n}"
      }
    },
    "2678": {
      "solution": {
        "string": ""
      }
    },
    "2679": {
      "solution": {
        "matrix": "class Solution {\n    public int matrixSum(int[][] nums) {\n        int ans = 0;\n\n        for (int[] row : nums)\n            Arrays.sort(row);\n\n        for (int j = 0; j < nums[0].length; ++j) {\n            int max = 0;\n            for (int i = 0; i < nums.length; ++i)\n                max = Math.max(max, nums[i][j]);\n            ans += max;\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "2680": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2681": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2682": {
      "solution": {
        "hash-table": ""
      }
    },
    "2683": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2684": {
      "solution": {
        "matrix": ""
      }
    },
    "2685": {
      "solution": {
        "graph": ""
      }
    },
    "2686": {
      "solution": {
        "database": ""
      }
    },
    "2687": {
      "solution": {
        "database": ""
      }
    },
    "2688": {
      "solution": {
        "database": ""
      }
    },
    "2689": {
      "solution": {
        "tree": ""
      }
    },
    "2696": {
      "solution": {
        "stack": ""
      }
    },
    "2697": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2698": {
      "solution": {
        "backtracking": ""
      }
    },
    "2699": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2701": {
      "solution": {
        "database": ""
      }
    },
    "2702": {
      "solution": {
        "array": ""
      }
    },
    "2706": {
      "solution": {
        "sorting": ""
      }
    },
    "2707": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2708": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2709": {
      "solution": {
        "union-find": ""
      }
    },
    "2710": {
      "solution": {
        "string": ""
      }
    },
    "2711": {
      "solution": {
        "matrix": ""
      }
    },
    "2712": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2713": {
      "solution": {
        "matrix": "",
        "ordered-set": "class Solution {\npublic:\n    int maxIncreasingCells(vector<vector<int>>& mat) {\n        const int m = mat.size();\n        const int n = mat[0].size();\n        // rows[i] := the maximum path length for the i-th row\n        vector<int> rows(m);\n        // cols[j] := the maximum path length for the j-th column\n        vector<int> cols(n);\n        unordered_map<int, vector<pair<int, int>>> valToIndices;\n        // maxPathLength[i][j] := the maximum path length from mat[i][j]\n        vector<vector<int>> maxPathLength(m, vector<int>(n));\n        // Sort all the unique values in the matrix in non-increasing order.\n        set<int, greater<>> decreasingSet;\n\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j) {\n                valToIndices[mat[i][j]].emplace_back(i, j);\n                decreasingSet.insert(mat[i][j]);\n            }\n\n        for (const int val : decreasingSet) {\n            for (const auto& [i, j] : valToIndices[val])\n                maxPathLength[i][j] = max(rows[i], cols[j]) + 1;\n            for (const auto& [i, j] : valToIndices[val]) {\n                rows[i] = max(rows[i], maxPathLength[i][j]);\n                cols[j] = max(cols[j], maxPathLength[i][j]);\n            }\n        }\n\n        return max(ranges::max(rows), ranges::max(cols));\n    }\n};"
      }
    },
    "2714": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2716": {
      "solution": {
        "hash-table": ""
      }
    },
    "2717": {
      "solution": {
        "array": ""
      }
    },
    "2718": {
      "solution": {
        "hash-table": ""
      }
    },
    "2719": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2720": {
      "solution": {
        "database": ""
      }
    },
    "2728": {
      "solution": {
        "interactive": ""
      }
    },
    "2729": {
      "solution": {
        "math": ""
      }
    },
    "2730": {
      "solution": {
        "sliding-window": "class Solution {\n  public int longestSemiRepetitiveSubstring(String s) {\n    int ans = 1;\n    int prevStart = 0;\n    int start = 0;\n\n    for (int i = 1; i < s.length(); ++i) {\n      if (s.charAt(i) == s.charAt(i - 1)) {\n        if (prevStart > 0)\n          start = prevStart;\n        prevStart = i;\n      }\n      ans = Math.max(ans, i - start + 1);\n    }\n\n    return ans;\n  }\n}"
      }
    },
    "2731": {
      "solution": {
        "brainteaser": ""
      }
    },
    "2732": {
      "solution": {
        "matrix": ""
      }
    },
    "2733": {
      "solution": {
        "sorting": ""
      }
    },
    "2734": {
      "solution": {
        "greedy": ""
      }
    },
    "2735": {
      "solution": {
        "enumeration": ""
      }
    },
    "2736": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "2737": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2738": {
      "solution": {
        "database": ""
      }
    },
    "2739": {
      "solution": {
        "math": ""
      }
    },
    "2740": {
      "solution": {
        "sorting": ""
      }
    },
    "2741": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2742": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2743": {
      "solution": {
        "sliding-window": "class Solution {\n    public int numberOfSpecialSubstrings(String s) {\n        int n = s.length();\n        int ans = 0;\n        int[] count = new int[26];\n        for (int i = 0, j = 0; i < n; ++i) {\n            int k = s.charAt(i) - 'a';\n            ++count[k];\n            while (count[k] > 1) {\n                --count[s.charAt(j++) - 'a'];\n            }\n            ans += i - j + 1;\n        }\n        return ans;\n    }\n}"
      }
    },
    "2744": {
      "solution": {
        "hash-table": ""
      }
    },
    "2745": {
      "solution": {
        "brainteaser": "class Solution {\n    public int longestString(int x, int y, int z) {\n        int min = Math.min(x, y);\n        if (x == y)\n            return (min * 2 + z) * 2;\n        return (min * 2 + 1 + z) * 2;\n    }\n}"
      }
    },
    "2746": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2747": {
      "solution": {
        "sliding-window": "class Solution {\n    private class Query {\n        public int query;\n        public int index;\n        public Query(int q, int index) {\n            this.query = q;\n            this.index = index;\n        }\n    }\n\n    public int[] countServers(int n, int[][] logs, int x, int[] queries) {\n        Arrays.sort(logs, (int[] a, int[] b) -> Integer.compare(a[1], b[1]));\n        List<Query> queryList = new ArrayList<>();\n        for (int i = 0; i < queries.length; ++i) {\n            queryList.add(new Query(queries[i], i));\n        }\n        Collections.sort(queryList, (a, b) -> Integer.compare(a.query, b.query));\n\n        int[] ans = new int[queries.length];\n        Map<Integer, Integer> countMap = new HashMap<>();\n        int left = 0;\n        int right = 0;\n        for (int i = 0; i < queryList.size(); ++i) {\n            Query q = queryList.get(i);\n            while (right < logs.length && logs[right][1] <= q.query) {\n                countMap.put(logs[right][0], countMap.getOrDefault(logs[right][0], 0) + 1);\n                ++right;\n            }\n\n            while (left < logs.length && logs[left][1] < q.query - x) {\n                int newCount = countMap.get(logs[left][0]) - 1;\n                if (newCount == 0) {\n                    countMap.remove(logs[left][0]);\n                } else {\n                    countMap.put(logs[left][0], newCount);\n                }\n                ++left;\n            }\n            ans[q.index] = n - countMap.size();\n        }\n        return ans;\n    }\n}"
      }
    },
    "2748": {
      "solution": {
        "number-theory": ""
      }
    },
    "2749": {
      "solution": {
        "brainteaser": ""
      }
    },
    "2750": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2751": {
      "solution": {
        "stack": "class Robot {\n    public int index;\n    public int position;\n    public int health;\n    public char direction;\n\n    public Robot(int index, int position, int health, char direction) {\n        this.index = index;\n        this.position = position;\n        this.health = health;\n        this.direction = direction;\n    }\n}\n\nclass Solution {\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths,\n            String directions) {\n        List<Integer> ans = new ArrayList<>();\n        Robot[] robots = new Robot[positions.length];\n        List<Robot> stack = new ArrayList<>();\n        for (int i = 0; i < positions.length; ++i)\n            robots[i] = new Robot(i, positions[i], healths[i], directions.charAt(i));\n\n        Arrays.sort(robots, (a, b) -> a.position - b.position);\n\n        for (Robot robot : robots) {\n            if (robot.direction == 'R') {\n                stack.add(robot);\n                continue;\n            }\n            while (!stack.isEmpty() && stack.get(stack.size() - 1).direction == 'R'\n                    && robot.health > 0) {\n                if (stack.get(stack.size() - 1).health == robot.health) {\n                    stack.remove(stack.size() - 1);\n                    robot.health = 0;\n                } else if (stack.get(stack.size() - 1).health < robot.health) {\n                    stack.remove(stack.size() - 1);\n                    robot.health -= 1;\n                } else {\n                    stack.get(stack.size() - 1).health -= 1;\n                    robot.health = 0;\n                }\n            }\n            if (robot.health > 0)\n                stack.add(robot);\n        }\n\n        stack.sort((a, b) -> a.index - b.index);\n\n        for (Robot robot : stack)\n            ans.add(robot.health);\n\n        return ans;\n    }\n}"
      }
    },
    "2752": {
      "solution": {
        "database": ""
      }
    },
    "2760": {
      "solution": {
        "sliding-window": "class Solution {\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\n        int ans = 0;\n        int dp = 0;\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] > threshold)\n                dp = 0;\n            else if (i > 0 && dp > 0 && isOddEven(nums[i - 1], nums[i]))\n                ++dp;\n            else\n                dp = nums[i] % 2 == 0 ? 1 : 0;\n            ans = Math.max(ans, dp);\n        }\n\n        return ans;\n    }\n\n    private boolean isOddEven(int a, int b) {\n        return a % 2 != b % 2;\n    }\n}"
      }
    },
    "2761": {
      "solution": {
        "number-theory": ""
      }
    },
    "2762": {
      "solution": {
        "monotonic-queue": "import java.util.Deque;\nimport java.util.LinkedList;\n\nclass Solution {\n    public long continuousSubarrays(int[] nums) {\n        long count = 0;\n        int left = 0;\n        Deque<Integer> maxDeque = new LinkedList<>();\n        Deque<Integer> minDeque = new LinkedList<>();\n\n        for (int right = 0; right < nums.length; right++) {\n            while (!maxDeque.isEmpty() && nums[maxDeque.peekLast()] <= nums[right]) {\n                maxDeque.pollLast();\n            }\n            maxDeque.offerLast(right);\n\n            while (!minDeque.isEmpty() && nums[minDeque.peekLast()] >= nums[right]) {\n                minDeque.pollLast();\n            }\n            minDeque.offerLast(right);\n\n            while (nums[maxDeque.peekFirst()] - nums[minDeque.peekFirst()] > 2) {\n                left++;\n                if (maxDeque.peekFirst() < left) {\n                    maxDeque.pollFirst();\n                }\n                if (minDeque.peekFirst() < left) {\n                    minDeque.pollFirst();\n                }\n            }\n\n            count += right - left + 1;\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums1 = {5, 4, 2, 4};\n        System.out.println(solution.continuousSubarrays(nums1)); \n\n        int[] nums2 = {1, 2, 3};\n        System.out.println(solution.continuousSubarrays(nums2));\n    }\n}\n"
      }
    },
    "2763": {
      "solution": {
        "ordered-set": ""
      }
    },
    "2764": {
      "solution": {
        "stack": ""
      }
    },
    "2765": {
      "solution": {
        "enumeration": ""
      }
    },
    "2766": {
      "solution": {
        "sorting": ""
      }
    },
    "2767": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2768": {
      "solution": {
        "enumeration": ""
      }
    },
    "2769": {
      "solution": {
        "math": ""
      }
    },
    "2770": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2771": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2772": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2773": {
      "solution": {
        "tree": ""
      }
    },
    "2778": {
      "solution": {
        "enumeration": ""
      }
    },
    "2779": {
      "solution": {
        "sliding-window": "class Solution {\n    public int maximumBeauty(int[] nums, int k) {\n        int ans = 0;\n\n        Arrays.sort(nums);\n\n        for (int left = 0, right = 0; right < nums.length; ++right) {\n            while (nums[right] - nums[left] > 2 * k)\n                ++left;\n            ans = Math.max(ans, right - left + 1);\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "2780": {
      "solution": {
        "sorting": ""
      }
    },
    "2781": {
      "solution": {
        "sliding-window": "class Solution {\n    public int longestValidSubstring(String word, List<String> forbidden) {\n        int ans = 0;\n        Set<String> forbiddenSet = new HashSet<>(forbidden);\n\n        int right = word.length() - 1;\n        for (int left = word.length() - 1; left >= 0; --left) {\n            for (int end = left; end < Math.min(left + 10, right + 1); ++end)\n                if (forbiddenSet.contains(word.substring(left, end + 1))) {\n                    right = end - 1;\n                    break;\n                }\n            ans = Math.max(ans, right - left + 1);\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "2782": {
      "solution": {
        "union-find": ""
      }
    },
    "2783": {
      "solution": {
        "database": ""
      }
    },
    "2784": {
      "solution": {
        "sorting": ""
      }
    },
    "2785": {
      "solution": {
        "sorting": ""
      }
    },
    "2786": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2787": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2788": {
      "solution": {
        "string": ""
      }
    },
    "2789": {
      "solution": {
        "greedy": ""
      }
    },
    "2790": {
      "solution": {
        "greedy": ""
      }
    },
    "2791": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2792": {
      "solution": {
        "tree": ""
      }
    },
    "2798": {
      "solution": {
        "array": ""
      }
    },
    "2799": {
      "solution": {
        "sliding-window": "import java.util.HashSet;\nimport java.util.HashMap;\nimport java.util.Set;\n\nclass Solution {\n    public int countCompleteSubarrays(int[] nums) {\n        Set<Integer> uniqueElements = new HashSet<>();\n        for (int num : nums) {\n            uniqueElements.add(num);\n        }\n        int uniqueCount = uniqueElements.size();\n        int result = 0;\n        HashMap<Integer, Integer> windowCounts = new HashMap<>();\n        int left = 0;\n        \n        for (int right = 0; right < nums.length; right++) {\n            windowCounts.put(nums[right], windowCounts.getOrDefault(nums[right], 0) + 1);\n            \n            while (windowCounts.size() == uniqueCount) {\n                result += nums.length - right;\n                int leftNum = nums[left];\n                windowCounts.put(leftNum, windowCounts.get(leftNum) - 1);\n                if (windowCounts.get(leftNum) == 0) {\n                    windowCounts.remove(leftNum);\n                }\n                left++;\n            }\n        }\n        \n        return result;\n    }\n}\n"
      }
    },
    "2800": {
      "solution": {
        "enumeration": ""
      }
    },
    "2801": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2802": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2806": {
      "solution": {
        "math": ""
      }
    },
    "2807": {
      "solution": {
        "number-theory": ""
      }
    },
    "2808": {
      "solution": {
        "hash-table": ""
      }
    },
    "2809": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2810": {
      "solution": {
        "string": ""
      }
    },
    "2811": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2812": {
      "solution": {
        "union-find": ""
      }
    },
    "2813": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2814": {
      "solution": {
        "matrix": ""
      }
    },
    "2815": {
      "solution": {
        "hash-table": ""
      }
    },
    "2816": {
      "solution": {
        "stack": ""
      }
    },
    "2817": {
      "solution": {
        "ordered-set": "#include <cmath>\n#include <limits>\n#include <set>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        if (x == 0)\n            return 0; // Edge case: x cannot be zero as |i - j| >= x\n\n        int n = nums.size();\n        set<int> orderedSet;\n        int minDiff = numeric_limits<int>::max();\n\n        for (int i = x; i < n; ++i) {\n            orderedSet.insert(nums[i - x]);\n\n            // Find the closest numbers in the set\n            auto it = orderedSet.lower_bound(nums[i]);\n\n            // Check the number >= nums[i]\n            if (it != orderedSet.end()) {\n                minDiff = min(minDiff, abs(*it - nums[i]));\n            }\n\n            // Check the number < nums[i]\n            if (it != orderedSet.begin()) {\n                minDiff = min(minDiff, abs(*prev(it) - nums[i]));\n            }\n        }\n\n        return minDiff;\n    }\n};\n"
      }
    },
    "2818": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "2819": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2824": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2825": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2826": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2827": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2828": {
      "solution": {
        "string": ""
      }
    },
    "2829": {
      "solution": {
        "greedy": ""
      }
    },
    "2830": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2831": {
      "solution": {
        "sliding-window": "class Solution {\n  public int longestEqualSubarray(List<Integer> nums, int k) {\n    int ans = 0;\n    Map<Integer, Integer> count = new HashMap<>();\n\n    for (int left = 0, right = 0; right < nums.size(); ++right) {\n      ans = Math.max(ans, count.merge(nums.get(right), 1, Integer::sum));\n      while (right - left + 1 - k > ans)\n        count.merge(nums.get(left++), -1, Integer::sum);\n    }\n\n    return ans;\n  }\n}"
      }
    },
    "2832": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "2833": {
      "solution": {
        "counting": ""
      }
    },
    "2834": {
      "solution": {
        "greedy": ""
      }
    },
    "2835": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2836": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2837": {
      "solution": {
        "database": ""
      }
    },
    "2838": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2839": {
      "solution": {
        "string": ""
      }
    },
    "2840": {
      "solution": {
        "sorting": ""
      }
    },
    "2841": {
      "solution": {
        "sliding-window": "public class Solution {\n    public long maxSum(List<Integer> nums, int m, int k) {\n        long ans = 0;\n        long sum = 0;\n        Map<Integer, Integer> count = new HashMap<>();\n\n        for (int i = 0; i < nums.size(); ++i) {\n            sum += nums.get(i);\n            count.merge(nums.get(i), 1, Integer::sum);\n            if (i >= k) {\n              int numToRemove = nums.get(i - k);\n                sum -= numToRemove;\n                count.merge(numToRemove, -1, Integer::sum);\n                if (count.get(numToRemove) == 0)\n                    count.remove(numToRemove);\n            }\n            if (count.size() >= m)\n                ans = Math.max(ans, sum);\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "2842": {
      "solution": {
        "combinatorics": ""
      }
    },
    "2843": {
      "solution": {
        "enumeration": ""
      }
    },
    "2844": {
      "solution": {
        "enumeration": ""
      }
    },
    "2845": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2846": {
      "solution": {
        "strongly-connected-component": "class Solution {\n  public int[] minOperationsQueries(int n, int[][] edges, int[][] queries) {\n  int kMax = 26;\n  int m = (int) (Math.log(n) / Math.log(2)) + 1;\n    int[] ans = new int[queries.length];\n    List<Pair<Integer, Integer>>[] graph = new List[n];\n    int[][] jump = new int[n][m];\n    int[][] count = new int[n][];\n    int[] depth = new int[n];\n\n    for (int i = 0; i < n; ++i)\n      graph[i] = new ArrayList<>();\n\n    for (int[] edge : edges) {\n    int u = edge[0];\n    int v = edge[1];\n    int w = edge[2];\n      graph[u].add(new Pair<>(v, w));\n      graph[v].add(new Pair<>(u, w));\n    }\n\n    count[0] = new int[kMax + 1];\n    dfs(graph, 0, -1, 0, jump, count, depth);\n\n    for (int j = 1; j < m; ++j)\n      for (int i = 0; i < n; ++i)\n        jump[i][j] = jump[jump[i][j - 1]][j - 1];\n\n    for (int i = 0; i < queries.length; ++i) {\n    int u = queries[i][0];\n    int v = queries[i][1];\n    int lca = getLCA(u, v, jump, depth);\n    int numEdges = depth[u] + depth[v] - 2 * depth[lca];\n      int maxFreq = 0;\n      for (int j = 1; j <= kMax; ++j)\n        maxFreq = Math.max(maxFreq, count[u][j] + count[v][j] - 2 * count[lca][j]);\n      ans[i] = numEdges - maxFreq;\n    }\n\n    return ans;\n  }\n\n  private void dfs(List<Pair<Integer, Integer>>[] graph, int u, int prev, int d, int[][] jump,\n                   int[][] count, int[] depth) {\n    if (prev != -1)\n      jump[u][0] = prev;\n    depth[u] = d;\n    for (Pair<Integer, Integer> pair : graph[u]) {\n    int v = pair.getKey();\n    int w = pair.getValue();\n      if (v == prev)\n        continue;\n      count[v] = count[u].clone();\n      ++count[v][w];\n      dfs(graph, v, u, d + 1, jump, count, depth);\n    }\n  }\n\n  private int getLCA(int u, int v, int[][] jump, int[] depth) {\n    if (depth[u] > depth[v])\n      return getLCA(v, u, jump, depth);\n    for (int j = 0; j < jump[0].length; ++j)\n      if ((depth[v] - depth[u] >> j & 1) == 1)\n        v = jump[v][j];\n    if (u == v)\n      return u;\n    for (int j = jump[0].length - 1; j >= 0; --j)\n      if (jump[u][j] != jump[v][j]) {\n        u = jump[u][j];\n        v = jump[v][j];\n      }\n    return jump[v][0];\n  }\n}\n"
      }
    },
    "2847": {
      "solution": {
        "greedy": ""
      }
    },
    "2848": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2849": {
      "solution": {
        "math": ""
      }
    },
    "2850": {
      "solution": {
        "matrix": ""
      }
    },
    "2851": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2852": {
      "solution": {
        "union-find": ""
      }
    },
    "2853": {
      "solution": {
        "database": ""
      }
    },
    "2854": {
      "solution": {
        "database": ""
      }
    },
    "2855": {
      "solution": {
        "array": ""
      }
    },
    "2856": {
      "solution": {
        "two-pointers": "class Solution {\n    public int minLengthAfterRemovals(List<Integer> nums) {\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int x : nums) {\n            count.merge(x, 1, Integer::sum);\n        }\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\n        for (int x : count.values()) {\n            pq.offer(x);\n        }\n        int ans = nums.size();\n        while (pq.size() > 1) {\n            int x = pq.poll();\n            int y = pq.poll();\n            x--;\n            y--;\n            if (x > 0) {\n                pq.offer(x);\n            }\n            if (y > 0) {\n                pq.offer(y);\n            }\n            ans -= 2;\n        }\n        return ans;\n    }\n}"
      }
    },
    "2857": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2858": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2859": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2860": {
      "solution": {
        "enumeration": ""
      }
    },
    "2861": {
      "solution": {
        "array": "",
        "binary-search": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>>& composition, vector<int>& stock, vector<int>& cost) {\n        int left = 0, right = 1e9, result = 0;\n\n        auto canProduce = [&](int x, vector<int>& recipe) -> bool {\n            long long totalCost = 0;\n            for (int i = 0; i < n; ++i) {\n                // Calculate the additional units needed for material i\n                long long required = 1LL * recipe[i] * x;\n                long long needed = max(0LL, required - stock[i]);\n                totalCost += needed * cost[i];\n                if (totalCost > budget) return false; // Exceeds budget\n            }\n            return totalCost <= budget;\n        };\n\n        // Binary search to find the maximum number of alloys\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            bool possible = false;\n\n            // Check all machines to see if producing `mid` alloys is feasible\n            for (int i = 0; i < k; ++i) {\n                if (canProduce(mid, composition[i])) {\n                    possible = true;\n                    break;\n                }\n            }\n\n            if (possible) {\n                result = mid; // Update result to the maximum feasible `mid`\n                left = mid + 1; // Try for a larger number of alloys\n            } else {\n                right = mid - 1; // Try for a smaller number of alloys\n            }\n        }\n\n        return result;\n    }\n};\n"
      }
    },
    "2862": {
      "solution": {
        "number-theory": "class Solution {\n public:\n  long long maximumSum(vector<int>& nums) {\n    long ans = 0;\n\n    for (int oddPower = 1; oddPower <= nums.size(); ++oddPower) {\n      long sum = 0;\n      for (int num = 1; num * num * oddPower <= nums.size(); ++num)\n        sum += nums[oddPower * num * num - 1];\n      ans = max(ans, sum);\n    }\n\n    return ans;\n  }\n};"
      }
    },
    "2863": {
      "solution": {
        "sorting": ""
      }
    },
    "2864": {
      "solution": {
        "greedy": ""
      }
    },
    "2865": {
      "solution": {
        "monotonic-stack": "import java.util.*;\n\nclass Solution {\n    public long maximumSumOfHeights(int[] heights) {\n        int n = heights.length;\n        long[] maxSum = new long[n];\n        Deque<Integer> stack = new ArrayDeque<>(Arrays.asList(-1));\n        long sum = 0;\n\n        for (int i = 0; i < n; ++i) {\n            sum = process(stack, heights, i, sum);\n            maxSum[i] = sum;\n        }\n\n        stack = new ArrayDeque<>(Arrays.asList(n));\n        sum = 0;\n\n        for (int i = n - 1; i >= 0; --i) {\n            sum = process(stack, heights, i, sum);\n            maxSum[i] += sum - heights[i];\n        }\n\n        return Arrays.stream(maxSum).max().getAsLong();\n    }\n\n    private long process(Deque<Integer> stack, int[] heights, int i, long sum) {\n        while (stack.size() > 1 && heights[stack.peek()] > heights[i]) {\n            int j = stack.pop();\n            sum -= Math.abs(j - stack.peek()) * (long) heights[j];\n        }\n        sum += Math.abs(i - stack.peek()) * (long) heights[i];\n        stack.push(i);\n        return sum;\n    }\n}\n"
      }
    },
    "2866": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "2867": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2868": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2869": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2870": {
      "solution": {
        "counting": ""
      }
    },
    "2871": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2872": {
      "solution": {
        "tree": ""
      }
    },
    "2873": {
      "solution": {
        "array": ""
      }
    },
    "2874": {
      "solution": {
        "array": ""
      }
    },
    "2875": {
      "solution": {
        "sliding-window": "class Solution {\n    public int minSizeSubarray(int[] nums, int target) {\n      long sum = Arrays.stream(nums).asLongStream().sum();\n      int n = nums.length;\n      int remainingTarget = (int) (target % sum);\n      int repeatLength = (int) (target / sum) * n;\n        if (remainingTarget == 0)\n            return repeatLength;\n\n        int suffixPlusPrefixLength = n;\n        long prefix = 0;\n        HashMap<Long, Integer> prefixToIndex = new HashMap<>();\n        prefixToIndex.put(0L, -1);\n\n        for (int i = 0; i < 2 * n; ++i) {\n            prefix += nums[i % n];\n            if (prefixToIndex.containsKey(prefix - remainingTarget))\n                suffixPlusPrefixLength = Math.min(suffixPlusPrefixLength,\n                        i - prefixToIndex.get(prefix - remainingTarget));\n            prefixToIndex.put(prefix, i);\n        }\n\n        return suffixPlusPrefixLength == n ? -1 : repeatLength + suffixPlusPrefixLength;\n    }\n}"
      }
    },
    "2876": {
      "solution": {
        "graph": "class Solution {\n public:\n  vector<int> countVisitedNodes(vector<int>& edges) {\n    const int n = edges.size();\n    vector<int> ans(n);\n    vector<int> inDegrees(n);\n    vector<bool> seen(n);\n    queue<int> q;\n    stack<int> stack;\n\n    for (const int v : edges)\n      ++inDegrees[v];\n\n    // Perform topological sorting.\n    for (int i = 0; i < n; ++i)\n      if (inDegrees[i] == 0)\n        q.push(i);\n\n    // Push non-cyclic nodes to stack.\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      if (--inDegrees[edges[u]] == 0)\n        q.push(edges[u]);\n      stack.push(u);\n      seen[u] = true;\n    }\n\n    // Fill the length of cyclic nodes.\n    for (int i = 0; i < n; ++i)\n      if (!seen[i])\n        fillCycle(edges, i, seen, ans);\n\n    // Fill the length of non-cyclic nodes.\n    while (!stack.empty()) {\n      const int u = stack.top();\n      stack.pop();\n      ans[u] = ans[edges[u]] + 1;\n    }\n\n    return ans;\n  }\n\n private:\n  void fillCycle(const vector<int>& edges, int start, vector<bool>& seen,\n                 vector<int>& ans) {\n    int cycleLength = 0;\n    for (int u = start; !seen[u]; u = edges[u]) {\n      ++cycleLength;\n      seen[u] = true;\n    }\n    ans[start] = cycleLength;\n    for (int u = edges[start]; u != start; u = edges[u])\n      ans[u] = cycleLength;\n  }\n};"
      }
    },
    "2892": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2893": {
      "solution": {
        "database": ""
      }
    },
    "2894": {
      "solution": {
        "math": ""
      }
    },
    "2895": {
      "solution": {
        "greedy": ""
      }
    },
    "2896": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2897": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2898": {
      "solution": {
        "hash-table": ""
      }
    },
    "2899": {
      "solution": {
        "array": ""
      }
    },
    "2900": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2901": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2902": {
      "solution": {
        "sliding-window": "class Solution {\n    public int countSubMultisets(List<Integer> nums, int left, int right) {\n        int kMod = 1_000_000_007;\n        // dp[i] := the number of submultisets of `nums` with sum i\n        long[] dp = new long[right + 1];\n        dp[0] = 1;\n        Map<Integer, Integer> count = new HashMap<>();\n\n        for (int num : nums)\n            count.merge(num, 1, Integer::sum);\n\n        int zeros = count.containsKey(0) ? count.remove(0) : 0;\n\n        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\n            int num = entry.getKey();\n            int freq = entry.getValue();\n            long[] stride = dp.clone();\n            for (int i = num; i <= right; ++i)\n                stride[i] += stride[i - num];\n            for (int i = right; i > 0; --i)\n                if (i >= num * (freq + 1))\n                    dp[i] = (stride[i] - stride[i - num * (freq + 1)]) % kMod;\n                else\n                    dp[i] = stride[i] % kMod;\n        }\n\n        long ans = 0;\n        for (int i = left; i <= right; ++i)\n            ans = (ans + dp[i]) % kMod;\n        return (int) (((zeros + 1) * ans) % kMod);\n    }\n}"
      }
    },
    "2903": {
      "solution": {
        "two-pointers": "public class Solution {\n    public int[] findIndices(int[] nums, int indexDifference, int valueDifference) {\n        int n = nums.length;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + indexDifference; j < n; j++) {\n                if (Math.abs(i - j) >= indexDifference && Math.abs(nums[i] - nums[j]) >= valueDifference) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        \n        return new int[]{-1, -1};\n    }\n}\n"
      }
    },
    "2904": {
      "solution": {
        "sliding-window": "class Solution {\n    public String shortestBeautifulSubstring(String s, int k) {\n        int bestLeft = -1;\n        int minLength = s.length() + 1;\n        int ones = 0;\n\n        for (int left = 0, right = 0; right < s.length(); ++right) {\n            if (s.charAt(right) == '1')\n                ++ones;\n            while (ones == k) {\n                if (right - left + 1 < minLength) {\n                    bestLeft = left;\n                    minLength = right - left + 1;\n                } else if (right - left + 1 == minLength &&\n                        s.substring(left, left + minLength)\n                                .compareTo(s.substring(bestLeft, bestLeft + minLength)) < 0) {\n                    bestLeft = left;\n                }\n                if (s.charAt(left++) == '1')\n                    --ones;\n            }\n        }\n\n        return bestLeft == -1 ? \"\" : s.substring(bestLeft, bestLeft + minLength);\n    }\n}"
      }
    },
    "2905": {
      "solution": {
        "two-pointers": "class Solution {\n    public int[] findIndices(int[] nums, int indexDifference, int valueDifference) {\n        int minIndex = 0;\n        int maxIndex = 0;\n\n        for (int i = indexDifference; i < nums.length; ++i) {\n            if (nums[i - indexDifference] < nums[minIndex])\n                minIndex = i - indexDifference;\n            if (nums[i - indexDifference] > nums[maxIndex])\n                maxIndex = i - indexDifference;\n            if (nums[i] - nums[minIndex] >= valueDifference)\n                return new int[] { i, minIndex };\n            if (nums[maxIndex] - nums[i] >= valueDifference)\n                return new int[] { i, maxIndex };\n        }\n\n        return new int[] { -1, -1 };\n    }\n}"
      }
    },
    "2906": {
      "solution": {
        "matrix": ""
      }
    },
    "2907": {
      "solution": {
        "binary-indexed-tree": "class FenwickTree {\n public:\n  FenwickTree(int n) : vals(n + 1) {}\n\n  void maximize(int i, int val) {\n    while (i < vals.size()) {\n      vals[i] = max(vals[i], val);\n      i += lowbit(i);\n    }\n  }\n\n  int get(int i) const {\n    int res = 0;\n    while (i > 0) {\n      res = max(res, vals[i]);\n      i -= lowbit(i);\n    }\n    return res;\n  }\n\n private:\n  vector<int> vals;\n\n  static int lowbit(int i) {\n    return i & -i;\n  }\n};\n\nclass Solution {\n public:\n  int maxProfit(vector<int>& prices, vector<int>& profits) {\n    const int maxPrice = ranges::max(prices);\n    int ans = -1;\n    FenwickTree maxProfitTree1(maxPrice);\n    FenwickTree maxProfitTree2(maxPrice);\n\n    for (int i = 0; i < prices.size(); ++i) {\n      const int price = prices[i];\n      const int profit = profits[i];\n      // max(proftis[i])\n      const int maxProfit1 = maxProfitTree1.get(price - 1);\n      // max(proftis[i]) + max(profits[j])\n      const int maxProfit2 = maxProfitTree2.get(price - 1);\n      maxProfitTree1.maximize(price, profit);\n      if (maxProfit1 > 0)\n        maxProfitTree2.maximize(price, profit + maxProfit1);\n      if (maxProfit2 > 0)\n        ans = max(ans, profit + maxProfit2);\n    }\n\n    return ans;\n  }\n};"
      }
    },
    "2908": {
      "solution": {
        "array": ""
      }
    },
    "2909": {
      "solution": {
        "array": ""
      }
    },
    "2910": {
      "solution": {
        "greedy": ""
      }
    },
    "2911": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2912": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2913": {
      "solution": {
        "hash-table": ""
      }
    },
    "2914": {
      "solution": {
        "string": ""
      }
    },
    "2915": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2916": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2917": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2918": {
      "solution": {
        "greedy": ""
      }
    },
    "2919": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2920": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2921": {
      "solution": {
        "array": ""
      }
    },
    "2922": {
      "solution": {
        "database": ""
      }
    },
    "2923": {
      "solution": {
        "matrix": "class Solution {\n    public int findChampion(int[][] grid) {\n        int n = grid.length;\n        int ans = -1;\n        int count = 0;\n        int[] inDegrees = new int[n];\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                if (i == j)\n                    continue;\n                if (grid[i][j] == 1)\n                    ++inDegrees[j];\n                else\n                    ++inDegrees[i];\n            }\n\n        for (int i = 0; i < n; ++i)\n            if (inDegrees[i] == 0) {\n                ++count;\n                ans = i;\n            }\n\n        return count > 1 ? -1 : ans;\n    }\n}"
      }
    },
    "2924": {
      "solution": {
        "graph": ""
      }
    },
    "2925": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2926": {
      "solution": {
        "binary-indexed-tree": "class FenwickTree {\n public:\n  FenwickTree(int n) : vals(n + 1) {}\n\n    void maximize(int i, long val) {\n        while (i < vals.size()) {\n            vals[i] = max(vals[i], val);\n            i += lowbit(i);\n        }\n    }\n\n  long get(int i) const {\n    long res = 0;\n    while (i > 0) {\n      res = max(res, vals[i]);\n      i -= lowbit(i);\n    }\n    return res;\n  }\n\n private:\n  vector<long> vals;\n\n    static int lowbit(int i) {\n        return i & -i;\n    }\n};\n\nclass Solution {\n public:\n  long long maxBalancedSubsequenceSum(vector<int>& nums) {\n    long ans = LONG_MIN;\n\n    FenwickTree tree(nums.size());\n\n    for (const auto& [_, i] : getPairs(nums)) {\n      const long subseqSum = tree.get(i) + nums[i];\n      tree.maximize(i + 1, subseqSum);\n      ans = max(ans, subseqSum);\n    }\n\n    return ans;\n  }\n\n private:\n  vector<pair<int, int>> getPairs(const vector<int>& nums) {\n    vector<pair<int, int>> pairs;\n    for (int i = 0; i < nums.size(); ++i)\n      pairs.emplace_back(nums[i] - i, i);\n    ranges::sort(pairs);\n    return pairs;\n  }\n}\n;"
      }
    },
    "2927": {
      "solution": {
        "combinatorics": ""
      }
    },
    "2928": {
      "solution": {
        "combinatorics": ""
      }
    },
    "2929": {
      "solution": {
        "combinatorics": ""
      }
    },
    "2930": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2931": {
      "solution": {
        "matrix": ""
      }
    },
    "2932": {
      "solution": {
        "sliding-window": "class TrieNode {\n    public TrieNode[] children = new TrieNode[2];\n    public int min = Integer.MAX_VALUE;\n    public int max = Integer.MIN_VALUE;\n}\n\nclass BitTrie {\n    public BitTrie(int maxBit) {\n        this.maxBit = maxBit;\n    }\n\n    public void insert(int num) {\n        TrieNode node = root;\n        for (int i = maxBit; i >= 0; --i) {\n            int bit = (int) (num >> i & 1);\n            if (node.children[bit] == null)\n                node.children[bit] = new TrieNode();\n            node = node.children[bit];\n            node.min = Math.min(node.min, num);\n            node.max = Math.max(node.max, num);\n        }\n    }\n\n    public int getMaxXor(int x) {\n        int maxXor = 0;\n        TrieNode node = root;\n        for (int i = maxBit; i >= 0; --i) {\n            int bit = (int) (x >> i & 1);\n            int toggleBit = bit ^ 1;\n            if (node.children[toggleBit] != null && node.children[toggleBit].max > x &&\n                    node.children[toggleBit].min <= 2 * x) {\n                maxXor = maxXor | 1 << i;\n                node = node.children[toggleBit];\n            } else if (node.children[bit] != null) {\n                node = node.children[bit];\n            } else {\n                return 0;\n            }\n        }\n        return maxXor;\n    }\n\n    private int maxBit;\n    private TrieNode root = new TrieNode();\n}\n\nclass Solution {\n    public int maximumStrongPairXor(int[] nums) {\n        int maxNum = Arrays.stream(nums).max().getAsInt();\n        int maxBit = (int) (Math.log(maxNum) / Math.log(2));\n        int ans = 0;\n        BitTrie bitTrie = new BitTrie(maxBit);\n\n        for (int num : nums)\n            bitTrie.insert(num);\n\n        for (int num : nums)\n            ans = Math.max(ans, bitTrie.getMaxXor(num));\n\n        return ans;\n    }\n}"
      }
    },
    "2933": {
      "solution": {
        "sorting": ""
      }
    },
    "2934": {
      "solution": {
        "enumeration": ""
      }
    },
    "2935": {
      "solution": {
        "sliding-window": "class TrieNode {\n    public TrieNode[] children = new TrieNode[2];\n    public int min = Integer.MAX_VALUE;\n    public int max = Integer.MIN_VALUE;\n}\n\nclass BitTrie {\n    public BitTrie(int maxBit) {\n        this.maxBit = maxBit;\n    }\n\n    public void insert(int num) {\n        TrieNode node = root;\n        for (int i = maxBit; i >= 0; --i) {\n            int bit = (int) (num >> i & 1);\n            if (node.children[bit] == null)\n                node.children[bit] = new TrieNode();\n            node = node.children[bit];\n            node.min = Math.min(node.min, num);\n            node.max = Math.max(node.max, num);\n        }\n    }\n\n    public int getMaxXor(int x) {\n        int maxXor = 0;\n        TrieNode node = root;\n        for (int i = maxBit; i >= 0; --i) {\n            int bit = (int) (x >> i & 1);\n            int toggleBit = bit ^ 1;\n            if (node.children[toggleBit] != null && node.children[toggleBit].max > x &&\n                    node.children[toggleBit].min <= 2 * x) {\n                maxXor = maxXor | 1 << i;\n                node = node.children[toggleBit];\n            } else if (node.children[bit] != null) {\n                node = node.children[bit];\n            } else {\n                return 0;\n            }\n        }\n        return maxXor;\n    }\n\n    private int maxBit;\n    private TrieNode root = new TrieNode();\n}\n\nclass Solution {\n    public int maximumStrongPairXor(int[] nums) {\n        int maxNum = Arrays.stream(nums).max().getAsInt();\n        int maxBit = (int) (Math.log(maxNum) / Math.log(2));\n        int ans = 0;\n        BitTrie bitTrie = new BitTrie(maxBit);\n\n        for (int num : nums)\n            bitTrie.insert(num);\n\n        for (int num : nums)\n            ans = Math.max(ans, bitTrie.getMaxXor(num));\n\n        return ans;\n    }\n}"
      }
    },
    "2936": {
      "solution": {
        "interactive": ""
      }
    },
    "2937": {
      "solution": {
        "string": ""
      }
    },
    "2938": {
      "solution": {
        "two-pointers": ""
      }
    },
    "2939": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2940": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2941": {
      "solution": {
        "number-theory": ""
      }
    },
    "2942": {
      "solution": {
        "string": ""
      }
    },
    "2943": {
      "solution": {
        "sorting": ""
      }
    },
    "2944": {
      "solution": {
        "monotonic-queue": "class Solution {\n    public int minimumCoins(int[] prices) {\n      int n = prices.length;\n        int ans = Integer.MAX_VALUE;\n\n        Deque<Pair<Integer, Integer>> deque = new ArrayDeque<>();\n        deque.offerFirst(new Pair<>(0, n));\n\n        for (int i = n - 1; i >= 0; --i) {\n            while (!deque.isEmpty() && deque.peekFirst().getValue() > (i + 1) * 2)\n                deque.pollFirst();\n            ans = prices[i] + deque.peekFirst().getKey();\n            while (!deque.isEmpty() && deque.peekLast().getKey() >= ans)\n                deque.pollLast();\n            deque.offerLast(new Pair<>(ans, i));\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "2945": {
      "solution": {
        "monotonic-queue": "import java.util.Arrays;\n\nclass Solution {\n    public int findMaximumLength(int[] A) {\n        int n = A.length;\n        int[] pre = new int[n + 2], dp = new int[n + 1];\n        long[] acc = new long[n + 1];\n        for (int i = 1; i <= n; i++) {\n            acc[i] = acc[i - 1] + A[i - 1];\n        }\n        for (int i = 0, j = 1; j <= n; j++) {\n            i = Math.max(i, pre[j]);\n            dp[j] = dp[i] + 1;\n            int k = Arrays.binarySearch(acc, 2 * acc[j] - acc[i]);\n            if (k < 0) {\n                k = -k - 1;\n            }\n            pre[k] = j;\n        }\n        return dp[n];\n    }\n}\n"
      }
    },
    "2946": {
      "solution": {
        "matrix": ""
      }
    },
    "2947": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2948": {
      "solution": {
        "union-find": ""
      }
    },
    "2949": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2950": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2951": {
      "solution": {
        "enumeration": ""
      }
    },
    "2952": {
      "solution": {
        "greedy": ""
      }
    },
    "2953": {
      "solution": {
        "sliding-window": "class Solution {\n    public int countCompleteSubstrings(String word, int k) {\n      int uniqueLetters = word.chars().boxed().collect(Collectors.toSet()).size();\n        int ans = 0;\n\n        for (int windowSize = k; windowSize <= k * uniqueLetters && windowSize <= word.length(); windowSize += k) {\n            ans += countCompleteStrings(word, k, windowSize);\n        }\n\n        return ans;\n    }\n\n    private int countCompleteStrings(final String word, int k, int windowSize) {\n        int res = 0;\n        int countLetters = 0;\n        int[] count = new int[26];\n\n        for (int i = 0; i < word.length(); ++i) {\n            ++count[word.charAt(i) - 'a'];\n            ++countLetters;\n            if (i > 0 && Math.abs(word.charAt(i) - word.charAt(i - 1)) > 2) {\n                count = new int[26];\n                ++count[word.charAt(i) - 'a'];\n                countLetters = 1;\n            }\n            if (countLetters == windowSize + 1) {\n                --count[word.charAt(i - windowSize) - 'a'];\n                --countLetters;\n            }\n            if (countLetters == windowSize)\n                res += Arrays.stream(count).allMatch(freq -> freq == 0 || freq == k) ? 1 : 0;\n        }\n\n        return res;\n    }\n}"
      }
    },
    "2954": {
      "solution": {
        "combinatorics": ""
      }
    },
    "2955": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2956": {
      "solution": {
        "hash-table": ""
      }
    },
    "2957": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2958": {
      "solution": {
        "sliding-window": "class Solution {\n    public int maxSubarrayLength(int[] nums, int k) {\n        int ans = 0;\n        Map<Integer, Integer> count = new HashMap<>();\n\n        for (int left = 0, right = 0; right < nums.length; ++right) {\n            count.merge(nums[right], 1, Integer::sum);\n            while (count.get(nums[right]) == k + 1)\n                count.merge(nums[left++], -1, Integer::sum);\n            ans = Math.max(ans, right - left + 1);\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "2959": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2960": {
      "solution": {
        "array": ""
      }
    },
    "2961": {
      "solution": {
        "math": ""
      }
    },
    "2962": {
      "solution": {
        "sliding-window": "class Solution {\n    public long countSubarrays(int[] nums, int k) {\n      int maxNum = Arrays.stream(nums).max().getAsInt();\n        long ans = 0;\n        int count = 0;\n\n        for (int left = 0, right = 0; right < nums.length; ++right) {\n            if (nums[right] == maxNum)\n                ++count;\n            while (count == k)\n                if (nums[left++] == maxNum)\n                    --count;\n            ans += left;\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "2963": {
      "solution": {
        "combinatorics": ""
      }
    },
    "2964": {
      "solution": {
        "hash-table": ""
      }
    },
    "2965": {
      "solution": {
        "matrix": "class Solution {\n  public int[] findMissingAndRepeatedValues(int[][] grid) {\n    int n = grid.length;\n    int nSquared = n * n;\n    int[] count = new int[nSquared + 1];\n\n    for (int[] row : grid)\n      for (final int num : row)\n        ++count[num];\n\n    int repeated = -1;\n    int missing = -1;\n\n    for (int i = 1; i <= nSquared; ++i) {\n      if (count[i] == 2)\n        repeated = i;\n      if (count[i] == 0)\n        missing = i;\n    }\n\n    return new int[] {repeated, missing};\n  }\n}"
      }
    },
    "2966": {
      "solution": {
        "greedy": ""
      }
    },
    "2967": {
      "solution": {
        "greedy": ""
      }
    },
    "2968": {
      "solution": {
        "sliding-window": "class Solution {\n    public int maxFrequencyScore(int[] nums, long k) {\n        int ans = 0;\n        long cost = 0;\n\n        Arrays.sort(nums);\n\n        for (int left = 0, right = 0; right < nums.length; ++right) {\n            cost += nums[right] - nums[(left + right) / 2];\n            while (cost > k)\n                cost -= nums[(left + right + 1) / 2] - nums[left++];\n            ans = Math.max(ans, right - left + 1);\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "2969": {
      "solution": {
        "monotonic-queue": "class Solution {\n    public int minimumCoins(int[] prices) {\n        int n = prices.length;\n        Deque<Integer> q = new ArrayDeque<>();\n        for (int i = n; i > 0; --i) {\n            while (!q.isEmpty() && q.peek() > i * 2 + 1) {\n                q.poll();\n            }\n            if (i <= (n - 1) / 2) {\n                prices[i - 1] += prices[q.peek() - 1];\n            }\n            while (!q.isEmpty() && prices[q.peekLast() - 1] >= prices[i - 1]) {\n                q.pollLast();\n            }\n            q.offer(i);\n        }\n        return prices[0];\n    }\n}"
      }
    },
    "2970": {
      "solution": {
        "two-pointers": "class Solution {\n    public int incremovableSubarrayCount(int[] nums) {\n        int n = nums.length;\n        int count = 0;\n        \n        for (int start = 0; start < n; start++) {\n            for (int end = start + 1; end <= n; end++) {\n                if (isIncremovable(nums, start, end)) {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n    \n    private boolean isIncremovable(int[] nums, int start, int end) {\n        List<Integer> remaining = new ArrayList<>();\n        \n        for (int i = 0; i < nums.length; i++) {\n            if (i < start || i >= end) {\n                remaining.add(nums[i]);\n            }\n        }\n        \n        for (int i = 1; i < remaining.size(); i++) {\n            if (remaining.get(i) <= remaining.get(i - 1)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n"
      }
    },
    "2971": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2972": {
      "solution": {
        "two-pointers": "class Solution {\n    public long incremovableSubarrayCount(int[] nums) {\n        int n = nums.length;\n        int startIndex = getStartIndexOfSuffix(nums);\n        if (startIndex == 0)\n            return (long) n * (n + 1) / 2;\n\n        long ans = n - startIndex + 1;\n\n        for (int i = 0, j = startIndex; i < startIndex; ++i) {\n            if (i > 0 && nums[i] <= nums[i - 1])\n                break;\n            while (j < n && nums[i] >= nums[j])\n                ++j;\n            ans += n - j + 1;\n        }\n\n        return ans;\n    }\n\n    private int getStartIndexOfSuffix(int[] nums) {\n        for (int i = nums.length - 2; i >= 0; --i)\n            if (nums[i] >= nums[i + 1])\n                return i + 1;\n        return 0;\n    }\n\n    private int firstGreater(int[] A, int startIndex, int target) {\n        int i = Arrays.binarySearch(A, startIndex, A.length, target + 1);\n        return i < 0 ? -i - 1 : i;\n    }\n}"
      }
    },
    "2973": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2974": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "2975": {
      "solution": {
        "enumeration": ""
      }
    },
    "2976": {
      "solution": {
        "shortest-path": "class Solution {\npublic:\n    long long minimumCost(string source, string target, vector<char>& original,\n                          vector<char>& changed, vector<int>& cost) {\n        long ans = 0;\n        // dist[u][v] := the minimum distance to change ('a' + u) to ('a' + v)\n        vector<vector<long>> dist(26, vector<long>(26, LONG_MAX));\n\n        for (int i = 0; i < cost.size(); ++i) {\n            const int u = original[i] - 'a';\n            const int v = changed[i] - 'a';\n            dist[u][v] = min(dist[u][v], static_cast<long>(cost[i]));\n        }\n\n        for (int k = 0; k < 26; ++k)\n            for (int i = 0; i < 26; ++i)\n                if (dist[i][k] < LONG_MAX)\n                    for (int j = 0; j < 26; ++j)\n                        if (dist[k][j] < LONG_MAX)\n                            dist[i][j] =\n                                min(dist[i][j], dist[i][k] + dist[k][j]);\n\n        for (int i = 0; i < source.length(); ++i) {\n            if (source[i] == target[i])\n                continue;\n            const int u = source[i] - 'a';\n            const int v = target[i] - 'a';\n            if (dist[u][v] == LONG_MAX)\n                return -1;\n            ans += dist[u][v];\n        }\n\n        return ans;\n    }\n};"
      }
    },
    "2977": {
      "solution": {
        "shortest-path": "class Solution {\npublic:\n    long long minimumCost(string source, string target,\n                          vector<string>& original, vector<string>& changed,\n                          vector<int>& cost) {\n        const unordered_set<int> subLengths = getSubLengths(original);\n        const unordered_map<string, int> subToId =\n            getSubToId(original, changed);\n        const int subCount = subToId.size();\n        // dist[u][v] := the minimum distance to change the substring with id u\n        // to the substring with id v\n        vector<vector<long>> dist(subCount, vector<long>(subCount, LONG_MAX));\n        // dp[i] := the minimum cost to change the first i letters of `source`\n        // into `target`, leaving the suffix untouched\n        vector<long> dp(source.length() + 1, LONG_MAX);\n\n        for (int i = 0; i < cost.size(); ++i) {\n            const int u = subToId.at(original[i]);\n            const int v = subToId.at(changed[i]);\n            dist[u][v] = min(dist[u][v], static_cast<long>(cost[i]));\n        }\n\n        for (int k = 0; k < subCount; ++k)\n            for (int i = 0; i < subCount; ++i)\n                if (dist[i][k] < LONG_MAX)\n                    for (int j = 0; j < subCount; ++j)\n                        if (dist[k][j] < LONG_MAX)\n                            dist[i][j] =\n                                min(dist[i][j], dist[i][k] + dist[k][j]);\n\n        dp[0] = 0;\n\n        for (int i = 0; i < source.length(); ++i) {\n            if (dp[i] == LONG_MAX)\n                continue;\n            if (target[i] == source[i])\n                dp[i + 1] = min(dp[i + 1], dp[i]);\n            for (const int subLength : subLengths) {\n                if (i + subLength > source.length())\n                    continue;\n                const string subSource = source.substr(i, subLength);\n                const string subTarget = target.substr(i, subLength);\n                if (!subToId.contains(subSource) ||\n                    !subToId.contains(subTarget))\n                    continue;\n                const int u = subToId.at(subSource);\n                const int v = subToId.at(subTarget);\n                if (dist[u][v] < LONG_MAX)\n                    dp[i + subLength] =\n                        min(dp[i + subLength], dp[i] + dist[u][v]);\n            }\n        }\n\n        return dp[source.length()] == LONG_MAX ? -1 : dp[source.length()];\n    }\n\nprivate:\n    unordered_map<string, int> getSubToId(const vector<string>& original,\n                                          const vector<string>& changed) {\n        unordered_map<string, int> subToId;\n        for (const string& s : original)\n            if (!subToId.contains(s))\n                subToId[s] = subToId.size();\n        for (const string& s : changed)\n            if (!subToId.contains(s))\n                subToId[s] = subToId.size();\n        return subToId;\n    }\n\n    unordered_set<int> getSubLengths(const vector<string>& original) {\n        unordered_set<int> subLengths;\n        for (const string& s : original)\n            subLengths.insert(s.length());\n        return subLengths;\n    }\n};"
      }
    },
    "2978": {
      "solution": {
        "database": ""
      }
    },
    "2979": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2980": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2981": {
      "solution": {
        "sliding-window": "class Solution {\n    public int maximumLength(String s) {\n        int n = s.length();\n        int ans = -1;\n        int runningLen = 0;\n        char prevLetter = '@';\n        int[][] counts = new int[26][n + 1];\n\n        for (final char c : s.toCharArray())\n            if (c == prevLetter) {\n                ++counts[c - 'a'][++runningLen];\n            } else {\n                runningLen = 1;\n                ++counts[c - 'a'][runningLen];\n                prevLetter = c;\n            }\n\n        for (int[] count : counts) {\n            ans = Math.max(ans, getMaxFreq(count, n));\n        }\n\n        return ans;\n    }\n\n    private int getMaxFreq(int[] count, int maxFreq) {\n        int times = 0;\n        for (int freq = maxFreq; freq >= 1; --freq) {\n            times += count[freq];\n            if (times >= 3)\n                return freq;\n        }\n        return -1;\n    }\n}"
      }
    },
    "2982": {
      "solution": {
        "sliding-window": "class Solution {\n    public int maximumLength(String s) {\n        int n = s.length();\n        int ans = -1;\n        int runningLen = 0;\n        char prevLetter = '@';\n        int[][] counts = new int[26][n + 1];\n\n        for (final char c : s.toCharArray())\n            if (c == prevLetter) {\n                ++counts[c - 'a'][++runningLen];\n            } else {\n                runningLen = 1;\n                ++counts[c - 'a'][runningLen];\n                prevLetter = c;\n            }\n\n        for (int[] count : counts) {\n            ans = Math.max(ans, getMaxFreq(count, n));\n        }\n\n        return ans;\n    }\n\n    private int getMaxFreq(int[] count, int maxFreq) {\n        int times = 0;\n        for (int freq = maxFreq; freq >= 1; --freq) {\n            times += count[freq];\n            if (times >= 3)\n                return freq;\n        }\n        return -1;\n    }\n}"
      }
    },
    "2983": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "2984": {
      "solution": {
        "database": ""
      }
    },
    "2985": {
      "solution": {
        "database": ""
      }
    },
    "2986": {
      "solution": {
        "database": ""
      }
    },
    "2987": {
      "solution": {
        "database": ""
      }
    },
    "2988": {
      "solution": {
        "database": ""
      }
    },
    "2989": {
      "solution": {
        "database": ""
      }
    },
    "2990": {
      "solution": {
        "database": ""
      }
    },
    "2991": {
      "solution": {
        "database": ""
      }
    },
    "2992": {
      "solution": {
        "bitmask": "class Solution {\n    private int n;\n    private Integer[] f;\n\n    public int selfDivisiblePermutationCount(int n) {\n        this.n = n;\n        f = new Integer[1 << (n + 1)];\n        return dfs(0);\n    }\n\n    private int dfs(int mask) {\n        if (f[mask] != null) {\n            return f[mask];\n        }\n        int i = Integer.bitCount(mask) + 1;\n        if (i > n) {\n            return 1;\n        }\n        f[mask] = 0;\n        for (int j = 1; j <= n; ++j) {\n            if ((mask >> j & 1) == 0 && (i % j == 0 || j % i == 0)) {\n                f[mask] += dfs(mask | 1 << j);\n            }\n        }\n        return f[mask];\n    }\n}"
      }
    },
    "2993": {
      "solution": {
        "database": ""
      }
    },
    "2994": {
      "solution": {
        "database": ""
      }
    },
    "2995": {
      "solution": {
        "database": ""
      }
    },
    "2996": {
      "solution": {
        "sorting": ""
      }
    },
    "2997": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "2998": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "2999": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3000": {
      "solution": {
        "array": ""
      }
    },
    "3001": {
      "solution": {
        "enumeration": ""
      }
    },
    "3002": {
      "solution": {
        "greedy": ""
      }
    },
    "3003": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3004": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3005": {
      "solution": {
        "counting": ""
      }
    },
    "3006": {
      "solution": {
        "two-pointers": ""
      }
    },
    "3007": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3008": {
      "solution": {
        "two-pointers": ""
      }
    },
    "3009": {
      "solution": {
        "geometry": ""
      }
    },
    "3010": {
      "solution": {
        "enumeration": ""
      }
    },
    "3011": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "3012": {
      "solution": {
        "number-theory": "class Solution {\npublic:\n    int minimumArrayLength(vector<int>& nums) {\n        // Let the minimum number in the array `nums` be x.\n        // * If there exists any element nums[i] where nums[i] % x > 0, a new\n        //   minimum can be generated and all other numbers can be removed.\n        // * If not, count the frequency of x in `nums`. For each pair of x, a 0\n        // is\n        //   generated which cannot be removed. Therefore, the result will be\n        //   (frequency of x + 1) / 2.\n        const int minNum = ranges::min(nums);\n        if (ranges::any_of(nums,\n                           [minNum](int num) { return num % minNum > 0; }))\n            return 1;\n        return (ranges::count(nums, minNum) + 1) / 2;\n    }\n};"
      }
    },
    "3013": {
      "solution": {
        "sliding-window": "class Multiset {\n    public void add(int num) {\n        map.merge(num, 1, Integer::sum);\n        ++sz;\n    }\n\n    public void remove(int num) {\n        map.merge(num, -1, Integer::sum);\n        if (map.get(num) == 0)\n            map.remove(num);\n        --sz;\n    }\n\n    public int min() {\n        return map.firstEntry().getKey();\n    }\n\n    public int max() {\n        return map.lastEntry().getKey();\n    }\n\n    public int size() {\n        return sz;\n    }\n\n    public boolean contains(int num) {\n        return map.containsKey(num);\n    }\n\n    private TreeMap<Integer, Integer> map = new TreeMap<>();\n    private int sz = 0;\n}\n\nclass Solution {\n    public long minimumCost(int[] nums, int k, int dist) {\n        long windowSum = 0;\n        Multiset selected = new Multiset();\n        Multiset candidates = new Multiset();\n\n        for (int i = 1; i <= dist + 1; ++i) {\n            windowSum += nums[i];\n            selected.add(nums[i]);\n        }\n\n        windowSum = balance(windowSum, selected, candidates, k);\n        long minWindowSum = windowSum;\n\n        for (int i = dist + 2; i < nums.length; ++i) {\n          int outOfScope = nums[i - dist - 1];\n            if (selected.contains(outOfScope)) {\n                windowSum -= outOfScope;\n                selected.remove(outOfScope);\n            } else {\n                candidates.remove(outOfScope);\n            }\n            if (nums[i] < selected.max()) {\n                windowSum += nums[i];\n                selected.add(nums[i]);\n            } else {\n                candidates.add(nums[i]);\n            }\n            windowSum = balance(windowSum, selected, candidates, k);\n            minWindowSum = Math.min(minWindowSum, windowSum);\n        }\n\n        return nums[0] + minWindowSum;\n    }\n\n    private long balance(long windowSum, Multiset selected, Multiset candidates, int k) {\n        while (selected.size() < k - 1) {\n          int minCandidate = candidates.min();\n            windowSum += minCandidate;\n            selected.add(minCandidate);\n            candidates.remove(minCandidate);\n        }\n        while (selected.size() > k - 1) {\n          int maxSelected = selected.max();\n            windowSum -= maxSelected;\n            selected.remove(maxSelected);\n            candidates.add(maxSelected);\n        }\n        return windowSum;\n    }\n}"
      }
    },
    "3014": {
      "solution": {
        "greedy": ""
      }
    },
    "3015": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "3016": {
      "solution": {
        "counting": ""
      }
    },
    "3017": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "3018": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3019": {
      "solution": {
        "string": ""
      }
    },
    "3020": {
      "solution": {
        "enumeration": ""
      }
    },
    "3021": {
      "solution": {
        "math": ""
      }
    },
    "3022": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "3023": {
      "solution": {
        "sliding-window": "**\n * Definition for an infinite stream.\n * class InfiniteStream {\n *     public InfiniteStream(int[] bits);\n *     public int next();\n * }\n */\nclass Solution {\n    public int findPattern(InfiniteStream infiniteStream, int[] pattern) {\n        long a = 0, b = 0;\n        int m = pattern.length;\n        int half = m >> 1;\n        long mask1 = (1L << half) - 1;\n        long mask2 = (1L << (m - half)) - 1;\n        for (int i = 0; i < half; ++i) {\n            a |= (long) pattern[i] << (half - 1 - i);\n        }\n        for (int i = half; i < m; ++i) {\n            b |= (long) pattern[i] << (m - 1 - i);\n        }\n        long x = 0, y = 0;\n        for (int i = 1;; ++i) {\n            int v = infiniteStream.next();\n            y = y << 1 | v;\n            v = (int) ((y >> (m - half)) & 1);\n            y &= mask2;\n            x = x << 1 | v;\n            x &= mask1;\n            if (i >= m && a == x && b == y) {\n                return i - m;\n            }\n        }\n    }\n}"
      }
    },
    "3024": {
      "solution": {
        "sorting": ""
      }
    },
    "3025": {
      "solution": {
        "geometry": "class Solution {\n public:\n  int numberOfPairs(vector<vector<int>>& points) {\n    int ans = 0;\n\n    ranges::sort(points, [](const vector<int>& a, const vector<int>& b) {\n      return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);\n    });\n\n    for (int i = 0; i < points.size(); ++i) {\n      int maxY = INT_MIN;\n      for (int j = i + 1; j < points.size(); ++j)\n        if (points[i][1] >= points[j][1] && points[j][1] > maxY) {\n          ++ans;\n          maxY = points[j][1];\n        }\n    }\n\n    return ans;\n  }\n};"
      }
    },
    "3026": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "3027": {
      "solution": {
        "geometry": ""
      }
    },
    "3028": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "3029": {
      "solution": {
        "rolling-hash": ""
      }
    },
    "3030": {
      "solution": {
        "matrix": ""
      }
    },
    "3031": {
      "solution": {
        "rolling-hash": ""
      }
    },
    "3032": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3033": {
      "solution": {
        "matrix": ""
      }
    },
    "3034": {
      "solution": {
        "rolling-hash": "class Solution {\npublic:\n    int countMatchingSubarrays(vector<int>& nums, vector<int>& pattern) {\n        const vector<int> numsPattern = getNumsPattern(nums);\n        return kmp(numsPattern, pattern);\n    }\n\nprivate:\n    int getNum(int a, int b) {\n        if (a < b)\n            return 1;\n        if (a > b)\n            return -1;\n        return 0;\n    }\n\n    vector<int> getNumsPattern(const vector<int>& nums) {\n        vector<int> numsPattern;\n        for (int i = 1; i < nums.size(); ++i)\n            numsPattern.push_back(getNum(nums[i - 1], nums[i]));\n        return numsPattern;\n    }\n\n    int kmp(const vector<int>& nums, const vector<int>& pattern) {\n        const vector<int> lps = getLPS(pattern);\n        int res = 0;\n        int i = 0; \n        int j = 0; \n        while (i < nums.size()) {\n            if (nums[i] == pattern[j]) {\n                ++i;\n                ++j;\n                if (j == pattern.size()) {\n                    ++res;\n                    j = lps[j - 1];\n                }\n            }\n            else if (j > 0) {\n                j = lps[j - 1];\n            } else {\n                ++i;\n            }\n        }\n        return res;\n    }\n\n    vector<int> getLPS(const vector<int>& pattern) {\n        vector<int> lps(pattern.size());\n        for (int i = 1, j = 0; i < pattern.size(); ++i) {\n            while (j > 0 && pattern[j] != pattern[i])\n                j = lps[j - 1];\n            if (pattern[i] == pattern[j])\n                lps[i] = ++j;\n        }\n        return lps;\n    }\n};"
      }
    },
    "3035": {
      "solution": {
        "counting": ""
      }
    },
    "3036": {
      "solution": {
        "rolling-hash": "class Solution {\npublic:\n    int countMatchingSubarrays(vector<int>& nums, vector<int>& pattern) {\n        const vector<int> numsPattern = getNumsPattern(nums);\n        return kmp(numsPattern, pattern);\n    }\n\nprivate:\n    int getNum(int a, int b) {\n        if (a < b)\n            return 1;\n        if (a > b)\n            return -1;\n        return 0;\n    }\n\n    vector<int> getNumsPattern(const vector<int>& nums) {\n        vector<int> numsPattern;\n        for (int i = 1; i < nums.size(); ++i)\n            numsPattern.push_back(getNum(nums[i - 1], nums[i]));\n        return numsPattern;\n    }\n\n    int kmp(const vector<int>& nums, const vector<int>& pattern) {\n        const vector<int> lps = getLPS(pattern);\n        int res = 0;\n        int i = 0;\n        int j = 0;\n        while (i < nums.size()) {\n            if (nums[i] == pattern[j]) {\n                ++i;\n                ++j;\n                if (j == pattern.size()) {\n                    ++res;\n                    j = lps[j - 1];\n                }\n            } else if (j > 0) {\n                j = lps[j - 1];\n            } else {\n                ++i;\n            }\n        }\n        return res;\n    }\n\n    vector<int> getLPS(const vector<int>& pattern) {\n        vector<int> lps(pattern.size());\n        for (int i = 1, j = 0; i < pattern.size(); ++i) {\n            while (j > 0 && pattern[j] != pattern[i])\n                j = lps[j - 1];\n            if (pattern[i] == pattern[j])\n                lps[i] = ++j;\n        }\n        return lps;\n    }\n};"
      }
    },
    "3037": {
      "solution": {
        "sliding-window": "/**\n * Definition for an infinite stream.\n * class InfiniteStream {\n *   public InfiniteStream(int[] bits);\n *   public int next();\n * }\n */\n\nclass Solution {\n  public int findPattern(InfiniteStream stream, int[] pattern) {\n    int[] lps = getLPS(pattern);\n    int i = 0;  \n    int j = 0;   \n    int bit = 0;\n    boolean readNext = false;\n    while (true) {\n      if (!readNext) {\n        bit = stream.next();\n        readNext = true;\n      }\n      if (bit == pattern[j]) {\n        ++i;\n        readNext = false;\n        ++j;\n        if (j == pattern.length)\n          return i - j;\n      }\n      else if (j > 0) {\n        j = lps[j - 1];\n      } else {\n        ++i;\n        readNext = false;\n      }\n    }\n  }\n\n\n  private int[] getLPS(int[] pattern) {\n    int[] lps = new int[pattern.length];\n    int j = 0;\n    for (int i = 1; i < pattern.length; ++i) {\n      while (j > 0 && pattern[j] != pattern[i])\n        j = lps[j - 1];\n      if (pattern[i] == pattern[j])\n        lps[i] = ++j;\n    }\n    return lps;\n  }\n}"
      }
    },
    "3038": {
      "solution": {
        "array": ""
      }
    },
    "3039": {
      "solution": {
        "counting": ""
      }
    },
    "3040": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3041": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3042": {
      "solution": {
        "trie": "struct TrieNode {\n    unordered_map<int, shared_ptr<TrieNode>> children;\n    int count = 0;\n};\n\nclass Trie {\npublic:\n    int insert(const string& word) {\n        const int n = word.length();\n        int count = 0;\n        shared_ptr<TrieNode> node = root;\n        for (int i = 0; i < n; ++i) {\n            const int j = hash(word[i], word[n - 1 - i]);\n            if (node->children[j] == nullptr)\n                node->children[j] = make_shared<TrieNode>();\n            node = node->children[j];\n            count += node->count;\n        }\n        ++node->count;\n        return count;\n    }\n\nprivate:\n    shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n    static int hash(char prefix, char suffix) {\n        return 26 * (prefix - 'a') + (suffix - 'a');\n    }\n};\n\nclass Solution {\npublic:\n    long long countPrefixSuffixPairs(vector<string>& words) {\n        long ans = 0;\n        Trie trie;\n\n        for (const string& word : words)\n            ans += trie.insert(word);\n\n        return ans;\n    }\n};"
      }
    },
    "3043": {
      "solution": {
        "trie": ""
      }
    },
    "3044": {
      "solution": {
        "matrix": ""
      }
    },
    "3045": {
      "solution": {
        "rolling-hash": ""
      }
    },
    "3046": {
      "solution": {
        "counting": "class Solution {\npublic:\n    bool isPossibleToSplit(vector<int>& nums) {\n        constexpr int kMax = 100;\n        vector<int> count(kMax + 1);\n\n        for (const int num : nums)\n            ++count[num];\n\n        return ranges::all_of(count, [](int freq) { return freq <= 2; });\n    }\n};"
      }
    },
    "3047": {
      "solution": {
        "geometry": "class Solution {\n public:\n  long long largestSquareArea(vector<vector<int>>& bottomLeft,\n                              vector<vector<int>>& topRight) {\n    int minSide = 0;\n\n    for (int i = 0; i < bottomLeft.size(); ++i)\n      for (int j = i + 1; j < bottomLeft.size(); ++j) {\n        const int ax1 = bottomLeft[i][0];\n        const int ay1 = bottomLeft[i][1];\n        const int ax2 = topRight[i][0];\n        const int ay2 = topRight[i][1];\n        const int bx1 = bottomLeft[j][0];\n        const int by1 = bottomLeft[j][1];\n        const int bx2 = topRight[j][0];\n        const int by2 = topRight[j][1];\n        const int overlapX = min(ax2, bx2) - max(ax1, bx1);\n        const int overlapY = min(ay2, by2) - max(ay1, by1);\n        minSide = max(minSide, min(overlapX, overlapY));\n      }\n\n    return static_cast<long>(minSide) * minSide;\n  }\n};"
      }
    },
    "3048": {
      "solution": {
        "array": ""
      }
    },
    "3049": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "3050": {
      "solution": {
        "database": ""
      }
    },
    "3051": {
      "solution": {
        "database": ""
      }
    },
    "3052": {
      "solution": {
        "database": ""
      }
    },
    "3053": {
      "solution": {
        "database": ""
      }
    },
    "3054": {
      "solution": {
        "database": ""
      }
    },
    "3055": {
      "solution": {
        "database": ""
      }
    },
    "3056": {
      "solution": {
        "database": ""
      }
    },
    "3057": {
      "solution": {
        "database": ""
      }
    },
    "3058": {
      "solution": {
        "database": ""
      }
    },
    "3059": {
      "solution": {
        "database": ""
      }
    },
    "3060": {
      "solution": {
        "database": ""
      }
    },
    "3061": {
      "solution": {
        "database": ""
      }
    },
    "3062": {
      "solution": {
        "linked-list": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    string gameResult(ListNode* head) {\n        int odd = 0, even = 0;\n        for (; head != nullptr; head = head->next->next) {\n            int a = head->val;\n            int b = head->next->val;\n            odd += a < b;\n            even += a > b;\n        }\n        if (odd > even) {\n            return \"Odd\";\n        }\n        if (odd < even) {\n            return \"Even\";\n        }\n        return \"Tie\";\n    }\n};"
      }
    },
    "3063": {
      "solution": {
        "linked-list": ""
      }
    },
    "3064": {
      "solution": {
        "interactive": ""
      }
    },
    "3065": {
      "solution": {
        "array": ""
      }
    },
    "3066": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "3067": {
      "solution": {
        "tree": "class Solution {\npublic:\n    vector<int> countPairsOfConnectableServers(vector<vector<int>>& edges,\n                                               int signalSpeed) {\n        const int n = edges.size() + 1;\n        vector<int> ans;\n        vector<vector<pair<int, int>>> tree(n);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            const int w = edge[2];\n            tree[u].emplace_back(v, w);\n            tree[v].emplace_back(u, w);\n        }\n\n        for (int i = 0; i < n; ++i)\n            ans.push_back(connectablePairsRootedAt(tree, i, signalSpeed));\n\n        return ans;\n    }\n\nprivate:\n    int connectablePairsRootedAt(const vector<vector<pair<int, int>>>& tree,\n                                 int u, int signalSpeed) {\n        int pairs = 0;\n        int count = 0;\n        for (const auto& [v, w] : tree[u]) {\n            const int childCount = dfs(tree, v, u, w, signalSpeed);\n            pairs += count * childCount;\n            count += childCount;\n        }\n        return pairs;\n    }\n\n    int dfs(const vector<vector<pair<int, int>>>& tree, int u, int prev,\n            int dist, int signalSpeed) {\n        int count = 0;\n        for (const auto& [v, w] : tree[u])\n            if (v != prev)\n                count += dfs(tree, v, u, dist + w, signalSpeed);\n        return (dist % signalSpeed == 0 ? 1 : 0) + count;\n    }\n};"
      }
    },
    "3068": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3069": {
      "solution": {
        "array": ""
      }
    },
    "3070": {
      "solution": {
        "matrix": ""
      }
    },
    "3071": {
      "solution": {
        "matrix": ""
      }
    },
    "3072": {
      "solution": {
        "array": ""
      }
    },
    "3073": {
      "solution": {
        "ordered-set": "class Solution {\npublic:\n    int maximumTripletValue(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> right(n, nums.back());\n        for (int i = n - 2; ~i; --i) {\n            right[i] = max(nums[i], right[i + 1]);\n        }\n        set<int> ts;\n        ts.insert(nums[0]);\n        int ans = 0;\n        for (int j = 1; j < n - 1; ++j) {\n            if (right[j + 1] > nums[j]) {\n                auto it = ts.lower_bound(nums[j]);\n                if (it != ts.begin()) {\n                    --it;\n                    ans = max(ans, *it - nums[j] + right[j + 1]);\n                }\n            }\n            ts.insert(nums[j]);\n        }\n        return ans;\n    }\n};"
      }
    },
    "3074": {
      "solution": {
        "greedy": ""
      }
    },
    "3075": {
      "solution": {
        "greedy": ""
      }
    },
    "3076": {
      "solution": {
        "trie": ""
      }
    },
    "3077": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "3078": {
      "solution": {
        "matrix": ""
      }
    },
    "3079": {
      "solution": {
        "math": ""
      }
    },
    "3080": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "3081": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "3082": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3083": {
      "solution": {
        "hash-table": ""
      }
    },
    "3084": {
      "solution": {
        "counting": ""
      }
    },
    "3085": {
      "solution": {
        "counting": ""
      }
    },
    "3086": {
      "solution": {
        "sliding-window": "class Solution {\n  public long minimumMoves(int[] nums, int k, int maxChanges) {\n    int kNumOfIndicesWithinOneDistance = 3;\n    long ans = Long.MAX_VALUE;\n    List<Integer> oneIndices = new ArrayList<>(); \n    List<Long> prefix = new ArrayList<>();       \n    prefix.add(0L);\n\n    for (int i = 0; i < nums.length; ++i)\n      if (nums[i] == 1)\n        oneIndices.add(i);\n\n    for (int oneIndex : oneIndices)\n      prefix.add(prefix.get(prefix.size() - 1) + oneIndex);\n\n    int minOnesByTwo = Math.max(0, k - maxChanges);\n    int maxOnesByTwo =\n        Math.min(k, Math.min(minOnesByTwo + kNumOfIndicesWithinOneDistance, oneIndices.size()));\n\n    for (int onesByTwo = minOnesByTwo; onesByTwo <= maxOnesByTwo; ++onesByTwo)\n      for (int left = 0; left + onesByTwo < prefix.size(); ++left) {\n        int right = left + onesByTwo;\n        long cost1 = (k - onesByTwo) * 2;\n        long cost2 = (prefix.get(right) - prefix.get((left + right) / 2)) -\n                           (prefix.get((left + right + 1) / 2) - prefix.get(left));\n        ans = Math.min(ans, cost1 + cost2);\n      }\n\n    return ans;\n  }\n}"
      }
    },
    "3087": {
      "solution": {
        "database": ""
      }
    },
    "3088": {
      "solution": {
        "greedy": ""
      }
    },
    "3089": {
      "solution": {
        "database": ""
      }
    },
    "3090": {
      "solution": {
        "sliding-window": "class Solution {\n    public int maximumLengthSubstring(String s) {\n        int ans = 0;\n        int[] count = new int[26];\n\n        for (int left = 0, right = 0; right < s.length(); ++right) {\n            ++count[s.charAt(right) - 'a'];\n            while (count[s.charAt(right) - 'a'] > 2)\n                --count[s.charAt(left++) - 'a'];\n            ans = Math.max(ans, right - left + 1);\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "3091": {
      "solution": {
        "enumeration": ""
      }
    },
    "3092": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "3093": {
      "solution": {
        "trie": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  TrieNode() : children(26) {}\n  int length = INT_MAX;\n  int index = -1;\n};\n\nclass Solution {\n public:\n  vector<int> stringIndices(vector<string>& wordsContainer,\n                            vector<string>& wordsQuery) {\n    vector<int> ans;\n    int minIndex = 0;\n\n    for (int i = 0; i < wordsContainer.size(); ++i) {\n      insert(wordsContainer[i], i);\n      if (wordsContainer[i].length() < wordsContainer[minIndex].length())\n        minIndex = i;\n    }\n\n    for (const string& query : wordsQuery) {\n      const int index = search(query);\n      ans.push_back(index == -1 ? minIndex : index);\n    }\n\n    return ans;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  void insert(const string& word, int index) {\n    shared_ptr<TrieNode> node = root;\n    for (int i = word.length() - 1; i >= 0; --i) {\n      const int j = word[i] - 'a';\n      if (node->children[j] == nullptr)\n        node->children[j] = make_shared<TrieNode>();\n      node = node->children[j];\n      if (node->length > word.length()) {\n        node->length = word.length();\n        node->index = index;\n      }\n    }\n  }\n\n  int search(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (int i = word.length() - 1; i >= 0; --i) {\n      const int j = word[i] - 'a';\n      if (node->children[j] == nullptr)\n        return node->index;\n      node = node->children[j];\n    }\n    return node->index;\n  }\n};"
      }
    },
    "3094": {
      "solution": {
        "interactive": ""
      }
    },
    "3095": {
      "solution": {
        "sliding-window": "class Solution {\n    public int minimumSubarrayLength(int[] nums, int k) {\n        int kMax = 50;\n        int n = nums.length;\n        int ans = n + 1;\n        int ors = 0;\n        int[] count = new int[kMax + 1];\n\n        for (int left = 0, right = 0; right < n; ++right) {\n            ors = orNum(ors, nums[right], count);\n            while (ors >= k && left <= right) {\n                ans = Math.min(ans, right - left + 1);\n                ors = undoOrNum(ors, nums[left], count);\n                ++left;\n            }\n        }\n\n        return (ans == n + 1) ? -1 : ans;\n    }\n\n    private static final int kMaxBit = 30;\n\n    private int orNum(int ors, int num, int[] count) {\n        for (int i = 0; i < kMaxBit; ++i)\n            if ((num >> i & 1) == 1 && ++count[i] == 1)\n                ors += 1 << i;\n        return ors;\n    }\n\n    private int undoOrNum(int ors, int num, int[] count) {\n        for (int i = 0; i < kMaxBit; ++i)\n            if ((num >> i & 1) == 1 && --count[i] == 0)\n                ors -= 1 << i;\n        return ors;\n    }\n}"
      }
    },
    "3096": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "3097": {
      "solution": {
        "sliding-window": "class Solution {\n    public int minimumSubarrayLength(int[] nums, int k) {\n        int kMax = 50;\n        int n = nums.length;\n        int ans = n + 1;\n        int ors = 0;\n        int[] count = new int[kMax + 1];\n\n        for (int left = 0, right = 0; right < n; ++right) {\n            ors = orNum(ors, nums[right], count);\n            while (ors >= k && left <= right) {\n                ans = Math.min(ans, right - left + 1);\n                ors = undoOrNum(ors, nums[left], count);\n                ++left;\n            }\n        }\n\n        return (ans == n + 1) ? -1 : ans;\n    }\n\n    private static final int kMaxBit = 30;\n\n    private int orNum(int ors, int num, int[] count) {\n        for (int i = 0; i < kMaxBit; ++i)\n            if ((num >> i & 1) == 1 && ++count[i] == 1)\n                ors += 1 << i;\n        return ors;\n    }\n\n    private int undoOrNum(int ors, int num, int[] count) {\n        for (int i = 0; i < kMaxBit; ++i)\n            if ((num >> i & 1) == 1 && --count[i] == 0)\n                ors -= 1 << i;\n        return ors;\n    }\n}"
      }
    },
    "3098": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3099": {
      "solution": {
        "math": ""
      }
    },
    "3100": {
      "solution": {
        "math": ""
      }
    },
    "3101": {
      "solution": {
        "math": ""
      }
    },
    "3102": {
      "solution": {
        "ordered-set": ""
      }
    },
    "3103": {
      "solution": {
        "database": ""
      }
    },
    "3104": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "3105": {
      "solution": {
        "array": ""
      }
    },
    "3106": {
      "solution": {
        "greedy": ""
      }
    },
    "3107": {
      "solution": {
        "greedy": ""
      }
    },
    "3108": {
      "solution": {
        "union-find": "class UnionFind {\npublic:\n    // 2^17 - 1 is the minimum number in the form 2^x - 1 > 10^5.\n    UnionFind(int n) : id(n), rank(n), weight(n, (1 << 17) - 1) {\n        iota(id.begin(), id.end(), 0);\n    }\n\n    void unionByRank(int u, int v, int w) {\n        const int i = find(u);\n        const int j = find(v);\n        const int newWeight = weight[i] & weight[j] & w;\n        weight[i] = newWeight;\n        weight[j] = newWeight;\n        if (i == j)\n            return;\n        if (rank[i] < rank[j]) {\n            id[i] = j;\n        } else if (rank[i] > rank[j]) {\n            id[j] = i;\n        } else {\n            id[i] = j;\n            ++rank[j];\n        }\n    }\n\n    int getMinCost(int u, int v) {\n        if (u == v)\n            return 0;\n        const int i = find(u);\n        const int j = find(v);\n        return i == j ? weight[i] : -1;\n    }\n\nprivate:\n    vector<int> id;\n    vector<int> rank;\n    vector<int> weight;\n\n    int find(int u) { return id[u] == u ? u : id[u] = find(id[u]); }\n};\n\nclass Solution {\npublic:\n    vector<int> minimumCost(int n, vector<vector<int>>& edges,\n                            vector<vector<int>>& query) {\n        vector<int> ans;\n        UnionFind uf(n);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            const int w = edge[2];\n            uf.unionByRank(u, v, w);\n        }\n\n        for (const vector<int>& q : query) {\n            const int u = q[0];\n            const int v = q[1];\n            ans.push_back(uf.getMinCost(u, v));\n        }\n\n        return ans;\n    }\n};"
      }
    },
    "3109": {
      "solution": {
        "merge-sort": "class FenwickTree {\n  public FenwickTree(int n) {\n    sums = new int[n + 1];\n  }\n\n  public void add(int i, int delta) {\n    while (i < sums.length) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  public int get(int i) {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n\n  private int[] sums;\n\n  private static int lowbit(int i) {\n    return i & -i;\n  }\n}\n\nclass Solution {\n  public int getPermutationIndex(int[] perm) {\n  int kMod = 1_000_000_007;\n  int n = perm.length;\n    int ans = 0;\n    FenwickTree tree = new FenwickTree(n);\n    int[] fact = new int[n + 1]; \n    Arrays.fill(fact, 1);\n\n    for (int i = 2; i <= n; ++i)\n      fact[i] = (int) ((fact[i - 1] * (long) i) % kMod);\n\n    for (int i = 0; i < n; ++i) {\n    int num = perm[i];\n    int unusedNums = num - 1 - tree.get(num - 1);\n    int suffixLength = fact[n - 1 - i];\n      ans = (int) ((ans + unusedNums * (long) suffixLength) % kMod);\n      tree.add(num, 1);\n    }\n\n    return ans;\n  }\n}"
      }
    },
    "3110": {
      "solution": {
        "string": ""
      }
    },
    "3111": {
      "solution": {
        "greedy": ""
      }
    },
    "3112": {
      "solution": {
        "shortest-path": "class Solution {\npublic:\n    vector<int> minimumTime(int n, vector<vector<int>>& edges,\n                            vector<int>& disappear) {\n        vector<vector<pair<int, int>>> graph(n);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            const int w = edge[2];\n            graph[u].emplace_back(v, w);\n            graph[v].emplace_back(u, w);\n        }\n\n        return dijkstra(graph, 0, disappear);\n    }\n\nprivate:\n    vector<int> dijkstra(const vector<vector<pair<int, int>>>& graph, int src,\n                         const vector<int>& disappear) {\n        vector<int> dist(graph.size(), INT_MAX);\n\n        dist[src] = 0;\n        using P = pair<int, int>; // (d, u)\n        priority_queue<P, vector<P>, greater<>> minHeap;\n        minHeap.emplace(dist[src], src);\n\n        while (!minHeap.empty()) {\n            const auto [d, u] = minHeap.top();\n            minHeap.pop();\n            if (d > dist[u])\n                continue;\n            for (const auto& [v, w] : graph[u])\n                if (d + w < disappear[v] && d + w < dist[v]) {\n                    dist[v] = d + w;\n                    minHeap.push({dist[v], v});\n                }\n        }\n\n        for (int& d : dist)\n            if (d == INT_MAX)\n                d = -1;\n\n        return dist;\n    }\n};"
      }
    },
    "3113": {
      "solution": {
        "monotonic-stack": "class Solution {\n    public long numberOfSubarrays(int[] nums) {\n        Deque<int[]> stack = new ArrayDeque<>();\n        long ans = 0;\n        int top = -1;\n\n        for (int num : nums) {\n            while (!stack.isEmpty() && stack.peek()[0] < num)\n                stack.pop();\n            if (stack.isEmpty() || stack.peek()[0] != num)\n                stack.push(new int[] { num, 0 });\n            ans += ++stack.peek()[1];\n        }\n\n        return ans;\n    }\n}"
      }
    },
    "3114": {
      "solution": {
        "enumeration": ""
      }
    },
    "3115": {
      "solution": {
        "number-theory": "class Solution {\npublic:\n    int maximumPrimeDifference(vector<int>& nums) {\n        constexpr int kMax = 100;\n        const vector<bool> isPrime = sieveEratosthenes(kMax + 1);\n        int minPrimeIndex = -1;\n        int maxPrimeIndex = -1;\n\n        for (int i = 0; i < nums.size(); ++i)\n            if (isPrime[nums[i]]) {\n                if (minPrimeIndex == -1)\n                    minPrimeIndex = i;\n                maxPrimeIndex = i;\n            }\n\n        return maxPrimeIndex - minPrimeIndex;\n    }\n\nprivate:\n    vector<bool> sieveEratosthenes(int n) {\n        vector<bool> isPrime(n, true);\n        isPrime[0] = false;\n        isPrime[1] = false;\n        for (int i = 2; i * i < n; ++i)\n            if (isPrime[i])\n                for (int j = i * i; j < n; j += i)\n                    isPrime[j] = false;\n        return isPrime;\n    }\n};"
      }
    },
    "3116": {
      "solution": {
        "combinatorics": ""
      }
    },
    "3117": {
      "solution": {
        "queue": ""
      }
    },
    "3118": {
      "solution": {
        "database": ""
      }
    },
    "3119": {
      "solution": {
        "greedy": ""
      }
    },
    "3120": {
      "solution": {
        "hash-table": ""
      }
    },
    "3121": {
      "solution": {
        "hash-table": ""
      }
    },
    "3122": {
      "solution": {
        "matrix": ""
      }
    },
    "3123": {
      "solution": {
        "shortest-path": "class Solution {\npublic:\n    vector<bool> findAnswer(int n, vector<vector<int>>& edges) {\n        vector<bool> ans;\n        vector<vector<pair<int, int>>> graph(n);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            const int w = edge[2];\n            graph[u].emplace_back(v, w);\n            graph[v].emplace_back(u, w);\n        }\n\n        const vector<int> from0 = dijkstra(graph, 0);\n        const vector<int> from1 = dijkstra(graph, n - 1);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            const int w = edge[2];\n            ans.push_back(from0[u] + w + from1[v] == from0[n - 1] ||\n                          from0[v] + w + from1[u] == from0[n - 1]);\n        }\n\n        return ans;\n    }\n\nprivate:\n    static constexpr int kMax = 1'000'000'000;\n\n    vector<int> dijkstra(const vector<vector<pair<int, int>>>& graph, int src) {\n        vector<int> dist(graph.size(), kMax);\n\n        dist[src] = 0;\n        using P = pair<int, int>; // (d, u)\n        priority_queue<P, vector<P>, greater<>> minHeap;\n        minHeap.emplace(dist[src], src);\n\n        while (!minHeap.empty()) {\n            const auto [d, u] = minHeap.top();\n            minHeap.pop();\n            if (d > dist[u])\n                continue;\n            for (const auto& [v, w] : graph[u])\n                if (d + w < dist[v]) {\n                    dist[v] = d + w;\n                    minHeap.emplace(dist[v], v);\n                }\n        }\n\n        return dist;\n    }\n};"
      }
    },
    "3124": {
      "solution": {
        "database": ""
      }
    },
    "3125": {
      "solution": {
        "greedy": ""
      }
    },
    "3126": {
      "solution": {
        "database": ""
      }
    },
    "3127": {
      "solution": {
        "matrix": "class Solution {\n  public boolean canMakeSquare(char[][] grid) {\n    for (int i = 0; i < 2; ++i)\n      for (int j = 0; j < 2; ++j) {\n        int black = 0;\n        int white = 0;\n        for (int x = 0; x < 2; ++x)\n          for (int y = 0; y < 2; ++y)\n            if (grid[i + x][j + y] == 'B')\n              ++black;\n            else\n              ++white;\n        if (black >= 3 || white >= 3)\n          return true;\n      }\n    return false;\n  }\n}"
      }
    },
    "3128": {
      "solution": {
        "combinatorics": ""
      }
    },
    "3129": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "3130": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "3131": {
      "solution": {
        "array": ""
      }
    },
    "3132": {
      "solution": {
        "two-pointers": ""
      }
    },
    "3133": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "3134": {
      "solution": {
        "sliding-window": "class Solution {\n    public int medianOfUniquenessArray(int[] nums) {\n        int n = nums.length;\n        long subarrayCount = n * (n + 1L) / 2;\n        long medianCount = (subarrayCount + 1) / 2;\n        int left = 1;\n        int right = n;\n\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (subarrayWithAtMostackDistinct(nums, mid) >= medianCount)\n                right = mid;\n            else\n                left = mid + 1;\n        }\n\n        return left;\n    }\n\n    private long subarrayWithAtMostackDistinct(int[] nums, int k) {\n        long res = 0;\n        HashMap<Integer, Integer> count = new HashMap<>();\n\n        for (int left = 0, right = 0; right < nums.length; ++right) {\n            if (count.merge(nums[right], 1, Integer::sum) == 1)\n                --k;\n            while (k == -1)\n                if (count.merge(nums[left++], -1, Integer::sum) == 0)\n                    ++k;\n            res += right - left + 1;\n        }\n\n        return res;\n    }\n}"
      }
    },
    "3135": {
      "solution": {
        "sliding-window": "class Solution {\n    public int minOperations(String initial, String target) {\n        int m = initial.length(), n = target.length();\n        int[][] dp = new int[m + 1][n + 1];\n        int mx = 0;\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                if (initial.charAt(i - 1) == target.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                    mx = Math.max(mx, dp[i][j]);\n                }\n            }\n        }\n        return m + n - 2 * mx;\n    }\n}"
      }
    },
    "3136": {
      "solution": {
        "string": ""
      }
    },
    "3137": {
      "solution": {
        "counting": ""
      }
    },
    "3138": {
      "solution": {
        "counting": ""
      }
    },
    "3139": {
      "solution": {
        "enumeration": ""
      }
    },
    "3140": {
      "solution": {
        "database": ""
      }
    },
    "3141": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "3142": {
      "solution": {
        "matrix": ""
      }
    },
    "3143": {
      "solution": {
        "sorting": ""
      }
    },
    "3144": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3145": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "3146": {
      "solution": {
        "hash-table": ""
      }
    },
    "3147": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "3148": {
      "solution": {
        "matrix": ""
      }
    },
    "3149": {
      "solution": {
        "bitmask": "class Solution {\npublic:\n    vector<int> findPermutation(vector<int>& nums) {\n        const int n = nums.size();\n        vector<vector<int>> mem(n, vector<int>(1 << n));\n        // bestPick[last][mask] := the best pick, where `last` is the last\n        // chosen number and `mask` is the bitmask of the chosen numbers\n        vector<vector<int>> bestPick(n, vector<int>(1 << n));\n\n        getScore(nums, 0, 1, bestPick, mem);\n        return construct(bestPick);\n    }\n\nprivate:\n    // Returns the minimum score, where `last` is the last chosen number and\n    // `mask` is the bitmask of the chosen numbers.\n    int getScore(const vector<int>& nums, int last, unsigned mask,\n                 vector<vector<int>>& bestPick, vector<vector<int>>& mem) {\n        if (popcount(mask) == nums.size())\n            return abs(last - nums[0]); // |perm[n - 1] - nums[perm[0]]|\n        if (mem[last][mask] > 0)\n            return mem[last][mask];\n\n        int minScore = INT_MAX;\n        for (int i = 1; i < nums.size(); ++i) {\n            if (mask >> i & 1)\n                continue;\n            const int nextMinScore =\n                abs(last - nums[i]) +\n                getScore(nums, i, mask | 1 << i, bestPick, mem);\n            if (nextMinScore < minScore) {\n                minScore = nextMinScore;\n                bestPick[last][mask] = i;\n            }\n        }\n\n        return mem[last][mask] = minScore;\n    }\n\n    vector<int> construct(const vector<vector<int>>& bestPick) {\n        vector<int> ans;\n        int last = 0;\n        int mask = 1;\n        for (int i = 0; i < bestPick.size(); ++i) {\n            ans.push_back(last);\n            last = bestPick[last][mask];\n            mask |= 1 << last;\n        }\n        return ans;\n    }\n};"
      }
    },
    "3150": {
      "solution": {
        "database": ""
      }
    },
    "3151": {
      "solution": {
        "array": ""
      }
    },
    "3152": {
      "solution": {
        "prefix-sum": ""
      }
    },
    "3153": {
      "solution": {
        "counting": ""
      }
    },
    "3154": {
      "solution": {
        "dynamic-programming": "",
        "memoization": "class Solution {\n    HashMap<String, Integer> memoizeMap = new HashMap<>();\n    int K;\n\n    public int waysToReachStair(int k) {\n\n        K = k;\n        int index = 1;\n        int jump = 0;\n        boolean canJumpBack = true;\n\n        return solve(index, jump, canJumpBack);\n    }\n\n    public int solve(int index, int jump, boolean canJumpBack) {\n\n        if (index > K + 1) {\n            return 0;\n        }\n\n        String str = String.valueOf(index) + \"_\" + String.valueOf(jump) + \"_\" + String.valueOf(canJumpBack);\n\n        if (memoizeMap.containsKey(str)) {\n\n            return memoizeMap.get(str);\n        }\n\n        int totalWays = 0;\n\n        if (index == K) {\n            totalWays++;\n        }\n\n        if (canJumpBack == true) {\n\n            totalWays += solve(index - 1, jump, false);\n        }\n        totalWays += solve(index + (int) Math.pow(2, jump), jump + 1, true);\n        memoizeMap.put(str, totalWays);\n\n        return totalWays;\n    }\n}"
      }
    },
    "3155": {
      "solution": {
        "math": ""
      }
    },
    "3156": {
      "solution": {
        "database": ""
      }
    },
    "3157": {
      "solution": {
        "breadth-first-search": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minimumLevel(TreeNode* root) {\n        queue<TreeNode*> q{{root}};\n        int ans = 0;\n        long long s = 1LL << 60;\n        for (int level = 1; q.size(); ++level) {\n            long long t = 0;\n            for (int m = q.size(); m; --m) {\n                TreeNode* node = q.front();\n                q.pop();\n                t += node->val;\n                if (node->left) {\n                    q.push(node->left);\n                }\n                if (node->right) {\n                    q.push(node->right);\n                }\n            }\n            if (s > t) {\n                s = t;\n                ans = level;\n            }\n        }\n        return ans;\n    }\n};"
      }
    },
    "3158": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "3159": {
      "solution": {
        "hash-table": ""
      }
    },
    "3160": {
      "solution": {
        "hash-table": ""
      }
    },
    "3161": {
      "solution": {
        "array": ""
      }
    },
    "3162": {
      "solution": {
        "hash-table": ""
      }
    },
    "3163": {
      "solution": {
        "string": ""
      }
    },
    "3164": {
      "solution": {
        "hash-table": ""
      }
    },
    "3165": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3166": {
      "solution": {
        "database": ""
      }
    },
    "3167": {
      "solution": {
        "counting": "class Solution {\n public:\n  string betterCompression(string compressed) {\n    string ans;\n    vector<int> count(26);\n\n    for (int i = 0; i < compressed.length();) {\n      const char c = compressed[i++];\n      int freq = 0;\n      while (i < compressed.length() && isdigit(compressed[i]))\n        freq = freq * 10 + (compressed[i++] - '0');\n      count[c - 'a'] += freq;\n    }\n\n    for (char c = 'a'; c <= 'z'; ++c)\n      if (count[c - 'a'] > 0)\n        ans += c + to_string(count[c - 'a']);\n\n    return ans;\n  }\n};"
      }
    },
    "3168": {
      "solution": {
        "string": ""
      }
    },
    "3169": {
      "solution": {
        "sorting": ""
      }
    },
    "3170": {
      "solution": {
        "heap-(priority-queue)": ""
      }
    },
    "3171": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "3172": {
      "solution": {
        "database": ""
      }
    },
    "3173": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "3174": {
      "solution": {
        "hash-table": ""
      }
    },
    "3175": {
      "solution": {
        "array": ""
      }
    },
    "3176": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3177": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3178": {
      "solution": {
        "math": ""
      }
    },
    "3179": {
      "solution": {
        "array": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int valueAfterKSeconds(int n, int k) {\n        const int MOD = 1e9 + 7;\n        vector<int> dp(n, 1); \n        \n        for (int second = 0; second < k; ++second) {\n            for (int i = 1; i < n; ++i) {\n                dp[i] = (dp[i] + dp[i - 1]) % MOD; /\n            }\n        }\n        \n        return dp[n - 1]; \n    }\n};\n"
      }
    },
    "3180": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3181": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3182": {
      "solution": {
        "database": ""
      }
    },
    "3183": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3184": {
      "solution": {
        "counting": "class Solution {\n public:\n  int countCompleteDayPairs(vector<int>& hours) {\n    int ans = 0;\n    vector<int> count(24);\n\n    for (const int hour : hours) {\n      ans += count[(24 - hour % 24) % 24];\n      ++count[hour % 24];\n    }\n\n    return ans;\n  }\n};"
      }
    },
    "3185": {
      "solution": {
        "counting": ""
      }
    },
    "3186": {
      "solution": {
        "two-pointers": ""
      }
    },
    "3187": {
      "solution": {
        "binary-indexed-tree": "class FenwickTree {\npublic:\n    FenwickTree(int n) : sums(n + 1) {}\n\n    void add(int i, int delta) {\n        while (i < sums.size()) {\n            sums[i] += delta;\n            i += lowbit(i);\n        }\n    }\n\n    int get(int i) const {\n        int sum = 0;\n        while (i > 0) {\n            sum += sums[i];\n            i -= lowbit(i);\n        }\n        return sum;\n    }\n\nprivate:\n    vector<int> sums;\n\n    static inline int lowbit(int i) { return i & -i; }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> ans;\n        vector<int> peak = getPeak(nums);\n        FenwickTree tree(peak.size());\n\n        for (int i = 0; i < peak.size(); ++i)\n            tree.add(i + 1, peak[i]);\n\n        auto update = [&](int i) {\n            const int newPeak = isPeak(nums, i);\n            if (newPeak != peak[i]) {\n                tree.add(i + 1, newPeak - peak[i]);\n                peak[i] = newPeak;\n            }\n        };\n\n        for (const vector<int>& query : queries)\n            if (query[0] == 1) {\n                const int l = query[1];\n                const int r = query[2];\n                ans.push_back(r - l < 2 ? 0 : tree.get(r) - tree.get(l + 1));\n            } else if (query[0] == 2) {\n                const int index = query[1];\n                const int val = query[2];\n                nums[index] = val;\n                update(index);\n                if (index > 0)\n                    update(index - 1);\n                if (index + 1 < nums.size())\n                    update(index + 1);\n            }\n\n        return ans;\n    }\n\nprivate:\n    vector<int> getPeak(const vector<int>& nums) {\n        vector<int> peak(nums.size());\n        for (int i = 1; i + 1 < nums.size(); ++i)\n            peak[i] = nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n        return peak;\n    }\n\n    bool isPeak(const vector<int>& nums, int i) {\n        return i > 0 && i + 1 < nums.size() && nums[i] > nums[i - 1] &&\n               nums[i] > nums[i + 1];\n    }\n};"
      }
    },
    "3188": {
      "solution": {
        "database": ""
      }
    },
    "3189": {
      "solution": {
        "greedy": ""
      }
    },
    "3190": {
      "solution": {
        "math": ""
      }
    },
    "3191": {
      "solution": {
        "sliding-window": "class Solution {\n    public int minOperations(int[] nums) {\n        int n = nums.length;\n        int ans = 0;\n\n        for (int i = 0; i + 2 < n; ++i)\n            if (nums[i] == 0) {\n                nums[i + 1] ^= 1;\n                nums[i + 2] ^= 1;\n                ++ans;\n            }\n\n        return nums[n - 1] == 0 || nums[n - 2] == 0 ? -1 : ans;\n    }\n}"
      }
    },
    "3192": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3193": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3194": {
      "solution": {
        "two-pointers": "import java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public double minimumAverage(int[] nums) {\n        Arrays.sort(nums); \n        List<Double> averages = new ArrayList<>();\n        int left = 0, right = nums.length - 1;\n        \n        while (left < right) {\n            int min = nums[left++];\n            int max = nums[right--];\n            double avg = (min + max) / 2.0;\n            averages.add(avg);\n        }\n        \n        return averages.stream().mapToDouble(Double::doubleValue).min().orElse(0.0);\n    }\n}\n"
      }
    },
    "3195": {
      "solution": {
        "matrix": "class Solution {\n  public int minimumArea(int[][] grid) {\n    int x1 = Integer.MAX_VALUE;\n    int y1 = Integer.MAX_VALUE;\n    int x2 = 0;\n    int y2 = 0;\n\n    for (int i = 0; i < grid.length; ++i)\n      for (int j = 0; j < grid[0].length; ++j)\n        if (grid[i][j] == 1) {\n          x1 = Math.min(x1, i);\n          y1 = Math.min(y1, j);\n          x2 = Math.max(x2, i);\n          y2 = Math.max(y2, j);\n        }\n\n    return (x2 - x1 + 1) * (y2 - y1 + 1);\n  }\n}"
      }
    },
    "3196": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3197": {
      "solution": {
        "matrix": "class Solution {\n  public int minimumSum(int[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    int ans = m * n;\n\n    for (int i = 0; i < m; ++i) {\n      int top = minimumArea(grid, 0, i, 0, n - 1);\n      for (int j = 0; j < n; ++j)\n        ans = Math.min(ans, top + /*left*/ minimumArea(grid, i + 1, m - 1, 0, j) +\n                                /*right*/ minimumArea(grid, i + 1, m - 1, j + 1, n - 1));\n    }\n\n    for (int i = 0; i < m; ++i) {\n      int bottom = minimumArea(grid, i, m - 1, 0, n - 1);\n      for (int j = 0; j < n; ++j)\n        ans = Math.min(ans, bottom + /*left*/ minimumArea(grid, 0, i - 1, 0, j) +\n                                /*right*/ minimumArea(grid, 0, i - 1, j + 1, n - 1));\n    }\n\n    for (int j = 0; j < n; ++j) {\n      int left = minimumArea(grid, 0, m - 1, 0, j);\n      for (int i = 0; i < m; ++i)\n        ans = Math.min(ans, left + /*top*/ minimumArea(grid, 0, i, j + 1, n - 1) +\n                                /*bottom*/ minimumArea(grid, i + 1, m - 1, j + 1, n - 1));\n    }\n\n    for (int j = 0; j < n; ++j) {\n      int right = minimumArea(grid, 0, m - 1, j, n - 1);\n      for (int i = 0; i < m; ++i)\n        ans = Math.min(ans, right + /*top*/ minimumArea(grid, 0, i, 0, j - 1) +\n                                /*bottom*/ minimumArea(grid, i + 1, m - 1, 0, j - 1));\n    }\n\n    for (int i1 = 0; i1 < m; ++i1)\n      for (int i2 = i1 + 1; i2 < m; ++i2)\n        ans = Math.min(ans, /*top*/ minimumArea(grid, 0, i1, 0, n - 1) +\n                                /*middle*/ minimumArea(grid, i1 + 1, i2, 0, n - 1) +\n                                /*bottom*/ minimumArea(grid, i2 + 1, m - 1, 0, n - 1));\n\n    for (int j1 = 0; j1 < n; ++j1)\n      for (int j2 = j1 + 1; j2 < n; ++j2)\n        ans = Math.min(ans, /*left*/ minimumArea(grid, 0, m - 1, 0, j1) +\n                                /*middle*/ minimumArea(grid, 0, m - 1, j1 + 1, j2) +\n                                /*right*/ minimumArea(grid, 0, m - 1, j2 + 1, n - 1));\n\n    return ans;\n  }\n\n  private int minimumArea(int[][] grid, int si, int ei, int sj, int ej) {\n    int x1 = Integer.MAX_VALUE;\n    int y1 = Integer.MAX_VALUE;\n    int x2 = 0;\n    int y2 = 0;\n    for (int i = si; i <= ei; ++i)\n      for (int j = sj; j <= ej; ++j)\n        if (grid[i][j] == 1) {\n          x1 = Math.min(x1, i);\n          y1 = Math.min(y1, j);\n          x2 = Math.max(x2, i);\n          y2 = Math.max(y2, j);\n        }\n    return x1 == Integer.MAX_VALUE ? 0 : (x2 - x1 + 1) * (y2 - y1 + 1);\n  }\n}"
      }
    },
    "3198": {
      "solution": {
        "database": ""
      }
    },
    "3199": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "3200": {
      "solution": {
        "enumeration": "class Solution {\npublic:\n    int maxHeightOfTriangle(int red, int blue) {\n        return max(maxHeight(red, blue), maxHeight(blue, red));\n    }\n\nprivate:\n    // Returns the maximum height of a triangle with the odd levels having `n1`\n    // balls and the even levels having `n2` balls.\n    int maxHeight(int n1, int n2) {\n        //             1 + 3 + ... + h <= n1\n        // ((1 + h) * (n + 1) / 2) / 2 <= n1\n        //                           h <= sqrt(4 * n1) - 1\n        const int oddHeight = sqrt(4 * n1) - 1;\n        //       2 + 4 + ... + h <= n2\n        // ((2 + h) * h / 2) / 2 <= n2\n        //                     h <= sqrt(4 * n2 + 1) - 1\n        const int evenHeight = sqrt(4 * n2 + 1) - 1;\n        // If the difference between the odd and even heights is >= 1, we can\n        // add an extra level to the minimum height.\n        return min(oddHeight, evenHeight) +\n               (abs(oddHeight - evenHeight) >= 1 ? 1 : 0);\n    }\n};"
      }
    },
    "3201": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3202": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3203": {
      "solution": {
        "tree": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1,\n                                  vector<vector<int>>& edges2) {\n        const int diameter1 = getDiameter(edges1);\n        const int diameter2 = getDiameter(edges2);\n        const int combinedDiameter =\n            (diameter1 + 1) / 2 + (diameter2 + 1) / 2 + 1;\n        return max({diameter1, diameter2, combinedDiameter});\n    }\n\nprivate:\n    int getDiameter(const vector<vector<int>>& edges) {\n        const int n = edges.size() + 1;\n        vector<vector<int>> graph(n);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n        }\n\n        int maxDiameter = 0;\n        maxDepth(graph, 0, -1, maxDiameter);\n        return maxDiameter;\n    }\n\n    int maxDepth(const vector<vector<int>>& graph, int u, int prev,\n                 int& maxDiameter) {\n        int maxSubDepth1 = 0;\n        int maxSubDepth2 = 0;\n        for (const int v : graph[u]) {\n            if (v == prev)\n                continue;\n            const int maxSubDepth = maxDepth(graph, v, u, maxDiameter);\n            if (maxSubDepth > maxSubDepth1) {\n                maxSubDepth2 = maxSubDepth1;\n                maxSubDepth1 = maxSubDepth;\n            } else if (maxSubDepth > maxSubDepth2) {\n                maxSubDepth2 = maxSubDepth;\n            }\n        }\n        maxDiameter = max(maxDiameter, maxSubDepth1 + maxSubDepth2);\n        return 1 + maxSubDepth1;\n    }\n};"
      }
    },
    "3204": {
      "solution": {
        "database": ""
      }
    },
    "3205": {
      "solution": {
        "monotonic-stack": ""
      }
    },
    "3206": {
      "solution": {
        "linked-list": ""
      }
    },
    "3207": {
      "solution": {
        "greedy": ""
      }
    },
    "3208": {
      "solution": {
        "array": ""
      }
    },
    "3209": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "3210": {
      "solution": {
        "string": ""
      }
    },
    "3211": {
      "solution": {
        "recursion": ""
      }
    },
    "3212": {
      "solution": {
        "matrix": "class Solution {\n  public int numberOfSubmatrices(char[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    int ans = 0;\n    // x[i][j] := the number of 'X' in grid[0..i)[0..j)\n    int[][] x = new int[m + 1][n + 1];\n    // y[i][j] := the number of 'Y' in grid[0..i)[0..j)\n    int[][] y = new int[m + 1][n + 1];\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        x[i + 1][j + 1] = (grid[i][j] == 'X' ? 1 : 0) + x[i][j + 1] + x[i + 1][j] - x[i][j];\n        y[i + 1][j + 1] = (grid[i][j] == 'Y' ? 1 : 0) + y[i][j + 1] + y[i + 1][j] - y[i][j];\n        if (x[i + 1][j + 1] > 0 && x[i + 1][j + 1] == y[i + 1][j + 1])\n          ++ans;\n      }\n\n    return ans;\n  }\n}"
      }
    },
    "3213": {
      "solution": {
        "dynamic-programming": ""
      }
    },
    "3214": {
      "solution": {
        "database": ""
      }
    },
    "3215": {
      "solution": {
        "bit-manipulation": ""
      }
    },
    "3216": {
      "solution": {
        "greedy": ""
      }
    },
    "3217": {
      "solution": {
        "linked-list": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* modifiedList(vector<int>& nums, ListNode* head) {\n        ListNode dummy(0, head);\n        unordered_set<int> numsSet{nums.begin(), nums.end()};\n\n        for (ListNode* curr = &dummy; curr->next != nullptr;)\n            if (numsSet.contains(curr->next->val))\n                curr->next = curr->next->next;\n            else\n                curr = curr->next;\n\n        return dummy.next;\n    }\n};"
      }
    },
    "3218": {
      "solution": {
        "greedy": ""
      }
    },
    "3219": {
      "solution": {
        "greedy": ""
      }
    }
  }